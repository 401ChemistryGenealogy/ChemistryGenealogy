<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>web\bower_components\angular-mocks\angular-mocks.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/editController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">editController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/GruntFile
                
                Was attempting to do gruntdocs....html">GruntFile
                
                Was attempting to do gruntdocs...</a></li>
                                <li><a href="../classes/mentorshipNotificationController
                
                Notifications for mentorships are dealt with here..html">mentorshipNotificationController
                
                Notifications for mentorships are dealt with here.</a></li>
                                <li><a href="../classes/muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application..html">muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file..html">personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file.</a></li>
                                <li><a href="../classes/personNotificationController
                
                Notifications for persons are dealt with here..html">personNotificationController
                
                Notifications for persons are dealt with here.</a></li>
                                <li><a href="../classes/searchController
                
                Entire Search Functionality located here..html">searchController
                
                Entire Search Functionality located here.</a></li>
                                <li><a href="../classes/submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc.html">submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc</a></li>
                                <li><a href="../classes/supervisionNotificationController
                
                Notifications for supervision are dealt with here..html">supervisionNotificationController
                
                Notifications for supervision are dealt with here.</a></li>
                                <li><a href="../classes/userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions..html">userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions.</a></li>
                                <li><a href="../classes/viewController
                
                This controller does all that can be done with the view page..html">viewController
                
                This controller does all that can be done with the view page.</a></li>
                                <li><a href="../classes/visController
                
                Notifications for mentorships are dealt with here..html">visController
                
                Notifications for mentorships are dealt with here.</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/auditTrailController.html">auditTrailController</a></li>
                                <li><a href="../modules/editController.html">editController</a></li>
                                <li><a href="../modules/GruntFile.html">GruntFile</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/mentorshipNotificationController.html">mentorshipNotificationController</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                                <li><a href="../modules/personNotificationController.html">personNotificationController</a></li>
                                <li><a href="../modules/searchController.html">searchController</a></li>
                                <li><a href="../modules/submitController.html">submitController</a></li>
                                <li><a href="../modules/supervisionNotificationController.html">supervisionNotificationController</a></li>
                                <li><a href="../modules/userController.html">userController</a></li>
                                <li><a href="../modules/userDialogController.html">userDialogController</a></li>
                                <li><a href="../modules/viewController.html">viewController</a></li>
                                <li><a href="../modules/visController.html">visController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: web\bower_components\angular-mocks\angular-mocks.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @license AngularJS v1.5.0
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {

&#x27;use strict&#x27;;

/**
 * @ngdoc object
 * @name angular.mock
 * @description
 *
 * Namespace from &#x27;angular-mocks.js&#x27; which contains testing related code.
 */
angular.mock = {};

/**
 * ! This is a private undocumented service !
 *
 * @name $browser
 *
 * @description
 * This service is a mock implementation of {@link ng.$browser}. It provides fake
 * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,
 * cookies, etc...
 *
 * The api of this service is the same as that of the real {@link ng.$browser $browser}, except
 * that there are several helper methods available which can be used in tests.
 */
angular.mock.$BrowserProvider = function() {
  this.$get = function() {
    return new angular.mock.$Browser();
  };
};

angular.mock.$Browser = function() {
  var self = this;

  this.isMock = true;
  self.$$url = &quot;http://server/&quot;;
  self.$$lastUrl = self.$$url; // used by url polling fn
  self.pollFns = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = angular.noop;
  self.$$incOutstandingRequestCount = angular.noop;


  // register url polling fn

  self.onUrlChange = function(listener) {
    self.pollFns.push(
      function() {
        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
          self.$$lastUrl = self.$$url;
          self.$$lastState = self.$$state;
          listener(self.$$url, self.$$state);
        }
      }
    );

    return listener;
  };

  self.$$applicationDestroyed = angular.noop;
  self.$$checkUrlChange = angular.noop;

  self.deferredFns = [];
  self.deferredNextId = 0;

  self.defer = function(fn, delay) {
    delay = delay || 0;
    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});
    self.deferredFns.sort(function(a, b) { return a.time - b.time;});
    return self.deferredNextId++;
  };


  /**
   * @name $browser#defer.now
   *
   * @description
   * Current milliseconds mock time.
   */
  self.defer.now = 0;


  self.defer.cancel = function(deferId) {
    var fnIndex;

    angular.forEach(self.deferredFns, function(fn, index) {
      if (fn.id === deferId) fnIndex = index;
    });

    if (angular.isDefined(fnIndex)) {
      self.deferredFns.splice(fnIndex, 1);
      return true;
    }

    return false;
  };


  /**
   * @name $browser#defer.flush
   *
   * @description
   * Flushes all pending requests and executes the defer callbacks.
   *
   * @param {number=} number of milliseconds to flush. See {@link #defer.now}
   */
  self.defer.flush = function(delay) {
    if (angular.isDefined(delay)) {
      self.defer.now += delay;
    } else {
      if (self.deferredFns.length) {
        self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
      } else {
        throw new Error(&#x27;No deferred tasks to be flushed&#x27;);
      }
    }

    while (self.deferredFns.length &amp;&amp; self.deferredFns[0].time &lt;= self.defer.now) {
      self.deferredFns.shift().fn();
    }
  };

  self.$$baseHref = &#x27;/&#x27;;
  self.baseHref = function() {
    return this.$$baseHref;
  };
};
angular.mock.$Browser.prototype = {

/**
  * @name $browser#poll
  *
  * @description
  * run all fns in pollFns
  */
  poll: function poll() {
    angular.forEach(this.pollFns, function(pollFn) {
      pollFn();
    });
  },

  url: function(url, replace, state) {
    if (angular.isUndefined(state)) {
      state = null;
    }
    if (url) {
      this.$$url = url;
      // Native pushState serializes &amp; copies the object; simulate it.
      this.$$state = angular.copy(state);
      return this;
    }

    return this.$$url;
  },

  state: function() {
    return this.$$state;
  },

  notifyWhenNoOutstandingRequests: function(fn) {
    fn();
  }
};


/**
 * @ngdoc provider
 * @name $exceptionHandlerProvider
 *
 * @description
 * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors
 * passed to the &#x60;$exceptionHandler&#x60;.
 */

/**
 * @ngdoc service
 * @name $exceptionHandler
 *
 * @description
 * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed
 * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration
 * information.
 *
 *
 * &#x60;&#x60;&#x60;js
 *   describe(&#x27;$exceptionHandlerProvider&#x27;, function() {
 *
 *     it(&#x27;should capture log messages and exceptions&#x27;, function() {
 *
 *       module(function($exceptionHandlerProvider) {
 *         $exceptionHandlerProvider.mode(&#x27;log&#x27;);
 *       });
 *
 *       inject(function($log, $exceptionHandler, $timeout) {
 *         $timeout(function() { $log.log(1); });
 *         $timeout(function() { $log.log(2); throw &#x27;banana peel&#x27;; });
 *         $timeout(function() { $log.log(3); });
 *         expect($exceptionHandler.errors).toEqual([]);
 *         expect($log.assertEmpty());
 *         $timeout.flush();
 *         expect($exceptionHandler.errors).toEqual([&#x27;banana peel&#x27;]);
 *         expect($log.log.logs).toEqual([[1], [2], [3]]);
 *       });
 *     });
 *   });
 * &#x60;&#x60;&#x60;
 */

angular.mock.$ExceptionHandlerProvider = function() {
  var handler;

  /**
   * @ngdoc method
   * @name $exceptionHandlerProvider#mode
   *
   * @description
   * Sets the logging mode.
   *
   * @param {string} mode Mode of operation, defaults to &#x60;rethrow&#x60;.
   *
   *   - &#x60;log&#x60;: Sometimes it is desirable to test that an error is thrown, for this case the &#x60;log&#x60;
   *            mode stores an array of errors in &#x60;$exceptionHandler.errors&#x60;, to allow later
   *            assertion of them. See {@link ngMock.$log#assertEmpty assertEmpty()} and
   *            {@link ngMock.$log#reset reset()}
   *   - &#x60;rethrow&#x60;: If any errors are passed to the handler in tests, it typically means that there
   *                is a bug in the application or test, so this mock will make these tests fail.
   *                For any implementations that expect exceptions to be thrown, the &#x60;rethrow&#x60; mode
   *                will also maintain a log of thrown errors.
   */
  this.mode = function(mode) {

    switch (mode) {
      case &#x27;log&#x27;:
      case &#x27;rethrow&#x27;:
        var errors = [];
        handler = function(e) {
          if (arguments.length == 1) {
            errors.push(e);
          } else {
            errors.push([].slice.call(arguments, 0));
          }
          if (mode === &quot;rethrow&quot;) {
            throw e;
          }
        };
        handler.errors = errors;
        break;
      default:
        throw new Error(&quot;Unknown mode &#x27;&quot; + mode + &quot;&#x27;, only &#x27;log&#x27;/&#x27;rethrow&#x27; modes are allowed!&quot;);
    }
  };

  this.$get = function() {
    return handler;
  };

  this.mode(&#x27;rethrow&#x27;);
};


/**
 * @ngdoc service
 * @name $log
 *
 * @description
 * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays
 * (one array per logging level). These arrays are exposed as &#x60;logs&#x60; property of each of the
 * level-specific log function, e.g. for level &#x60;error&#x60; the array is exposed as &#x60;$log.error.logs&#x60;.
 *
 */
angular.mock.$LogProvider = function() {
  var debug = true;

  function concat(array1, array2, index) {
    return array1.concat(Array.prototype.slice.call(array2, index));
  }

  this.debugEnabled = function(flag) {
    if (angular.isDefined(flag)) {
      debug = flag;
      return this;
    } else {
      return debug;
    }
  };

  this.$get = function() {
    var $log = {
      log: function() { $log.log.logs.push(concat([], arguments, 0)); },
      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },
      info: function() { $log.info.logs.push(concat([], arguments, 0)); },
      error: function() { $log.error.logs.push(concat([], arguments, 0)); },
      debug: function() {
        if (debug) {
          $log.debug.logs.push(concat([], arguments, 0));
        }
      }
    };

    /**
     * @ngdoc method
     * @name $log#reset
     *
     * @description
     * Reset all of the logging arrays to empty.
     */
    $log.reset = function() {
      /**
       * @ngdoc property
       * @name $log#log.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#log &#x60;log()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.log(&#x27;Some Log&#x27;);
       * var first = $log.log.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.log.logs = [];
      /**
       * @ngdoc property
       * @name $log#info.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#info &#x60;info()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.info(&#x27;Some Info&#x27;);
       * var first = $log.info.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.info.logs = [];
      /**
       * @ngdoc property
       * @name $log#warn.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#warn &#x60;warn()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.warn(&#x27;Some Warning&#x27;);
       * var first = $log.warn.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.warn.logs = [];
      /**
       * @ngdoc property
       * @name $log#error.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#error &#x60;error()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.error(&#x27;Some Error&#x27;);
       * var first = $log.error.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.error.logs = [];
        /**
       * @ngdoc property
       * @name $log#debug.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#debug &#x60;debug()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.debug(&#x27;Some Error&#x27;);
       * var first = $log.debug.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.debug.logs = [];
    };

    /**
     * @ngdoc method
     * @name $log#assertEmpty
     *
     * @description
     * Assert that all of the logging methods have no logged messages. If any messages are present,
     * an exception is thrown.
     */
    $log.assertEmpty = function() {
      var errors = [];
      angular.forEach([&#x27;error&#x27;, &#x27;warn&#x27;, &#x27;info&#x27;, &#x27;log&#x27;, &#x27;debug&#x27;], function(logLevel) {
        angular.forEach($log[logLevel].logs, function(log) {
          angular.forEach(log, function(logItem) {
            errors.push(&#x27;MOCK $log (&#x27; + logLevel + &#x27;): &#x27; + String(logItem) + &#x27;\n&#x27; +
                        (logItem.stack || &#x27;&#x27;));
          });
        });
      });
      if (errors.length) {
        errors.unshift(&quot;Expected $log to be empty! Either a message was logged unexpectedly, or &quot; +
          &quot;an expected log message was not checked and removed:&quot;);
        errors.push(&#x27;&#x27;);
        throw new Error(errors.join(&#x27;\n---------\n&#x27;));
      }
    };

    $log.reset();
    return $log;
  };
};


/**
 * @ngdoc service
 * @name $interval
 *
 * @description
 * Mock implementation of the $interval service.
 *
 * Use {@link ngMock.$interval#flush &#x60;$interval.flush(millis)&#x60;} to
 * move forward by &#x60;millis&#x60; milliseconds and trigger any functions scheduled to run in that
 * time.
 *
 * @param {function()} fn A function that should be called repeatedly.
 * @param {number} delay Number of milliseconds between each function call.
 * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
 *   indefinitely.
 * @param {boolean=} [invokeApply=true] If set to &#x60;false&#x60; skips model dirty checking, otherwise
 *   will invoke &#x60;fn&#x60; within the {@link ng.$rootScope.Scope#$apply $apply} block.
 * @param {...*=} Pass additional parameters to the executed function.
 * @returns {promise} A promise which will be notified on each iteration.
 */
angular.mock.$IntervalProvider = function() {
  this.$get = [&#x27;$browser&#x27;, &#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$$q&#x27;,
       function($browser,   $rootScope,   $q,   $$q) {
    var repeatFns = [],
        nextRepeatId = 0,
        now = 0;

    var $interval = function(fn, delay, count, invokeApply) {
      var hasParams = arguments.length &gt; 4,
          args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],
          iteration = 0,
          skipApply = (angular.isDefined(invokeApply) &amp;&amp; !invokeApply),
          deferred = (skipApply ? $$q : $q).defer(),
          promise = deferred.promise;

      count = (angular.isDefined(count)) ? count : 0;
      promise.then(null, null, (!hasParams) ? fn : function() {
        fn.apply(null, args);
      });

      promise.$$intervalId = nextRepeatId;

      function tick() {
        deferred.notify(iteration++);

        if (count &gt; 0 &amp;&amp; iteration &gt;= count) {
          var fnIndex;
          deferred.resolve(iteration);

          angular.forEach(repeatFns, function(fn, index) {
            if (fn.id === promise.$$intervalId) fnIndex = index;
          });

          if (angular.isDefined(fnIndex)) {
            repeatFns.splice(fnIndex, 1);
          }
        }

        if (skipApply) {
          $browser.defer.flush();
        } else {
          $rootScope.$apply();
        }
      }

      repeatFns.push({
        nextTime:(now + delay),
        delay: delay,
        fn: tick,
        id: nextRepeatId,
        deferred: deferred
      });
      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});

      nextRepeatId++;
      return promise;
    };
    /**
     * @ngdoc method
     * @name $interval#cancel
     *
     * @description
     * Cancels a task associated with the &#x60;promise&#x60;.
     *
     * @param {promise} promise A promise from calling the &#x60;$interval&#x60; function.
     * @returns {boolean} Returns &#x60;true&#x60; if the task was successfully cancelled.
     */
    $interval.cancel = function(promise) {
      if (!promise) return false;
      var fnIndex;

      angular.forEach(repeatFns, function(fn, index) {
        if (fn.id === promise.$$intervalId) fnIndex = index;
      });

      if (angular.isDefined(fnIndex)) {
        repeatFns[fnIndex].deferred.reject(&#x27;canceled&#x27;);
        repeatFns.splice(fnIndex, 1);
        return true;
      }

      return false;
    };

    /**
     * @ngdoc method
     * @name $interval#flush
     * @description
     *
     * Runs interval tasks scheduled to be run in the next &#x60;millis&#x60; milliseconds.
     *
     * @param {number=} millis maximum timeout amount to flush up until.
     *
     * @return {number} The amount of time moved forward.
     */
    $interval.flush = function(millis) {
      now += millis;
      while (repeatFns.length &amp;&amp; repeatFns[0].nextTime &lt;= now) {
        var task = repeatFns[0];
        task.fn();
        task.nextTime += task.delay;
        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});
      }
      return millis;
    };

    return $interval;
  }];
};


/* jshint -W101 */
/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!
 * This directive should go inside the anonymous function but a bug in JSHint means that it would
 * not be enacted early enough to prevent the warning.
 */
var R_ISO8061_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;

function jsonStringToDate(string) {
  var match;
  if (match = string.match(R_ISO8061_STR)) {
    var date = new Date(0),
        tzHour = 0,
        tzMin  = 0;
    if (match[9]) {
      tzHour = toInt(match[9] + match[10]);
      tzMin = toInt(match[9] + match[11]);
    }
    date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
    date.setUTCHours(toInt(match[4] || 0) - tzHour,
                     toInt(match[5] || 0) - tzMin,
                     toInt(match[6] || 0),
                     toInt(match[7] || 0));
    return date;
  }
  return string;
}

function toInt(str) {
  return parseInt(str, 10);
}

function padNumber(num, digits, trim) {
  var neg = &#x27;&#x27;;
  if (num &lt; 0) {
    neg =  &#x27;-&#x27;;
    num = -num;
  }
  num = &#x27;&#x27; + num;
  while (num.length &lt; digits) num = &#x27;0&#x27; + num;
  if (trim) {
    num = num.substr(num.length - digits);
  }
  return neg + num;
}


/**
 * @ngdoc type
 * @name angular.mock.TzDate
 * @description
 *
 * *NOTE*: this is not an injectable instance, just a globally available mock class of &#x60;Date&#x60;.
 *
 * Mock of the Date type which has its timezone specified via constructor arg.
 *
 * The main purpose is to create Date-like instances with timezone fixed to the specified timezone
 * offset, so that we can test code that depends on local timezone settings without dependency on
 * the time zone settings of the machine where the code is running.
 *
 * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)
 * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*
 *
 * @example
 * !!!! WARNING !!!!!
 * This is not a complete Date object so only methods that were implemented can be called safely.
 * To make matters worse, TzDate instances inherit stuff from Date via a prototype.
 *
 * We do our best to intercept calls to &quot;unimplemented&quot; methods, but since the list of methods is
 * incomplete we might be missing some non-standard methods. This can result in errors like:
 * &quot;Date.prototype.foo called on incompatible Object&quot;.
 *
 * &#x60;&#x60;&#x60;js
 * var newYearInBratislava = new TzDate(-1, &#x27;2009-12-31T23:00:00Z&#x27;);
 * newYearInBratislava.getTimezoneOffset() =&gt; -60;
 * newYearInBratislava.getFullYear() =&gt; 2010;
 * newYearInBratislava.getMonth() =&gt; 0;
 * newYearInBratislava.getDate() =&gt; 1;
 * newYearInBratislava.getHours() =&gt; 0;
 * newYearInBratislava.getMinutes() =&gt; 0;
 * newYearInBratislava.getSeconds() =&gt; 0;
 * &#x60;&#x60;&#x60;
 *
 */
angular.mock.TzDate = function(offset, timestamp) {
  var self = new Date(0);
  if (angular.isString(timestamp)) {
    var tsStr = timestamp;

    self.origDate = jsonStringToDate(timestamp);

    timestamp = self.origDate.getTime();
    if (isNaN(timestamp)) {
      throw {
        name: &quot;Illegal Argument&quot;,
        message: &quot;Arg &#x27;&quot; + tsStr + &quot;&#x27; passed into TzDate constructor is not a valid date string&quot;
      };
    }
  } else {
    self.origDate = new Date(timestamp);
  }

  var localOffset = new Date(timestamp).getTimezoneOffset();
  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
  self.date = new Date(timestamp + self.offsetDiff);

  self.getTime = function() {
    return self.date.getTime() - self.offsetDiff;
  };

  self.toLocaleDateString = function() {
    return self.date.toLocaleDateString();
  };

  self.getFullYear = function() {
    return self.date.getFullYear();
  };

  self.getMonth = function() {
    return self.date.getMonth();
  };

  self.getDate = function() {
    return self.date.getDate();
  };

  self.getHours = function() {
    return self.date.getHours();
  };

  self.getMinutes = function() {
    return self.date.getMinutes();
  };

  self.getSeconds = function() {
    return self.date.getSeconds();
  };

  self.getMilliseconds = function() {
    return self.date.getMilliseconds();
  };

  self.getTimezoneOffset = function() {
    return offset * 60;
  };

  self.getUTCFullYear = function() {
    return self.origDate.getUTCFullYear();
  };

  self.getUTCMonth = function() {
    return self.origDate.getUTCMonth();
  };

  self.getUTCDate = function() {
    return self.origDate.getUTCDate();
  };

  self.getUTCHours = function() {
    return self.origDate.getUTCHours();
  };

  self.getUTCMinutes = function() {
    return self.origDate.getUTCMinutes();
  };

  self.getUTCSeconds = function() {
    return self.origDate.getUTCSeconds();
  };

  self.getUTCMilliseconds = function() {
    return self.origDate.getUTCMilliseconds();
  };

  self.getDay = function() {
    return self.date.getDay();
  };

  // provide this method only on browsers that already have it
  if (self.toISOString) {
    self.toISOString = function() {
      return padNumber(self.origDate.getUTCFullYear(), 4) + &#x27;-&#x27; +
            padNumber(self.origDate.getUTCMonth() + 1, 2) + &#x27;-&#x27; +
            padNumber(self.origDate.getUTCDate(), 2) + &#x27;T&#x27; +
            padNumber(self.origDate.getUTCHours(), 2) + &#x27;:&#x27; +
            padNumber(self.origDate.getUTCMinutes(), 2) + &#x27;:&#x27; +
            padNumber(self.origDate.getUTCSeconds(), 2) + &#x27;.&#x27; +
            padNumber(self.origDate.getUTCMilliseconds(), 3) + &#x27;Z&#x27;;
    };
  }

  //hide all methods not implemented in this mock that the Date prototype exposes
  var unimplementedMethods = [&#x27;getUTCDay&#x27;,
      &#x27;getYear&#x27;, &#x27;setDate&#x27;, &#x27;setFullYear&#x27;, &#x27;setHours&#x27;, &#x27;setMilliseconds&#x27;,
      &#x27;setMinutes&#x27;, &#x27;setMonth&#x27;, &#x27;setSeconds&#x27;, &#x27;setTime&#x27;, &#x27;setUTCDate&#x27;, &#x27;setUTCFullYear&#x27;,
      &#x27;setUTCHours&#x27;, &#x27;setUTCMilliseconds&#x27;, &#x27;setUTCMinutes&#x27;, &#x27;setUTCMonth&#x27;, &#x27;setUTCSeconds&#x27;,
      &#x27;setYear&#x27;, &#x27;toDateString&#x27;, &#x27;toGMTString&#x27;, &#x27;toJSON&#x27;, &#x27;toLocaleFormat&#x27;, &#x27;toLocaleString&#x27;,
      &#x27;toLocaleTimeString&#x27;, &#x27;toSource&#x27;, &#x27;toString&#x27;, &#x27;toTimeString&#x27;, &#x27;toUTCString&#x27;, &#x27;valueOf&#x27;];

  angular.forEach(unimplementedMethods, function(methodName) {
    self[methodName] = function() {
      throw new Error(&quot;Method &#x27;&quot; + methodName + &quot;&#x27; is not implemented in the TzDate mock&quot;);
    };
  });

  return self;
};

//make &quot;tzDateInstance instanceof Date&quot; return true
angular.mock.TzDate.prototype = Date.prototype;
/* jshint +W101 */


/**
 * @ngdoc service
 * @name $animate
 *
 * @description
 * Mock implementation of the {@link ng.$animate &#x60;$animate&#x60;} service. Exposes two additional methods
 * for testing animations.
 */
angular.mock.animate = angular.module(&#x27;ngAnimateMock&#x27;, [&#x27;ng&#x27;])

  .config([&#x27;$provide&#x27;, function($provide) {

    $provide.factory(&#x27;$$forceReflow&#x27;, function() {
      function reflowFn() {
        reflowFn.totalReflows++;
      }
      reflowFn.totalReflows = 0;
      return reflowFn;
    });

    $provide.factory(&#x27;$$animateAsyncRun&#x27;, function() {
      var queue = [];
      var queueFn = function() {
        return function(fn) {
          queue.push(fn);
        };
      };
      queueFn.flush = function() {
        if (queue.length === 0) return false;

        for (var i = 0; i &lt; queue.length; i++) {
          queue[i]();
        }
        queue = [];

        return true;
      };
      return queueFn;
    });

    $provide.decorator(&#x27;$$animateJs&#x27;, [&#x27;$delegate&#x27;, function($delegate) {
      var runners = [];

      var animateJsConstructor = function() {
        var animator = $delegate.apply($delegate, arguments);
        // If no javascript animation is found, animator is undefined
        if (animator) {
          runners.push(animator);
        }
        return animator;
      };

      animateJsConstructor.$closeAndFlush = function() {
        runners.forEach(function(runner) {
          runner.end();
        });
        runners = [];
      };

      return animateJsConstructor;
    }]);

    $provide.decorator(&#x27;$animateCss&#x27;, [&#x27;$delegate&#x27;, function($delegate) {
      var runners = [];

      var animateCssConstructor = function(element, options) {
        var animator = $delegate(element, options);
        runners.push(animator);
        return animator;
      };

      animateCssConstructor.$closeAndFlush = function() {
        runners.forEach(function(runner) {
          runner.end();
        });
        runners = [];
      };

      return animateCssConstructor;
    }]);

    $provide.decorator(&#x27;$animate&#x27;, [&#x27;$delegate&#x27;, &#x27;$timeout&#x27;, &#x27;$browser&#x27;, &#x27;$$rAF&#x27;, &#x27;$animateCss&#x27;, &#x27;$$animateJs&#x27;,
                                    &#x27;$$forceReflow&#x27;, &#x27;$$animateAsyncRun&#x27;, &#x27;$rootScope&#x27;,
                            function($delegate,   $timeout,   $browser,   $$rAF,   $animateCss,   $$animateJs,
                                     $$forceReflow,   $$animateAsyncRun,  $rootScope) {
      var animate = {
        queue: [],
        cancel: $delegate.cancel,
        on: $delegate.on,
        off: $delegate.off,
        pin: $delegate.pin,
        get reflows() {
          return $$forceReflow.totalReflows;
        },
        enabled: $delegate.enabled,
        /**
         * @ngdoc method
         * @name $animate#closeAndFlush
         * @description
         *
         * This method will close all pending animations (both {@link ngAnimate#javascript-based-animations Javascript}
         * and {@link ngAnimate.$animateCss CSS}) and it will also flush any remaining animation frames and/or callbacks.
         */
        closeAndFlush: function() {
          // we allow the flush command to swallow the errors
          // because depending on whether CSS or JS animations are
          // used, there may not be a RAF flush. The primary flush
          // at the end of this function must throw an exception
          // because it will track if there were pending animations
          this.flush(true);
          $animateCss.$closeAndFlush();
          $$animateJs.$closeAndFlush();
          this.flush();
        },
        /**
         * @ngdoc method
         * @name $animate#flush
         * @description
         *
         * This method is used to flush the pending callbacks and animation frames to either start
         * an animation or conclude an animation. Note that this will not actually close an
         * actively running animation (see {@link ngMock.$animate#closeAndFlush &#x60;closeAndFlush()&#x60;} for that).
         */
        flush: function(hideErrors) {
          $rootScope.$digest();

          var doNextRun, somethingFlushed = false;
          do {
            doNextRun = false;

            if ($$rAF.queue.length) {
              $$rAF.flush();
              doNextRun = somethingFlushed = true;
            }

            if ($$animateAsyncRun.flush()) {
              doNextRun = somethingFlushed = true;
            }
          } while (doNextRun);

          if (!somethingFlushed &amp;&amp; !hideErrors) {
            throw new Error(&#x27;No pending animations ready to be closed or flushed&#x27;);
          }

          $rootScope.$digest();
        }
      };

      angular.forEach(
        [&#x27;animate&#x27;,&#x27;enter&#x27;,&#x27;leave&#x27;,&#x27;move&#x27;,&#x27;addClass&#x27;,&#x27;removeClass&#x27;,&#x27;setClass&#x27;], function(method) {
        animate[method] = function() {
          animate.queue.push({
            event: method,
            element: arguments[0],
            options: arguments[arguments.length - 1],
            args: arguments
          });
          return $delegate[method].apply($delegate, arguments);
        };
      });

      return animate;
    }]);

  }]);


/**
 * @ngdoc function
 * @name angular.mock.dump
 * @description
 *
 * *NOTE*: this is not an injectable instance, just a globally available function.
 *
 * Method for serializing common angular objects (scope, elements, etc..) into strings, useful for
 * debugging.
 *
 * This method is also available on window, where it can be used to display objects on debug
 * console.
 *
 * @param {*} object - any object to turn into string.
 * @return {string} a serialized string of the argument
 */
angular.mock.dump = function(object) {
  return serialize(object);

  function serialize(object) {
    var out;

    if (angular.isElement(object)) {
      object = angular.element(object);
      out = angular.element(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;);
      angular.forEach(object, function(element) {
        out.append(angular.element(element).clone());
      });
      out = out.html();
    } else if (angular.isArray(object)) {
      out = [];
      angular.forEach(object, function(o) {
        out.push(serialize(o));
      });
      out = &#x27;[ &#x27; + out.join(&#x27;, &#x27;) + &#x27; ]&#x27;;
    } else if (angular.isObject(object)) {
      if (angular.isFunction(object.$eval) &amp;&amp; angular.isFunction(object.$apply)) {
        out = serializeScope(object);
      } else if (object instanceof Error) {
        out = object.stack || (&#x27;&#x27; + object.name + &#x27;: &#x27; + object.message);
      } else {
        // TODO(i): this prevents methods being logged,
        // we should have a better way to serialize objects
        out = angular.toJson(object, true);
      }
    } else {
      out = String(object);
    }

    return out;
  }

  function serializeScope(scope, offset) {
    offset = offset ||  &#x27;  &#x27;;
    var log = [offset + &#x27;Scope(&#x27; + scope.$id + &#x27;): {&#x27;];
    for (var key in scope) {
      if (Object.prototype.hasOwnProperty.call(scope, key) &amp;&amp; !key.match(/^(\$|this)/)) {
        log.push(&#x27;  &#x27; + key + &#x27;: &#x27; + angular.toJson(scope[key]));
      }
    }
    var child = scope.$$childHead;
    while (child) {
      log.push(serializeScope(child, offset + &#x27;  &#x27;));
      child = child.$$nextSibling;
    }
    log.push(&#x27;}&#x27;);
    return log.join(&#x27;\n&#x27; + offset);
  }
};

/**
 * @ngdoc service
 * @name $httpBackend
 * @description
 * Fake HTTP backend implementation suitable for unit testing applications that use the
 * {@link ng.$http $http service}.
 *
 * *Note*: For fake HTTP backend implementation suitable for end-to-end testing or backend-less
 * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.
 *
 * During unit testing, we want our unit tests to run quickly and have no external dependencies so
 * we don’t want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or
 * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is
 * to verify whether a certain request has been sent or not, or alternatively just let the
 * application make requests, respond with pre-trained responses and assert that the end result is
 * what we expect it to be.
 *
 * This mock implementation can be used to respond with static or dynamic responses via the
 * &#x60;expect&#x60; and &#x60;when&#x60; apis and their shortcuts (&#x60;expectGET&#x60;, &#x60;whenPOST&#x60;, etc).
 *
 * When an Angular application needs some data from a server, it calls the $http service, which
 * sends the request to a real server using $httpBackend service. With dependency injection, it is
 * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify
 * the requests and respond with some testing data without sending a request to a real server.
 *
 * There are two ways to specify what test data should be returned as http responses by the mock
 * backend when the code under test makes http requests:
 *
 * - &#x60;$httpBackend.expect&#x60; - specifies a request expectation
 * - &#x60;$httpBackend.when&#x60; - specifies a backend definition
 *
 *
 * ## Request Expectations vs Backend Definitions
 *
 * Request expectations provide a way to make assertions about requests made by the application and
 * to define responses for those requests. The test will fail if the expected requests are not made
 * or they are made in the wrong order.
 *
 * Backend definitions allow you to define a fake backend for your application which doesn&#x27;t assert
 * if a particular request was made or not, it just returns a trained response if a request is made.
 * The test will pass whether or not the request gets made during testing.
 *
 *
 * &lt;table class=&quot;table&quot;&gt;
 *   &lt;tr&gt;&lt;th width=&quot;220px&quot;&gt;&lt;/th&gt;&lt;th&gt;Request expectations&lt;/th&gt;&lt;th&gt;Backend definitions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Syntax&lt;/th&gt;
 *     &lt;td&gt;.expect(...).respond(...)&lt;/td&gt;
 *     &lt;td&gt;.when(...).respond(...)&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Typical usage&lt;/th&gt;
 *     &lt;td&gt;strict unit tests&lt;/td&gt;
 *     &lt;td&gt;loose (black-box) unit testing&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Fulfills multiple requests&lt;/th&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Order of requests matters&lt;/th&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Request required&lt;/th&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Response required&lt;/th&gt;
 *     &lt;td&gt;optional (see below)&lt;/td&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * In cases where both backend definitions and request expectations are specified during unit
 * testing, the request expectations are evaluated first.
 *
 * If a request expectation has no response specified, the algorithm will search your backend
 * definitions for an appropriate response.
 *
 * If a request didn&#x27;t match any expectation or if the expectation doesn&#x27;t have the response
 * defined, the backend definitions are evaluated in sequential order to see if any of them match
 * the request. The response from the first matched definition is returned.
 *
 *
 * ## Flushing HTTP requests
 *
 * The $httpBackend used in production always responds to requests asynchronously. If we preserved
 * this behavior in unit testing, we&#x27;d have to create async unit tests, which are hard to write,
 * to follow and to maintain. But neither can the testing mock respond synchronously; that would
 * change the execution of the code under test. For this reason, the mock $httpBackend has a
 * &#x60;flush()&#x60; method, which allows the test to explicitly flush pending requests. This preserves
 * the async api of the backend, while allowing the test to execute synchronously.
 *
 *
 * ## Unit testing with mock $httpBackend
 * The following code shows how to setup and use the mock backend when unit testing a controller.
 * First we create the controller under test:
 *
  &#x60;&#x60;&#x60;js
  // The module code
  angular
    .module(&#x27;MyApp&#x27;, [])
    .controller(&#x27;MyController&#x27;, MyController);

  // The controller code
  function MyController($scope, $http) {
    var authToken;

    $http.get(&#x27;/auth.py&#x27;).then(function(response) {
      authToken = response.headers(&#x27;A-Token&#x27;);
      $scope.user = response.data;
    });

    $scope.saveMessage = function(message) {
      var headers = { &#x27;Authorization&#x27;: authToken };
      $scope.status = &#x27;Saving...&#x27;;

      $http.post(&#x27;/add-msg.py&#x27;, message, { headers: headers } ).then(function(response) {
        $scope.status = &#x27;&#x27;;
      }).catch(function() {
        $scope.status = &#x27;Failed...&#x27;;
      });
    };
  }
  &#x60;&#x60;&#x60;
 *
 * Now we setup the mock backend and create the test specs:
 *
  &#x60;&#x60;&#x60;js
    // testing controller
    describe(&#x27;MyController&#x27;, function() {
       var $httpBackend, $rootScope, createController, authRequestHandler;

       // Set up the module
       beforeEach(module(&#x27;MyApp&#x27;));

       beforeEach(inject(function($injector) {
         // Set up the mock http service responses
         $httpBackend = $injector.get(&#x27;$httpBackend&#x27;);
         // backend definition common for all tests
         authRequestHandler = $httpBackend.when(&#x27;GET&#x27;, &#x27;/auth.py&#x27;)
                                .respond({userId: &#x27;userX&#x27;}, {&#x27;A-Token&#x27;: &#x27;xxx&#x27;});

         // Get hold of a scope (i.e. the root scope)
         $rootScope = $injector.get(&#x27;$rootScope&#x27;);
         // The $controller service is used to create instances of controllers
         var $controller = $injector.get(&#x27;$controller&#x27;);

         createController = function() {
           return $controller(&#x27;MyController&#x27;, {&#x27;$scope&#x27; : $rootScope });
         };
       }));


       afterEach(function() {
         $httpBackend.verifyNoOutstandingExpectation();
         $httpBackend.verifyNoOutstandingRequest();
       });


       it(&#x27;should fetch authentication token&#x27;, function() {
         $httpBackend.expectGET(&#x27;/auth.py&#x27;);
         var controller = createController();
         $httpBackend.flush();
       });


       it(&#x27;should fail authentication&#x27;, function() {

         // Notice how you can change the response even after it was set
         authRequestHandler.respond(401, &#x27;&#x27;);

         $httpBackend.expectGET(&#x27;/auth.py&#x27;);
         var controller = createController();
         $httpBackend.flush();
         expect($rootScope.status).toBe(&#x27;Failed...&#x27;);
       });


       it(&#x27;should send msg to server&#x27;, function() {
         var controller = createController();
         $httpBackend.flush();

         // now you don’t care about the authentication, but
         // the controller will still send the request and
         // $httpBackend will respond without you having to
         // specify the expectation and response for this request

         $httpBackend.expectPOST(&#x27;/add-msg.py&#x27;, &#x27;message content&#x27;).respond(201, &#x27;&#x27;);
         $rootScope.saveMessage(&#x27;message content&#x27;);
         expect($rootScope.status).toBe(&#x27;Saving...&#x27;);
         $httpBackend.flush();
         expect($rootScope.status).toBe(&#x27;&#x27;);
       });


       it(&#x27;should send auth header&#x27;, function() {
         var controller = createController();
         $httpBackend.flush();

         $httpBackend.expectPOST(&#x27;/add-msg.py&#x27;, undefined, function(headers) {
           // check if the header was sent, if it wasn&#x27;t the expectation won&#x27;t
           // match the request and the test will fail
           return headers[&#x27;Authorization&#x27;] == &#x27;xxx&#x27;;
         }).respond(201, &#x27;&#x27;);

         $rootScope.saveMessage(&#x27;whatever&#x27;);
         $httpBackend.flush();
       });
    });
  &#x60;&#x60;&#x60;
 *
 * ## Dynamic responses
 *
 * You define a response to a request by chaining a call to &#x60;respond()&#x60; onto a definition or expectation.
 * If you provide a **callback** as the first parameter to &#x60;respond(callback)&#x60; then you can dynamically generate
 * a response based on the properties of the request.
 *
 * The &#x60;callback&#x60; function should be of the form &#x60;function(method, url, data, headers, params)&#x60;.
 *
 * ### Query parameters
 *
 * By default, query parameters on request URLs are parsed into the &#x60;params&#x60; object. So a request URL
 * of &#x60;/list?q=searchstr&amp;orderby=-name&#x60; would set &#x60;params&#x60; to be &#x60;{q: &#x27;searchstr&#x27;, orderby: &#x27;-name&#x27;}&#x60;.
 *
 * ### Regex parameter matching
 *
 * If an expectation or definition uses a **regex** to match the URL, you can provide an array of **keys** via a
 * &#x60;params&#x60; argument. The index of each **key** in the array will match the index of a **group** in the
 * **regex**.
 *
 * The &#x60;params&#x60; object in the **callback** will now have properties with these keys, which hold the value of the
 * corresponding **group** in the **regex**.
 *
 * This also applies to the &#x60;when&#x60; and &#x60;expect&#x60; shortcut methods.
 *
 *
 * &#x60;&#x60;&#x60;js
 *   $httpBackend.expect(&#x27;GET&#x27;, /\/user\/(.+)/, undefined, undefined, [&#x27;id&#x27;])
 *     .respond(function(method, url, data, headers, params) {
 *       // for requested url of &#x27;/user/1234&#x27; params is {id: &#x27;1234&#x27;}
 *     });
 *
 *   $httpBackend.whenPATCH(/\/user\/(.+)\/article\/(.+)/, undefined, undefined, [&#x27;user&#x27;, &#x27;article&#x27;])
 *     .respond(function(method, url, data, headers, params) {
 *       // for url of &#x27;/user/1234/article/567&#x27; params is {user: &#x27;1234&#x27;, article: &#x27;567&#x27;}
 *     });
 * &#x60;&#x60;&#x60;
 *
 * ## Matching route requests
 *
 * For extra convenience, &#x60;whenRoute&#x60; and &#x60;expectRoute&#x60; shortcuts are available. These methods offer colon
 * delimited matching of the url path, ignoring the query string. This allows declarations
 * similar to how application routes are configured with &#x60;$routeProvider&#x60;. Because these methods convert
 * the definition url to regex, declaration order is important. Combined with query parameter parsing,
 * the following is possible:
 *
  &#x60;&#x60;&#x60;js
    $httpBackend.whenRoute(&#x27;GET&#x27;, &#x27;/users/:id&#x27;)
      .respond(function(method, url, data, headers, params) {
        return [200, MockUserList[Number(params.id)]];
      });

    $httpBackend.whenRoute(&#x27;GET&#x27;, &#x27;/users&#x27;)
      .respond(function(method, url, data, headers, params) {
        var userList = angular.copy(MockUserList),
          defaultSort = &#x27;lastName&#x27;,
          count, pages, isPrevious, isNext;

        // paged api response &#x27;/v1/users?page=2&#x27;
        params.page = Number(params.page) || 1;

        // query for last names &#x27;/v1/users?q=Archer&#x27;
        if (params.q) {
          userList = $filter(&#x27;filter&#x27;)({lastName: params.q});
        }

        pages = Math.ceil(userList.length / pagingLength);
        isPrevious = params.page &gt; 1;
        isNext = params.page &lt; pages;

        return [200, {
          count:    userList.length,
          previous: isPrevious,
          next:     isNext,
          // sort field -&gt; &#x27;/v1/users?sortBy=firstName&#x27;
          results:  $filter(&#x27;orderBy&#x27;)(userList, params.sortBy || defaultSort)
                      .splice((params.page - 1) * pagingLength, pagingLength)
        }];
      });
  &#x60;&#x60;&#x60;
 */
angular.mock.$HttpBackendProvider = function() {
  this.$get = [&#x27;$rootScope&#x27;, &#x27;$timeout&#x27;, createHttpBackendMock];
};

/**
 * General factory function for $httpBackend mock.
 * Returns instance for unit testing (when no arguments specified):
 *   - passing through is disabled
 *   - auto flushing is disabled
 *
 * Returns instance for e2e testing (when &#x60;$delegate&#x60; and &#x60;$browser&#x60; specified):
 *   - passing through (delegating request to real backend) is enabled
 *   - auto flushing is enabled
 *
 * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)
 * @param {Object=} $browser Auto-flushing enabled if specified
 * @return {Object} Instance of $httpBackend mock
 */
function createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {
  var definitions = [],
      expectations = [],
      responses = [],
      responsesPush = angular.bind(responses, responses.push),
      copy = angular.copy;

  function createResponse(status, data, headers, statusText) {
    if (angular.isFunction(status)) return status;

    return function() {
      return angular.isNumber(status)
          ? [status, data, headers, statusText]
          : [200, status, data, headers];
    };
  }

  // TODO(vojta): change params to: method, url, data, headers, callback
  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials) {
    var xhr = new MockXhr(),
        expectation = expectations[0],
        wasExpected = false;

    function prettyPrint(data) {
      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)
          ? data
          : angular.toJson(data);
    }

    function wrapResponse(wrapped) {
      if (!$browser &amp;&amp; timeout) {
        timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);
      }

      return handleResponse;

      function handleResponse() {
        var response = wrapped.response(method, url, data, headers, wrapped.params(url));
        xhr.$$respHeaders = response[2];
        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),
                 copy(response[3] || &#x27;&#x27;));
      }

      function handleTimeout() {
        for (var i = 0, ii = responses.length; i &lt; ii; i++) {
          if (responses[i] === handleResponse) {
            responses.splice(i, 1);
            callback(-1, undefined, &#x27;&#x27;);
            break;
          }
        }
      }
    }

    if (expectation &amp;&amp; expectation.match(method, url)) {
      if (!expectation.matchData(data)) {
        throw new Error(&#x27;Expected &#x27; + expectation + &#x27; with different data\n&#x27; +
            &#x27;EXPECTED: &#x27; + prettyPrint(expectation.data) + &#x27;\nGOT:      &#x27; + data);
      }

      if (!expectation.matchHeaders(headers)) {
        throw new Error(&#x27;Expected &#x27; + expectation + &#x27; with different headers\n&#x27; +
                        &#x27;EXPECTED: &#x27; + prettyPrint(expectation.headers) + &#x27;\nGOT:      &#x27; +
                        prettyPrint(headers));
      }

      expectations.shift();

      if (expectation.response) {
        responses.push(wrapResponse(expectation));
        return;
      }
      wasExpected = true;
    }

    var i = -1, definition;
    while ((definition = definitions[++i])) {
      if (definition.match(method, url, data, headers || {})) {
        if (definition.response) {
          // if $browser specified, we do auto flush all requests
          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
        } else if (definition.passThrough) {
          $delegate(method, url, data, callback, headers, timeout, withCredentials);
        } else throw new Error(&#x27;No response defined !&#x27;);
        return;
      }
    }
    throw wasExpected ?
        new Error(&#x27;No response defined !&#x27;) :
        new Error(&#x27;Unexpected request: &#x27; + method + &#x27; &#x27; + url + &#x27;\n&#x27; +
                  (expectation ? &#x27;Expected &#x27; + expectation : &#x27;No more request expected&#x27;));
  }

  /**
   * @ngdoc method
   * @name $httpBackend#when
   * @description
   * Creates a new backend definition.
   *
   * @param {string} method HTTP method.
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
   *   object and returns true if the headers match the current definition.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   *
   *  - respond –
   *      &#x60;{function([status,] data[, headers, statusText])
   *      | function(function(method, url, data, headers, params)}&#x60;
   *    – The respond method takes a set of static data to be returned or a function that can
   *    return an array containing response status (number), response data (string), response
   *    headers (Object), and the text for the status (string). The respond method returns the
   *    &#x60;requestHandler&#x60; object for possible overrides.
   */
  $httpBackend.when = function(method, url, data, headers, keys) {
    var definition = new MockHttpExpectation(method, url, data, headers, keys),
        chain = {
          respond: function(status, data, headers, statusText) {
            definition.passThrough = undefined;
            definition.response = createResponse(status, data, headers, statusText);
            return chain;
          }
        };

    if ($browser) {
      chain.passThrough = function() {
        definition.response = undefined;
        definition.passThrough = true;
        return chain;
      };
    }

    definitions.push(definition);
    return chain;
  };

  /**
   * @ngdoc method
   * @name $httpBackend#whenGET
   * @description
   * Creates a new backend definition for GET requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenHEAD
   * @description
   * Creates a new backend definition for HEAD requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenDELETE
   * @description
   * Creates a new backend definition for DELETE requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenPOST
   * @description
   * Creates a new backend definition for POST requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenPUT
   * @description
   * Creates a new backend definition for PUT requests.  For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenJSONP
   * @description
   * Creates a new backend definition for JSONP requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */
  createShortMethods(&#x27;when&#x27;);

  /**
   * @ngdoc method
   * @name $httpBackend#whenRoute
   * @description
   * Creates a new backend definition that compares only with the requested route.
   *
   * @param {string} method HTTP method.
   * @param {string} url HTTP url string that supports colon param matching.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled. See #when for more info.
   */
  $httpBackend.whenRoute = function(method, url) {
    var pathObj = parseRoute(url);
    return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);
  };

  function parseRoute(url) {
    var ret = {
      regexp: url
    },
    keys = ret.keys = [];

    if (!url || !angular.isString(url)) return ret;

    url = url
      .replace(/([().])/g, &#x27;\\$1&#x27;)
      .replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
        var optional = option === &#x27;?&#x27; ? option : null;
        var star = option === &#x27;*&#x27; ? option : null;
        keys.push({ name: key, optional: !!optional });
        slash = slash || &#x27;&#x27;;
        return &#x27;&#x27;
          + (optional ? &#x27;&#x27; : slash)
          + &#x27;(?:&#x27;
          + (optional ? slash : &#x27;&#x27;)
          + (star &amp;&amp; &#x27;(.+?)&#x27; || &#x27;([^/]+)&#x27;)
          + (optional || &#x27;&#x27;)
          + &#x27;)&#x27;
          + (optional || &#x27;&#x27;);
      })
      .replace(/([\/$\*])/g, &#x27;\\$1&#x27;);

    ret.regexp = new RegExp(&#x27;^&#x27; + url, &#x27;i&#x27;);
    return ret;
  }

  /**
   * @ngdoc method
   * @name $httpBackend#expect
   * @description
   * Creates a new request expectation.
   *
   * @param {string} method HTTP method.
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
   *   object and returns true if the headers match the current expectation.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *  request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *  order to change how a matched request is handled.
   *
   *  - respond –
   *    &#x60;{function([status,] data[, headers, statusText])
   *    | function(function(method, url, data, headers, params)}&#x60;
   *    – The respond method takes a set of static data to be returned or a function that can
   *    return an array containing response status (number), response data (string), response
   *    headers (Object), and the text for the status (string). The respond method returns the
   *    &#x60;requestHandler&#x60; object for possible overrides.
   */
  $httpBackend.expect = function(method, url, data, headers, keys) {
    var expectation = new MockHttpExpectation(method, url, data, headers, keys),
        chain = {
          respond: function(status, data, headers, statusText) {
            expectation.response = createResponse(status, data, headers, statusText);
            return chain;
          }
        };

    expectations.push(expectation);
    return chain;
  };

  /**
   * @ngdoc method
   * @name $httpBackend#expectGET
   * @description
   * Creates a new request expectation for GET requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled. See #expect for more info.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectHEAD
   * @description
   * Creates a new request expectation for HEAD requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectDELETE
   * @description
   * Creates a new request expectation for DELETE requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPOST
   * @description
   * Creates a new request expectation for POST requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPUT
   * @description
   * Creates a new request expectation for PUT requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPATCH
   * @description
   * Creates a new request expectation for PATCH requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
   *   and returns true if the url matches the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectJSONP
   * @description
   * Creates a new request expectation for JSONP requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives an url
   *   and returns true if the url matches the current definition.
   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */
  createShortMethods(&#x27;expect&#x27;);

  /**
   * @ngdoc method
   * @name $httpBackend#expectRoute
   * @description
   * Creates a new request expectation that compares only with the requested route.
   *
   * @param {string} method HTTP method.
   * @param {string} url HTTP url string that supports colon param matching.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled. See #expect for more info.
   */
  $httpBackend.expectRoute = function(method, url) {
    var pathObj = parseRoute(url);
    return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);
  };


  /**
   * @ngdoc method
   * @name $httpBackend#flush
   * @description
   * Flushes all pending requests using the trained responses.
   *
   * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,
   *   all pending requests will be flushed. If there are no pending requests when the flush method
   *   is called an exception is thrown (as this typically a sign of programming error).
   */
  $httpBackend.flush = function(count, digest) {
    if (digest !== false) $rootScope.$digest();
    if (!responses.length) throw new Error(&#x27;No pending request to flush !&#x27;);

    if (angular.isDefined(count) &amp;&amp; count !== null) {
      while (count--) {
        if (!responses.length) throw new Error(&#x27;No more pending request to flush !&#x27;);
        responses.shift()();
      }
    } else {
      while (responses.length) {
        responses.shift()();
      }
    }
    $httpBackend.verifyNoOutstandingExpectation(digest);
  };


  /**
   * @ngdoc method
   * @name $httpBackend#verifyNoOutstandingExpectation
   * @description
   * Verifies that all of the requests defined via the &#x60;expect&#x60; api were made. If any of the
   * requests were not made, verifyNoOutstandingExpectation throws an exception.
   *
   * Typically, you would call this method following each test case that asserts requests using an
   * &quot;afterEach&quot; clause.
   *
   * &#x60;&#x60;&#x60;js
   *   afterEach($httpBackend.verifyNoOutstandingExpectation);
   * &#x60;&#x60;&#x60;
   */
  $httpBackend.verifyNoOutstandingExpectation = function(digest) {
    if (digest !== false) $rootScope.$digest();
    if (expectations.length) {
      throw new Error(&#x27;Unsatisfied requests: &#x27; + expectations.join(&#x27;, &#x27;));
    }
  };


  /**
   * @ngdoc method
   * @name $httpBackend#verifyNoOutstandingRequest
   * @description
   * Verifies that there are no outstanding requests that need to be flushed.
   *
   * Typically, you would call this method following each test case that asserts requests using an
   * &quot;afterEach&quot; clause.
   *
   * &#x60;&#x60;&#x60;js
   *   afterEach($httpBackend.verifyNoOutstandingRequest);
   * &#x60;&#x60;&#x60;
   */
  $httpBackend.verifyNoOutstandingRequest = function() {
    if (responses.length) {
      throw new Error(&#x27;Unflushed requests: &#x27; + responses.length);
    }
  };


  /**
   * @ngdoc method
   * @name $httpBackend#resetExpectations
   * @description
   * Resets all request expectations, but preserves all backend definitions. Typically, you would
   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of
   * $httpBackend mock.
   */
  $httpBackend.resetExpectations = function() {
    expectations.length = 0;
    responses.length = 0;
  };

  return $httpBackend;


  function createShortMethods(prefix) {
    angular.forEach([&#x27;GET&#x27;, &#x27;DELETE&#x27;, &#x27;JSONP&#x27;, &#x27;HEAD&#x27;], function(method) {
     $httpBackend[prefix + method] = function(url, headers, keys) {
       return $httpBackend[prefix](method, url, undefined, headers, keys);
     };
    });

    angular.forEach([&#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;PATCH&#x27;], function(method) {
      $httpBackend[prefix + method] = function(url, data, headers, keys) {
        return $httpBackend[prefix](method, url, data, headers, keys);
      };
    });
  }
}

function MockHttpExpectation(method, url, data, headers, keys) {

  this.data = data;
  this.headers = headers;

  this.match = function(m, u, d, h) {
    if (method != m) return false;
    if (!this.matchUrl(u)) return false;
    if (angular.isDefined(d) &amp;&amp; !this.matchData(d)) return false;
    if (angular.isDefined(h) &amp;&amp; !this.matchHeaders(h)) return false;
    return true;
  };

  this.matchUrl = function(u) {
    if (!url) return true;
    if (angular.isFunction(url.test)) return url.test(u);
    if (angular.isFunction(url)) return url(u);
    return url == u;
  };

  this.matchHeaders = function(h) {
    if (angular.isUndefined(headers)) return true;
    if (angular.isFunction(headers)) return headers(h);
    return angular.equals(headers, h);
  };

  this.matchData = function(d) {
    if (angular.isUndefined(data)) return true;
    if (data &amp;&amp; angular.isFunction(data.test)) return data.test(d);
    if (data &amp;&amp; angular.isFunction(data)) return data(d);
    if (data &amp;&amp; !angular.isString(data)) {
      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
    }
    return data == d;
  };

  this.toString = function() {
    return method + &#x27; &#x27; + url;
  };

  this.params = function(u) {
    return angular.extend(parseQuery(), pathParams());

    function pathParams() {
      var keyObj = {};
      if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0) return keyObj;

      var m = url.exec(u);
      if (!m) return keyObj;
      for (var i = 1, len = m.length; i &lt; len; ++i) {
        var key = keys[i - 1];
        var val = m[i];
        if (key &amp;&amp; val) {
          keyObj[key.name || key] = val;
        }
      }

      return keyObj;
    }

    function parseQuery() {
      var obj = {}, key_value, key,
          queryStr = u.indexOf(&#x27;?&#x27;) &gt; -1
          ? u.substring(u.indexOf(&#x27;?&#x27;) + 1)
          : &quot;&quot;;

      angular.forEach(queryStr.split(&#x27;&amp;&#x27;), function(keyValue) {
        if (keyValue) {
          key_value = keyValue.replace(/\+/g,&#x27;%20&#x27;).split(&#x27;=&#x27;);
          key = tryDecodeURIComponent(key_value[0]);
          if (angular.isDefined(key)) {
            var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
            if (!hasOwnProperty.call(obj, key)) {
              obj[key] = val;
            } else if (angular.isArray(obj[key])) {
              obj[key].push(val);
            } else {
              obj[key] = [obj[key],val];
            }
          }
        }
      });
      return obj;
    }
    function tryDecodeURIComponent(value) {
      try {
        return decodeURIComponent(value);
      } catch (e) {
        // Ignore any invalid uri component
      }
    }
  };
}

function createMockXhr() {
  return new MockXhr();
}

function MockXhr() {

  // hack for testing $http, $httpBackend
  MockXhr.$$lastInstance = this;

  this.open = function(method, url, async) {
    this.$$method = method;
    this.$$url = url;
    this.$$async = async;
    this.$$reqHeaders = {};
    this.$$respHeaders = {};
  };

  this.send = function(data) {
    this.$$data = data;
  };

  this.setRequestHeader = function(key, value) {
    this.$$reqHeaders[key] = value;
  };

  this.getResponseHeader = function(name) {
    // the lookup must be case insensitive,
    // that&#x27;s why we try two quick lookups first and full scan last
    var header = this.$$respHeaders[name];
    if (header) return header;

    name = angular.lowercase(name);
    header = this.$$respHeaders[name];
    if (header) return header;

    header = undefined;
    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
      if (!header &amp;&amp; angular.lowercase(headerName) == name) header = headerVal;
    });
    return header;
  };

  this.getAllResponseHeaders = function() {
    var lines = [];

    angular.forEach(this.$$respHeaders, function(value, key) {
      lines.push(key + &#x27;: &#x27; + value);
    });
    return lines.join(&#x27;\n&#x27;);
  };

  this.abort = angular.noop;
}


/**
 * @ngdoc service
 * @name $timeout
 * @description
 *
 * This service is just a simple decorator for {@link ng.$timeout $timeout} service
 * that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.
 */

angular.mock.$TimeoutDecorator = [&#x27;$delegate&#x27;, &#x27;$browser&#x27;, function($delegate, $browser) {

  /**
   * @ngdoc method
   * @name $timeout#flush
   * @description
   *
   * Flushes the queue of pending tasks.
   *
   * @param {number=} delay maximum timeout amount to flush up until
   */
  $delegate.flush = function(delay) {
    $browser.defer.flush(delay);
  };

  /**
   * @ngdoc method
   * @name $timeout#verifyNoPendingTasks
   * @description
   *
   * Verifies that there are no pending tasks that need to be flushed.
   */
  $delegate.verifyNoPendingTasks = function() {
    if ($browser.deferredFns.length) {
      throw new Error(&#x27;Deferred tasks to flush (&#x27; + $browser.deferredFns.length + &#x27;): &#x27; +
          formatPendingTasksAsString($browser.deferredFns));
    }
  };

  function formatPendingTasksAsString(tasks) {
    var result = [];
    angular.forEach(tasks, function(task) {
      result.push(&#x27;{id: &#x27; + task.id + &#x27;, &#x27; + &#x27;time: &#x27; + task.time + &#x27;}&#x27;);
    });

    return result.join(&#x27;, &#x27;);
  }

  return $delegate;
}];

angular.mock.$RAFDecorator = [&#x27;$delegate&#x27;, function($delegate) {
  var rafFn = function(fn) {
    var index = rafFn.queue.length;
    rafFn.queue.push(fn);
    return function() {
      rafFn.queue.splice(index, 1);
    };
  };

  rafFn.queue = [];
  rafFn.supported = $delegate.supported;

  rafFn.flush = function() {
    if (rafFn.queue.length === 0) {
      throw new Error(&#x27;No rAF callbacks present&#x27;);
    }

    var length = rafFn.queue.length;
    for (var i = 0; i &lt; length; i++) {
      rafFn.queue[i]();
    }

    rafFn.queue = rafFn.queue.slice(i);
  };

  return rafFn;
}];

/**
 *
 */
angular.mock.$RootElementProvider = function() {
  this.$get = function() {
    return angular.element(&#x27;&lt;div ng-app&gt;&lt;/div&gt;&#x27;);
  };
};

/**
 * @ngdoc service
 * @name $controller
 * @description
 * A decorator for {@link ng.$controller} with additional &#x60;bindings&#x60; parameter, useful when testing
 * controllers of directives that use {@link $compile#-bindtocontroller- &#x60;bindToController&#x60;}.
 *
 *
 * ## Example
 *
 * &#x60;&#x60;&#x60;js
 *
 * // Directive definition ...
 *
 * myMod.directive(&#x27;myDirective&#x27;, {
 *   controller: &#x27;MyDirectiveController&#x27;,
 *   bindToController: {
 *     name: &#x27;@&#x27;
 *   }
 * });
 *
 *
 * // Controller definition ...
 *
 * myMod.controller(&#x27;MyDirectiveController&#x27;, [&#x27;$log&#x27;, function($log) {
 *   $log.info(this.name);
 * })];
 *
 *
 * // In a test ...
 *
 * describe(&#x27;myDirectiveController&#x27;, function() {
 *   it(&#x27;should write the bound name to the log&#x27;, inject(function($controller, $log) {
 *     var ctrl = $controller(&#x27;MyDirectiveController&#x27;, { /* no locals &amp;#42;/ }, { name: &#x27;Clark Kent&#x27; });
 *     expect(ctrl.name).toEqual(&#x27;Clark Kent&#x27;);
 *     expect($log.info.logs).toEqual([&#x27;Clark Kent&#x27;]);
 *   });
 * });
 *
 * &#x60;&#x60;&#x60;
 *
 * @param {Function|string} constructor If called with a function then it&#x27;s considered to be the
 *    controller constructor function. Otherwise it&#x27;s considered to be a string which is used
 *    to retrieve the controller constructor using the following steps:
 *
 *    * check if a controller with given name is registered via &#x60;$controllerProvider&#x60;
 *    * check if evaluating the string on the current scope returns a constructor
 *    * if $controllerProvider#allowGlobals, check &#x60;window[constructor]&#x60; on the global
 *      &#x60;window&#x60; object (not recommended)
 *
 *    The string can use the &#x60;controller as property&#x60; syntax, where the controller instance is published
 *    as the specified property on the &#x60;scope&#x60;; the &#x60;scope&#x60; must be injected into &#x60;locals&#x60; param for this
 *    to work correctly.
 *
 * @param {Object} locals Injection locals for Controller.
 * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used
 *                           to simulate the &#x60;bindToController&#x60; feature and simplify certain kinds of tests.
 * @return {Object} Instance of given controller.
 */
angular.mock.$ControllerDecorator = [&#x27;$delegate&#x27;, function($delegate) {
  return function(expression, locals, later, ident) {
    if (later &amp;&amp; typeof later === &#x27;object&#x27;) {
      var create = $delegate(expression, locals, true, ident);
      angular.extend(create.instance, later);
      return create();
    }
    return $delegate(expression, locals, later, ident);
  };
}];

/**
 * @ngdoc service
 * @name $componentController
 * @description
 * A service that can be used to create instances of component controllers.
 * &lt;div class=&quot;alert alert-info&quot;&gt;
 * Be aware that the controller will be instantiated and attached to the scope as specified in
 * the component definition object. That means that you must always provide a &#x60;$scope&#x60; object
 * in the &#x60;locals&#x60; param.
 * &lt;/div&gt;
 * @param {string} componentName the name of the component whose controller we want to instantiate
 * @param {Object} locals Injection locals for Controller.
 * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used
 *                           to simulate the &#x60;bindToController&#x60; feature and simplify certain kinds of tests.
 * @param {string=} ident Override the property name to use when attaching the controller to the scope.
 * @return {Object} Instance of requested controller.
 */
angular.mock.$ComponentControllerProvider = [&#x27;$compileProvider&#x27;, function($compileProvider) {
  return {
    $get: [&#x27;$controller&#x27;,&#x27;$injector&#x27;, function($controller,$injector) {
      return function $componentController(componentName, locals, bindings, ident) {
        // get all directives associated to the component name
        var directives = $injector.get(componentName + &#x27;Directive&#x27;);
        // look for those directives that are components
        var candidateDirectives = directives.filter(function(directiveInfo) {
          // components have controller, controllerAs and restrict:&#x27;E&#x27;
          return directiveInfo.controller &amp;&amp; directiveInfo.controllerAs &amp;&amp; directiveInfo.restrict === &#x27;E&#x27;;
        });
        // check if valid directives found
        if (candidateDirectives.length === 0) {
          throw new Error(&#x27;No component found&#x27;);
        }
        if (candidateDirectives.length &gt; 1) {
          throw new Error(&#x27;Too many components found&#x27;);
        }
        // get the info of the component
        var directiveInfo = candidateDirectives[0];
        return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);
      };
    }]
  };
}];


/**
 * @ngdoc module
 * @name ngMock
 * @packageName angular-mocks
 * @description
 *
 * # ngMock
 *
 * The &#x60;ngMock&#x60; module provides support to inject and mock Angular services into unit tests.
 * In addition, ngMock also extends various core ng services such that they can be
 * inspected and controlled in a synchronous manner within test code.
 *
 *
 * &lt;div doc-module-components=&quot;ngMock&quot;&gt;&lt;/div&gt;
 *
 */
angular.module(&#x27;ngMock&#x27;, [&#x27;ng&#x27;]).provider({
  $browser: angular.mock.$BrowserProvider,
  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
  $log: angular.mock.$LogProvider,
  $interval: angular.mock.$IntervalProvider,
  $httpBackend: angular.mock.$HttpBackendProvider,
  $rootElement: angular.mock.$RootElementProvider,
  $componentController: angular.mock.$ComponentControllerProvider
}).config([&#x27;$provide&#x27;, function($provide) {
  $provide.decorator(&#x27;$timeout&#x27;, angular.mock.$TimeoutDecorator);
  $provide.decorator(&#x27;$$rAF&#x27;, angular.mock.$RAFDecorator);
  $provide.decorator(&#x27;$rootScope&#x27;, angular.mock.$RootScopeDecorator);
  $provide.decorator(&#x27;$controller&#x27;, angular.mock.$ControllerDecorator);
}]);

/**
 * @ngdoc module
 * @name ngMockE2E
 * @module ngMockE2E
 * @packageName angular-mocks
 * @description
 *
 * The &#x60;ngMockE2E&#x60; is an angular module which contains mocks suitable for end-to-end testing.
 * Currently there is only one mock present in this module -
 * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.
 */
angular.module(&#x27;ngMockE2E&#x27;, [&#x27;ng&#x27;]).config([&#x27;$provide&#x27;, function($provide) {
  $provide.decorator(&#x27;$httpBackend&#x27;, angular.mock.e2e.$httpBackendDecorator);
}]);

/**
 * @ngdoc service
 * @name $httpBackend
 * @module ngMockE2E
 * @description
 * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of
 * applications that use the {@link ng.$http $http service}.
 *
 * *Note*: For fake http backend implementation suitable for unit testing please see
 * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.
 *
 * This implementation can be used to respond with static or dynamic responses via the &#x60;when&#x60; api
 * and its shortcuts (&#x60;whenGET&#x60;, &#x60;whenPOST&#x60;, etc) and optionally pass through requests to the
 * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch
 * templates from a webserver).
 *
 * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application
 * is being developed with the real backend api replaced with a mock, it is often desirable for
 * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch
 * templates or static files from the webserver). To configure the backend with this behavior
 * use the &#x60;passThrough&#x60; request handler of &#x60;when&#x60; instead of &#x60;respond&#x60;.
 *
 * Additionally, we don&#x27;t want to manually have to flush mocked out requests like we do during unit
 * testing. For this reason the e2e $httpBackend flushes mocked out requests
 * automatically, closely simulating the behavior of the XMLHttpRequest object.
 *
 * To setup the application to run with this http backend, you have to create a module that depends
 * on the &#x60;ngMockE2E&#x60; and your application modules and defines the fake backend:
 *
 * &#x60;&#x60;&#x60;js
 *   myAppDev = angular.module(&#x27;myAppDev&#x27;, [&#x27;myApp&#x27;, &#x27;ngMockE2E&#x27;]);
 *   myAppDev.run(function($httpBackend) {
 *     phones = [{name: &#x27;phone1&#x27;}, {name: &#x27;phone2&#x27;}];
 *
 *     // returns the current list of phones
 *     $httpBackend.whenGET(&#x27;/phones&#x27;).respond(phones);
 *
 *     // adds a new phone to the phones array
 *     $httpBackend.whenPOST(&#x27;/phones&#x27;).respond(function(method, url, data) {
 *       var phone = angular.fromJson(data);
 *       phones.push(phone);
 *       return [200, phone, {}];
 *     });
 *     $httpBackend.whenGET(/^\/templates\//).passThrough();
 *     //...
 *   });
 * &#x60;&#x60;&#x60;
 *
 * Afterwards, bootstrap your app with this new module.
 */

/**
 * @ngdoc method
 * @name $httpBackend#when
 * @module ngMockE2E
 * @description
 * Creates a new backend definition.
 *
 * @param {string} method HTTP method.
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
 *   object and returns true if the headers match the current definition.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 *
 *  - respond –
 *    &#x60;{function([status,] data[, headers, statusText])
 *    | function(function(method, url, data, headers, params)}&#x60;
 *    – The respond method takes a set of static data to be returned or a function that can return
 *    an array containing response status (number), response data (string), response headers
 *    (Object), and the text for the status (string).
 *  - passThrough – &#x60;{function()}&#x60; – Any request matching a backend definition with
 *    &#x60;passThrough&#x60; handler will be passed through to the real backend (an XHR request will be made
 *    to the server.)
 *  - Both methods return the &#x60;requestHandler&#x60; object for possible overrides.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenGET
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for GET requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenHEAD
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for HEAD requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenDELETE
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for DELETE requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPOST
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for POST requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPUT
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for PUT requests.  For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPATCH
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for PATCH requests.  For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenJSONP
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for JSONP requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives a url
 *   and returns true if the url matches the current definition.
 * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on
 *   {@link ngMock.$httpBackend $httpBackend mock}.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */
/**
 * @ngdoc method
 * @name $httpBackend#whenRoute
 * @module ngMockE2E
 * @description
 * Creates a new backend definition that compares only with the requested route.
 *
 * @param {string} method HTTP method.
 * @param {string} url HTTP url string that supports colon param matching.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */
angular.mock.e2e = {};
angular.mock.e2e.$httpBackendDecorator =
  [&#x27;$rootScope&#x27;, &#x27;$timeout&#x27;, &#x27;$delegate&#x27;, &#x27;$browser&#x27;, createHttpBackendMock];


/**
 * @ngdoc type
 * @name $rootScope.Scope
 * @module ngMock
 * @description
 * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These
 * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when
 * &#x60;ngMock&#x60; module is loaded.
 *
 * In addition to all the regular &#x60;Scope&#x60; methods, the following helper methods are available:
 */
angular.mock.$RootScopeDecorator = [&#x27;$delegate&#x27;, function($delegate) {

  var $rootScopePrototype = Object.getPrototypeOf($delegate);

  $rootScopePrototype.$countChildScopes = countChildScopes;
  $rootScopePrototype.$countWatchers = countWatchers;

  return $delegate;

  // ------------------------------------------------------------------------------------------ //

  /**
   * @ngdoc method
   * @name $rootScope.Scope#$countChildScopes
   * @module ngMock
   * @description
   * Counts all the direct and indirect child scopes of the current scope.
   *
   * The current scope is excluded from the count. The count includes all isolate child scopes.
   *
   * @returns {number} Total number of child scopes.
   */
  function countChildScopes() {
    // jshint validthis: true
    var count = 0; // exclude the current scope
    var pendingChildHeads = [this.$$childHead];
    var currentScope;

    while (pendingChildHeads.length) {
      currentScope = pendingChildHeads.shift();

      while (currentScope) {
        count += 1;
        pendingChildHeads.push(currentScope.$$childHead);
        currentScope = currentScope.$$nextSibling;
      }
    }

    return count;
  }


  /**
   * @ngdoc method
   * @name $rootScope.Scope#$countWatchers
   * @module ngMock
   * @description
   * Counts all the watchers of direct and indirect child scopes of the current scope.
   *
   * The watchers of the current scope are included in the count and so are all the watchers of
   * isolate child scopes.
   *
   * @returns {number} Total number of watchers.
   */
  function countWatchers() {
    // jshint validthis: true
    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope
    var pendingChildHeads = [this.$$childHead];
    var currentScope;

    while (pendingChildHeads.length) {
      currentScope = pendingChildHeads.shift();

      while (currentScope) {
        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
        pendingChildHeads.push(currentScope.$$childHead);
        currentScope = currentScope.$$nextSibling;
      }
    }

    return count;
  }
}];


if (window.jasmine || window.mocha) {

  var currentSpec = null,
      annotatedFunctions = [],
      isSpecRunning = function() {
        return !!currentSpec;
      };

  angular.mock.$$annotate = angular.injector.$$annotate;
  angular.injector.$$annotate = function(fn) {
    if (typeof fn === &#x27;function&#x27; &amp;&amp; !fn.$inject) {
      annotatedFunctions.push(fn);
    }
    return angular.mock.$$annotate.apply(this, arguments);
  };


  (window.beforeEach || window.setup)(function() {
    annotatedFunctions = [];
    currentSpec = this;
  });

  (window.afterEach || window.teardown)(function() {
    var injector = currentSpec.$injector;

    annotatedFunctions.forEach(function(fn) {
      delete fn.$inject;
    });

    angular.forEach(currentSpec.$modules, function(module) {
      if (module &amp;&amp; module.$$hashKey) {
        module.$$hashKey = undefined;
      }
    });

    currentSpec.$injector = null;
    currentSpec.$modules = null;
    currentSpec.$providerInjector = null;
    currentSpec = null;

    if (injector) {
      injector.get(&#x27;$rootElement&#x27;).off();
      injector.get(&#x27;$rootScope&#x27;).$destroy();
    }

    // clean up jquery&#x27;s fragment cache
    angular.forEach(angular.element.fragments, function(val, key) {
      delete angular.element.fragments[key];
    });

    MockXhr.$$lastInstance = null;

    angular.forEach(angular.callbacks, function(val, key) {
      delete angular.callbacks[key];
    });
    angular.callbacks.counter = 0;
  });

  /**
   * @ngdoc function
   * @name angular.mock.module
   * @description
   *
   * *NOTE*: This function is also published on window for easy access.&lt;br&gt;
   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
   *
   * This function registers a module configuration code. It collects the configuration information
   * which will be used when the injector is created by {@link angular.mock.inject inject}.
   *
   * See {@link angular.mock.inject inject} for usage example
   *
   * @param {...(string|Function|Object)} fns any number of modules which are represented as string
   *        aliases or as anonymous module initialization functions. The modules are used to
   *        configure the injector. The &#x27;ng&#x27; and &#x27;ngMock&#x27; modules are automatically loaded. If an
   *        object literal is passed each key-value pair will be registered on the module via
   *        {@link auto.$provide $provide}.value, the key being the string name (or token) to associate
   *        with the value on the injector.
   */
  window.module = angular.mock.module = function() {
    var moduleFns = Array.prototype.slice.call(arguments, 0);
    return isSpecRunning() ? workFn() : workFn;
    /////////////////////
    function workFn() {
      if (currentSpec.$injector) {
        throw new Error(&#x27;Injector already created, can not register a module!&#x27;);
      } else {
        var fn, modules = currentSpec.$modules || (currentSpec.$modules = []);
        angular.forEach(moduleFns, function(module) {
          if (angular.isObject(module) &amp;&amp; !angular.isArray(module)) {
            fn = function($provide) {
              angular.forEach(module, function(value, key) {
                $provide.value(key, value);
              });
            };
          } else {
            fn = module;
          }
          if (currentSpec.$providerInjector) {
            currentSpec.$providerInjector.invoke(fn);
          } else {
            modules.push(fn);
          }
        });
      }
    }
  };

  /**
   * @ngdoc function
   * @name angular.mock.inject
   * @description
   *
   * *NOTE*: This function is also published on window for easy access.&lt;br&gt;
   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
   *
   * The inject function wraps a function into an injectable function. The inject() creates new
   * instance of {@link auto.$injector $injector} per test, which is then used for
   * resolving references.
   *
   *
   * ## Resolving References (Underscore Wrapping)
   * Often, we would like to inject a reference once, in a &#x60;beforeEach()&#x60; block and reuse this
   * in multiple &#x60;it()&#x60; clauses. To be able to do this we must assign the reference to a variable
   * that is declared in the scope of the &#x60;describe()&#x60; block. Since we would, most likely, want
   * the variable to have the same name of the reference we have a problem, since the parameter
   * to the &#x60;inject()&#x60; function would hide the outer variable.
   *
   * To help with this, the injected parameters can, optionally, be enclosed with underscores.
   * These are ignored by the injector when the reference name is resolved.
   *
   * For example, the parameter &#x60;_myService_&#x60; would be resolved as the reference &#x60;myService&#x60;.
   * Since it is available in the function body as _myService_, we can then assign it to a variable
   * defined in an outer scope.
   *
   * &#x60;&#x60;&#x60;
   * // Defined out reference variable outside
   * var myService;
   *
   * // Wrap the parameter in underscores
   * beforeEach( inject( function(_myService_){
   *   myService = _myService_;
   * }));
   *
   * // Use myService in a series of tests.
   * it(&#x27;makes use of myService&#x27;, function() {
   *   myService.doStuff();
   * });
   *
   * &#x60;&#x60;&#x60;
   *
   * See also {@link angular.mock.module angular.mock.module}
   *
   * ## Example
   * Example of what a typical jasmine tests looks like with the inject method.
   * &#x60;&#x60;&#x60;js
   *
   *   angular.module(&#x27;myApplicationModule&#x27;, [])
   *       .value(&#x27;mode&#x27;, &#x27;app&#x27;)
   *       .value(&#x27;version&#x27;, &#x27;v1.0.1&#x27;);
   *
   *
   *   describe(&#x27;MyApp&#x27;, function() {
   *
   *     // You need to load modules that you want to test,
   *     // it loads only the &quot;ng&quot; module by default.
   *     beforeEach(module(&#x27;myApplicationModule&#x27;));
   *
   *
   *     // inject() is used to inject arguments of all given functions
   *     it(&#x27;should provide a version&#x27;, inject(function(mode, version) {
   *       expect(version).toEqual(&#x27;v1.0.1&#x27;);
   *       expect(mode).toEqual(&#x27;app&#x27;);
   *     }));
   *
   *
   *     // The inject and module method can also be used inside of the it or beforeEach
   *     it(&#x27;should override a version and test the new version is injected&#x27;, function() {
   *       // module() takes functions or strings (module aliases)
   *       module(function($provide) {
   *         $provide.value(&#x27;version&#x27;, &#x27;overridden&#x27;); // override version here
   *       });
   *
   *       inject(function(version) {
   *         expect(version).toEqual(&#x27;overridden&#x27;);
   *       });
   *     });
   *   });
   *
   * &#x60;&#x60;&#x60;
   *
   * @param {...Function} fns any number of functions which will be injected using the injector.
   */



  var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
    this.message = e.message;
    this.name = e.name;
    if (e.line) this.line = e.line;
    if (e.sourceId) this.sourceId = e.sourceId;
    if (e.stack &amp;&amp; errorForStack)
      this.stack = e.stack + &#x27;\n&#x27; + errorForStack.stack;
    if (e.stackArray) this.stackArray = e.stackArray;
  };
  ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;

  window.inject = angular.mock.inject = function() {
    var blockFns = Array.prototype.slice.call(arguments, 0);
    var errorForStack = new Error(&#x27;Declaration Location&#x27;);
    return isSpecRunning() ? workFn.call(currentSpec) : workFn;
    /////////////////////
    function workFn() {
      var modules = currentSpec.$modules || [];
      var strictDi = !!currentSpec.$injectorStrict;
      modules.unshift(function($injector) {
        currentSpec.$providerInjector = $injector;
      });
      modules.unshift(&#x27;ngMock&#x27;);
      modules.unshift(&#x27;ng&#x27;);
      var injector = currentSpec.$injector;
      if (!injector) {
        if (strictDi) {
          // If strictDi is enabled, annotate the providerInjector blocks
          angular.forEach(modules, function(moduleFn) {
            if (typeof moduleFn === &quot;function&quot;) {
              angular.injector.$$annotate(moduleFn);
            }
          });
        }
        injector = currentSpec.$injector = angular.injector(modules, strictDi);
        currentSpec.$injectorStrict = strictDi;
      }
      for (var i = 0, ii = blockFns.length; i &lt; ii; i++) {
        if (currentSpec.$injectorStrict) {
          // If the injector is strict / strictDi, and the spec wants to inject using automatic
          // annotation, then annotate the function here.
          injector.annotate(blockFns[i]);
        }
        try {
          /* jshint -W040 *//* Jasmine explicitly provides a &#x60;this&#x60; object when calling functions */
          injector.invoke(blockFns[i] || angular.noop, this);
          /* jshint +W040 */
        } catch (e) {
          if (e.stack &amp;&amp; errorForStack) {
            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
          }
          throw e;
        } finally {
          errorForStack = null;
        }
      }
    }
  };


  angular.mock.inject.strictDi = function(value) {
    value = arguments.length ? !!value : true;
    return isSpecRunning() ? workFn() : workFn;

    function workFn() {
      if (value !== currentSpec.$injectorStrict) {
        if (currentSpec.$injector) {
          throw new Error(&#x27;Injector already created, can not modify strict annotations&#x27;);
        } else {
          currentSpec.$injectorStrict = value;
        }
      }
    }
  };
}


})(window, window.angular);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
