<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>web\bower_components\angular-material\modules\closure\autocomplete\autocomplete.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/editController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">editController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/GruntFile
                
                Was attempting to do gruntdocs....html">GruntFile
                
                Was attempting to do gruntdocs...</a></li>
                                <li><a href="../classes/mentorshipNotificationController
                
                Notifications for mentorships are dealt with here..html">mentorshipNotificationController
                
                Notifications for mentorships are dealt with here.</a></li>
                                <li><a href="../classes/muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application..html">muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file..html">personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file.</a></li>
                                <li><a href="../classes/personNotificationController
                
                Notifications for persons are dealt with here..html">personNotificationController
                
                Notifications for persons are dealt with here.</a></li>
                                <li><a href="../classes/searchController
                
                Entire Search Functionality located here..html">searchController
                
                Entire Search Functionality located here.</a></li>
                                <li><a href="../classes/submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc.html">submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc</a></li>
                                <li><a href="../classes/supervisionNotificationController
                
                Notifications for supervision are dealt with here..html">supervisionNotificationController
                
                Notifications for supervision are dealt with here.</a></li>
                                <li><a href="../classes/userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions..html">userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions.</a></li>
                                <li><a href="../classes/viewController
                
                This controller does all that can be done with the view page..html">viewController
                
                This controller does all that can be done with the view page.</a></li>
                                <li><a href="../classes/visController
                
                Notifications for mentorships are dealt with here..html">visController
                
                Notifications for mentorships are dealt with here.</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/auditTrailController.html">auditTrailController</a></li>
                                <li><a href="../modules/editController.html">editController</a></li>
                                <li><a href="../modules/GruntFile.html">GruntFile</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/mentorshipNotificationController.html">mentorshipNotificationController</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                                <li><a href="../modules/personNotificationController.html">personNotificationController</a></li>
                                <li><a href="../modules/searchController.html">searchController</a></li>
                                <li><a href="../modules/submitController.html">submitController</a></li>
                                <li><a href="../modules/supervisionNotificationController.html">supervisionNotificationController</a></li>
                                <li><a href="../modules/userController.html">userController</a></li>
                                <li><a href="../modules/userDialogController.html">userDialogController</a></li>
                                <li><a href="../modules/viewController.html">viewController</a></li>
                                <li><a href="../modules/visController.html">visController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: web\bower_components\angular-material\modules\closure\autocomplete\autocomplete.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.6
 */
goog.provide(&#x27;ng.material.components.autocomplete&#x27;);
goog.require(&#x27;ng.material.components.icon&#x27;);
goog.require(&#x27;ng.material.components.virtualRepeat&#x27;);
goog.require(&#x27;ng.material.core&#x27;);
/**
 * @ngdoc module
 * @name material.components.autocomplete
 */
/*
 * @see js folder for autocomplete implementation
 */
angular.module(&#x27;material.components.autocomplete&#x27;, [
  &#x27;material.core&#x27;,
  &#x27;material.components.icon&#x27;,
  &#x27;material.components.virtualRepeat&#x27;
]);

angular
    .module(&#x27;material.components.autocomplete&#x27;)
    .controller(&#x27;MdAutocompleteCtrl&#x27;, MdAutocompleteCtrl);

var ITEM_HEIGHT   = 41,
    MAX_HEIGHT    = 5.5 * ITEM_HEIGHT,
    MENU_PADDING  = 8,
    INPUT_PADDING = 2; // Padding provided by &#x60;md-input-container&#x60;

function MdAutocompleteCtrl ($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window,
                             $animate, $rootElement, $attrs, $q) {
  //-- private variables
  var ctrl                 = this,
      itemParts            = $scope.itemsExpr.split(/ in /i),
      itemExpr             = itemParts[ 1 ],
      elements             = null,
      cache                = {},
      noBlur               = false,
      selectedItemWatchers = [],
      hasFocus             = false,
      lastCount            = 0,
      promiseFetch         = false;

  //-- public variables with handlers
  defineProperty(&#x27;hidden&#x27;, handleHiddenChange, true);

  //-- public variables
  ctrl.scope      = $scope;
  ctrl.parent     = $scope.$parent;
  ctrl.itemName   = itemParts[ 0 ];
  ctrl.matches    = [];
  ctrl.loading    = false;
  ctrl.hidden     = true;
  ctrl.index      = null;
  ctrl.messages   = [];
  ctrl.id         = $mdUtil.nextUid();
  ctrl.isDisabled = null;
  ctrl.isRequired = null;
  ctrl.hasNotFound = false;

  //-- public methods
  ctrl.keydown                       = keydown;
  ctrl.blur                          = blur;
  ctrl.focus                         = focus;
  ctrl.clear                         = clearValue;
  ctrl.select                        = select;
  ctrl.listEnter                     = onListEnter;
  ctrl.listLeave                     = onListLeave;
  ctrl.mouseUp                       = onMouseup;
  ctrl.getCurrentDisplayValue        = getCurrentDisplayValue;
  ctrl.registerSelectedItemWatcher   = registerSelectedItemWatcher;
  ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
  ctrl.notFoundVisible               = notFoundVisible;
  ctrl.loadingIsVisible              = loadingIsVisible;

  return init();

  //-- initialization methods

  /**
   * Initialize the controller, setup watchers, gather elements
   */
  function init () {
    $mdUtil.initOptionalProperties($scope, $attrs, { searchText: null, selectedItem: null });
    $mdTheming($element);
    configureWatchers();
    $mdUtil.nextTick(function () {
      gatherElements();
      moveDropdown();
      focusElement();
      $element.on(&#x27;focus&#x27;, focusElement);
    });
  }

  /**
   * Calculates the dropdown&#x27;s position and applies the new styles to the menu element
   * @returns {*}
   */
  function positionDropdown () {
    if (!elements) return $mdUtil.nextTick(positionDropdown, false, $scope);
    var hrect  = elements.wrap.getBoundingClientRect(),
        vrect  = elements.snap.getBoundingClientRect(),
        root   = elements.root.getBoundingClientRect(),
        top    = vrect.bottom - root.top,
        bot    = root.bottom - vrect.top,
        left   = hrect.left - root.left,
        width  = hrect.width,
        offset = getVerticalOffset(),
        styles;
    // Adjust the width to account for the padding provided by &#x60;md-input-container&#x60;
    if ($attrs.mdFloatingLabel) {
      left += INPUT_PADDING;
      width -= INPUT_PADDING * 2;
    }
    styles = {
      left:     left + &#x27;px&#x27;,
      minWidth: width + &#x27;px&#x27;,
      maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + &#x27;px&#x27;
    };
    if (top &gt; bot &amp;&amp; root.height - hrect.bottom - MENU_PADDING &lt; MAX_HEIGHT) {
      styles.top       = &#x27;auto&#x27;;
      styles.bottom    = bot + &#x27;px&#x27;;
      styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + &#x27;px&#x27;;
    } else {
      styles.top       = (top - offset) + &#x27;px&#x27;;
      styles.bottom    = &#x27;auto&#x27;;
      styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + &#x27;px&#x27;;
    }

    elements.$.scrollContainer.css(styles);
    $mdUtil.nextTick(correctHorizontalAlignment, false);

    /**
     * Calculates the vertical offset for floating label examples to account for ngMessages
     * @returns {number}
     */
    function getVerticalOffset () {
      var offset = 0;
      var inputContainer = $element.find(&#x27;md-input-container&#x27;);
      if (inputContainer.length) {
        var input = inputContainer.find(&#x27;input&#x27;);
        offset = inputContainer.prop(&#x27;offsetHeight&#x27;);
        offset -= input.prop(&#x27;offsetTop&#x27;);
        offset -= input.prop(&#x27;offsetHeight&#x27;);
        // add in the height left up top for the floating label text
        offset += inputContainer.prop(&#x27;offsetTop&#x27;);
      }
      return offset;
    }

    /**
     * Makes sure that the menu doesn&#x27;t go off of the screen on either side.
     */
    function correctHorizontalAlignment () {
      var dropdown = elements.scrollContainer.getBoundingClientRect(),
          styles   = {};
      if (dropdown.right &gt; root.right - MENU_PADDING) {
        styles.left = (hrect.right - dropdown.width) + &#x27;px&#x27;;
      }
      elements.$.scrollContainer.css(styles);
    }
  }

  /**
   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.
   */
  function moveDropdown () {
    if (!elements.$.root.length) return;
    $mdTheming(elements.$.scrollContainer);
    elements.$.scrollContainer.detach();
    elements.$.root.append(elements.$.scrollContainer);
    if ($animate.pin) $animate.pin(elements.$.scrollContainer, $rootElement);
  }

  /**
   * Sends focus to the input element.
   */
  function focusElement () {
    if ($scope.autofocus) elements.input.focus();
  }

  /**
   * Sets up any watchers used by autocomplete
   */
  function configureWatchers () {
    var wait = parseInt($scope.delay, 10) || 0;
    $attrs.$observe(&#x27;disabled&#x27;, function (value) { ctrl.isDisabled = !!value; });
    $attrs.$observe(&#x27;required&#x27;, function (value) { ctrl.isRequired = !!value; });
    $scope.$watch(&#x27;searchText&#x27;, wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
    $scope.$watch(&#x27;selectedItem&#x27;, selectedItemChange);
    angular.element($window).on(&#x27;resize&#x27;, positionDropdown);
    $scope.$on(&#x27;$destroy&#x27;, cleanup);
  }

  /**
   * Removes any events or leftover elements created by this controller
   */
  function cleanup () {
    if(!ctrl.hidden) {
      $mdUtil.enableScrolling();
    }

    angular.element($window).off(&#x27;resize&#x27;, positionDropdown);
    if ( elements ){
      var items = &#x27;ul scroller scrollContainer input&#x27;.split(&#x27; &#x27;);
      angular.forEach(items, function(key){
        elements.$[key].remove();
      });
    }
  }

  /**
   * Gathers all of the elements needed for this controller
   */
  function gatherElements () {
    elements = {
      main:  $element[0],
      scrollContainer: $element[0].getElementsByClassName(&#x27;md-virtual-repeat-container&#x27;)[0],
      scroller: $element[0].getElementsByClassName(&#x27;md-virtual-repeat-scroller&#x27;)[0],
      ul:    $element.find(&#x27;ul&#x27;)[0],
      input: $element.find(&#x27;input&#x27;)[0],
      wrap:  $element.find(&#x27;md-autocomplete-wrap&#x27;)[0],
      root:  document.body
    };
    elements.li   = elements.ul.getElementsByTagName(&#x27;li&#x27;);
    elements.snap = getSnapTarget();
    elements.$    = getAngularElements(elements);
  }

  /**
   * Finds the element that the menu will base its position on
   * @returns {*}
   */
  function getSnapTarget () {
    for (var element = $element; element.length; element = element.parent()) {
      if (angular.isDefined(element.attr(&#x27;md-autocomplete-snap&#x27;))) return element[ 0 ];
    }
    return elements.wrap;
  }

  /**
   * Gathers angular-wrapped versions of each element
   * @param elements
   * @returns {{}}
   */
  function getAngularElements (elements) {
    var obj = {};
    for (var key in elements) {
      if (elements.hasOwnProperty(key)) obj[ key ] = angular.element(elements[ key ]);
    }
    return obj;
  }

  //-- event/change handlers

  /**
   * Handles changes to the &#x60;hidden&#x60; property.
   * @param hidden
   * @param oldHidden
   */
  function handleHiddenChange (hidden, oldHidden) {
    if (!hidden &amp;&amp; oldHidden) {
      positionDropdown();

      if (elements) {
        $mdUtil.nextTick(function () {
          $mdUtil.disableScrollAround(elements.ul);
        }, false, $scope);
      }
    } else if (hidden &amp;&amp; !oldHidden) {
      $mdUtil.nextTick(function () {
        $mdUtil.enableScrolling();
      }, false, $scope);
    }
  }

  /**
   * When the user mouses over the dropdown menu, ignore blur events.
   */
  function onListEnter () {
    noBlur = true;
  }

  /**
   * When the user&#x27;s mouse leaves the menu, blur events may hide the menu again.
   */
  function onListLeave () {
    if (!hasFocus) elements.input.focus();
    noBlur = false;
    ctrl.hidden = shouldHide();
  }

  /**
   * When the mouse button is released, send focus back to the input field.
   */
  function onMouseup () {
    elements.input.focus();
  }

  /**
   * Handles changes to the selected item.
   * @param selectedItem
   * @param previousSelectedItem
   */
  function selectedItemChange (selectedItem, previousSelectedItem) {
    if (selectedItem) {
      getDisplayValue(selectedItem).then(function (val) {
        $scope.searchText = val;
        handleSelectedItemChange(selectedItem, previousSelectedItem);
      });
    }

    if (selectedItem !== previousSelectedItem) announceItemChange();
  }

  /**
   * Use the user-defined expression to announce changes each time a new item is selected
   */
  function announceItemChange () {
    angular.isFunction($scope.itemChange) &amp;&amp; $scope.itemChange(getItemAsNameVal($scope.selectedItem));
  }

  /**
   * Use the user-defined expression to announce changes each time the search text is changed
   */
  function announceTextChange () {
    angular.isFunction($scope.textChange) &amp;&amp; $scope.textChange();
  }

  /**
   * Calls any external watchers listening for the selected item.  Used in conjunction with
   * &#x60;registerSelectedItemWatcher&#x60;.
   * @param selectedItem
   * @param previousSelectedItem
   */
  function handleSelectedItemChange (selectedItem, previousSelectedItem) {
    selectedItemWatchers.forEach(function (watcher) { watcher(selectedItem, previousSelectedItem); });
  }

  /**
   * Register a function to be called when the selected item changes.
   * @param cb
   */
  function registerSelectedItemWatcher (cb) {
    if (selectedItemWatchers.indexOf(cb) == -1) {
      selectedItemWatchers.push(cb);
    }
  }

  /**
   * Unregister a function previously registered for selected item changes.
   * @param cb
   */
  function unregisterSelectedItemWatcher (cb) {
    var i = selectedItemWatchers.indexOf(cb);
    if (i != -1) {
      selectedItemWatchers.splice(i, 1);
    }
  }

  /**
   * Handles changes to the searchText property.
   * @param searchText
   * @param previousSearchText
   */
  function handleSearchText (searchText, previousSearchText) {
    ctrl.index = getDefaultIndex();
    // do nothing on init
    if (searchText === previousSearchText) return;

    getDisplayValue($scope.selectedItem).then(function (val) {
      // clear selected item if search text no longer matches it
      if (searchText !== val) {
        $scope.selectedItem = null;

        // trigger change event if available
        if (searchText !== previousSearchText) announceTextChange();

        // cancel results if search text is not long enough
        if (!isMinLengthMet()) {
          ctrl.matches = [];
          setLoading(false);
          updateMessages();
        } else {
          handleQuery();
        }
      }
    });

  }

  /**
   * Handles input blur event, determines if the dropdown should hide.
   */
  function blur () {
    hasFocus = false;
    if (!noBlur) {
      ctrl.hidden = shouldHide();
    }
  }

  /**
   * Force blur on input element
   * @param forceBlur
   */
  function doBlur(forceBlur) {
    if (forceBlur) {
      noBlur = false;
      hasFocus = false;
    }
    elements.input.blur();
  }

  /**
   * Handles input focus event, determines if the dropdown should show.
   */
  function focus () {
    hasFocus = true;
    //-- if searchText is null, let&#x27;s force it to be a string
    if (!angular.isString($scope.searchText)) $scope.searchText = &#x27;&#x27;;
    ctrl.hidden = shouldHide();
    if (!ctrl.hidden) handleQuery();
  }

  /**
   * Handles keyboard input.
   * @param event
   */
  function keydown (event) {
    switch (event.keyCode) {
      case $mdConstant.KEY_CODE.DOWN_ARROW:
        if (ctrl.loading) return;
        event.stopPropagation();
        event.preventDefault();
        ctrl.index   = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
        updateScroll();
        updateMessages();
        break;
      case $mdConstant.KEY_CODE.UP_ARROW:
        if (ctrl.loading) return;
        event.stopPropagation();
        event.preventDefault();
        ctrl.index   = ctrl.index &lt; 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
        updateScroll();
        updateMessages();
        break;
      case $mdConstant.KEY_CODE.TAB:
        // If we hit tab, assume that we&#x27;ve left the list so it will close
        onListLeave();

        if (ctrl.hidden || ctrl.loading || ctrl.index &lt; 0 || ctrl.matches.length &lt; 1) return;
        select(ctrl.index);
        break;
      case $mdConstant.KEY_CODE.ENTER:
        if (ctrl.hidden || ctrl.loading || ctrl.index &lt; 0 || ctrl.matches.length &lt; 1) return;
        if (hasSelection()) return;
        event.stopPropagation();
        event.preventDefault();
        select(ctrl.index);
        break;
      case $mdConstant.KEY_CODE.ESCAPE:
        event.stopPropagation();
        event.preventDefault();
        clearValue();

        // Force the component to blur if they hit escape
        doBlur(true);

        break;
      default:
    }
  }

  //-- getters

  /**
   * Returns the minimum length needed to display the dropdown.
   * @returns {*}
   */
  function getMinLength () {
    return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
  }

  /**
   * Returns the display value for an item.
   * @param item
   * @returns {*}
   */
  function getDisplayValue (item) {
    return $q.when(getItemText(item) || item);

    /**
     * Getter function to invoke user-defined expression (in the directive)
     * to convert your object to a single string.
     */
    function getItemText (item) {
      return (item &amp;&amp; $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
    }
  }

  /**
   * Returns the locals object for compiling item templates.
   * @param item
   * @returns {{}}
   */
  function getItemAsNameVal (item) {
    if (!item) return undefined;

    var locals = {};
    if (ctrl.itemName) locals[ ctrl.itemName ] = item;

    return locals;
  }

  /**
   * Returns the default index based on whether or not autoselect is enabled.
   * @returns {number}
   */
  function getDefaultIndex () {
    return $scope.autoselect ? 0 : -1;
  }

  /**
   * Sets the loading parameter and updates the hidden state.
   * @param value {boolean} Whether or not the component is currently loading.
   */
  function setLoading(value) {
    if (ctrl.loading != value) {
      ctrl.loading = value;
    }

    // Always refresh the hidden variable as something else might have changed
    ctrl.hidden = shouldHide();
  }

  /**
   * Determines if the menu should be hidden.
   * @returns {boolean}
   */
  function shouldHide () {
    if (ctrl.loading &amp;&amp; !hasMatches()) return true; // Hide while loading initial matches
    else if (hasSelection()) return true;           // Hide if there is already a selection
    else if (!hasFocus) return true;                // Hide if the input does not have focus
    else return !shouldShow();                      // Defer to standard show logic
  }

  /**
   * Determines if the menu should be shown.
   * @returns {boolean}
   */
  function shouldShow() {
    return (isMinLengthMet() &amp;&amp; hasMatches()) || notFoundVisible();
  }

  /**
   * Returns true if the search text has matches.
   * @returns {boolean}
   */
  function hasMatches() {
    return ctrl.matches.length ? true : false;
  }

  /**
   * Returns true if the autocomplete has a valid selection.
   * @returns {boolean}
   */
  function hasSelection() {
    return ctrl.scope.selectedItem ? true : false;
  }

  /**
   * Returns true if the loading indicator is, or should be, visible.
   * @returns {boolean}
   */
  function loadingIsVisible() {
    return ctrl.loading &amp;&amp; !hasSelection();
  }

  /**
   * Returns the display value of the current item.
   * @returns {*}
   */
  function getCurrentDisplayValue () {
    return getDisplayValue(ctrl.matches[ ctrl.index ]);
  }

  /**
   * Determines if the minimum length is met by the search text.
   * @returns {*}
   */
  function isMinLengthMet () {
    return ($scope.searchText || &#x27;&#x27;).length &gt;= getMinLength();
  }

  //-- actions

  /**
   * Defines a public property with a handler and a default value.
   * @param key
   * @param handler
   * @param value
   */
  function defineProperty (key, handler, value) {
    Object.defineProperty(ctrl, key, {
      get: function () { return value; },
      set: function (newValue) {
        var oldValue = value;
        value        = newValue;
        handler(newValue, oldValue);
      }
    });
  }

  /**
   * Selects the item at the given index.
   * @param index
   */
  function select (index) {
    //-- force form to update state for validation
    $mdUtil.nextTick(function () {
      getDisplayValue(ctrl.matches[ index ]).then(function (val) {
        var ngModel = elements.$.input.controller(&#x27;ngModel&#x27;);
        ngModel.$setViewValue(val);
        ngModel.$render();
      }).finally(function () {
        $scope.selectedItem = ctrl.matches[ index ];
        setLoading(false);
      });
    }, false);
  }

  /**
   * Clears the searchText value and selected item.
   */
  function clearValue () {
    // Set the loading to true so we don&#x27;t see flashes of content
    setLoading(true);

    // Reset our variables
    ctrl.index = 0;
    ctrl.matches = [];
    $scope.searchText = &#x27;&#x27;;

    // Tell the select to fire and select nothing
    select(-1);

    // Per http://www.w3schools.com/jsref/event_oninput.asp
    var eventObj = document.createEvent(&#x27;CustomEvent&#x27;);
    eventObj.initCustomEvent(&#x27;input&#x27;, true, true, { value: $scope.searchText });
    elements.input.dispatchEvent(eventObj);

    elements.input.focus();
  }

  /**
   * Fetches the results for the provided search text.
   * @param searchText
   */
  function fetchResults (searchText) {
    var items = $scope.$parent.$eval(itemExpr),
        term  = searchText.toLowerCase();
    if (angular.isArray(items)) {
      handleResults(items);
    } else if (items) {
      setLoading(true);
      promiseFetch = true;
      $mdUtil.nextTick(function () {
        if (items.success) items.success(handleResults);
        if (items.then)    items.then(handleResults);
        if (items.finally) items.finally(function () {
          setLoading(false);
          promiseFetch = false;
        });
      },true, $scope);
    }
    function handleResults (matches) {
      cache[ term ] = matches;
      if ((searchText || &#x27;&#x27;) !== ($scope.searchText || &#x27;&#x27;)) return; //-- just cache the results if old request
      ctrl.matches = matches;
      ctrl.hidden  = shouldHide();
      if ($scope.selectOnMatch) selectItemOnMatch();
      updateMessages();
      positionDropdown();
    }
  }

  /**
   * Updates the ARIA messages
   */
  function updateMessages () {
    getCurrentDisplayValue().then(function (msg) {
      ctrl.messages = [ getCountMessage(), msg ];
    });
  }

  /**
   * Returns the ARIA message for how many results match the current query.
   * @returns {*}
   */
  function getCountMessage () {
    if (lastCount === ctrl.matches.length) return &#x27;&#x27;;
    lastCount = ctrl.matches.length;
    switch (ctrl.matches.length) {
      case 0:
        return &#x27;There are no matches available.&#x27;;
      case 1:
        return &#x27;There is 1 match available.&#x27;;
      default:
        return &#x27;There are &#x27; + ctrl.matches.length + &#x27; matches available.&#x27;;
    }
  }

  /**
   * Makes sure that the focused element is within view.
   */
  function updateScroll () {
    if (!elements.li[0]) return;
    var height = elements.li[0].offsetHeight,
        top = height * ctrl.index,
        bot = top + height,
        hgt = elements.scroller.clientHeight,
        scrollTop = elements.scroller.scrollTop;
    if (top &lt; scrollTop) {
      scrollTo(top);
    } else if (bot &gt; scrollTop + hgt) {
      scrollTo(bot - hgt);
    }
  }

  function scrollTo (offset) {
    elements.$.scrollContainer.controller(&#x27;mdVirtualRepeatContainer&#x27;).scrollTo(offset);
  }

  function notFoundVisible () {
    var textLength = (ctrl.scope.searchText || &#x27;&#x27;).length;

    return ctrl.hasNotFound &amp;&amp; !hasMatches() &amp;&amp; (!ctrl.loading || promiseFetch) &amp;&amp; textLength &gt;= getMinLength() &amp;&amp; (hasFocus || noBlur) &amp;&amp; !hasSelection();
  }

  /**
   * Starts the query to gather the results for the current searchText.  Attempts to return cached
   * results first, then forwards the process to &#x60;fetchResults&#x60; if necessary.
   */
  function handleQuery () {
    var searchText = $scope.searchText || &#x27;&#x27;,
        term       = searchText.toLowerCase();
    //-- if results are cached, pull in cached results
    if (!$scope.noCache &amp;&amp; cache[ term ]) {
      ctrl.matches = cache[ term ];
      updateMessages();
    } else {
      fetchResults(searchText);
    }

    ctrl.hidden = shouldHide();
  }

  /**
   * If there is only one matching item and the search text matches its display value exactly,
   * automatically select that item.  Note: This function is only called if the user uses the
   * &#x60;md-select-on-match&#x60; flag.
   */
  function selectItemOnMatch () {
    var searchText = $scope.searchText,
        matches    = ctrl.matches,
        item       = matches[ 0 ];
    if (matches.length === 1) getDisplayValue(item).then(function (displayValue) {
      if (searchText == displayValue) select(0);
    });
  }

}
MdAutocompleteCtrl.$inject = [&quot;$scope&quot;, &quot;$element&quot;, &quot;$mdUtil&quot;, &quot;$mdConstant&quot;, &quot;$mdTheming&quot;, &quot;$window&quot;, &quot;$animate&quot;, &quot;$rootElement&quot;, &quot;$attrs&quot;, &quot;$q&quot;];

angular
    .module(&#x27;material.components.autocomplete&#x27;)
    .directive(&#x27;mdAutocomplete&#x27;, MdAutocomplete);

/**
 * @ngdoc directive
 * @name mdAutocomplete
 * @module material.components.autocomplete
 *
 * @description
 * &#x60;&lt;md-autocomplete&gt;&#x60; is a special input component with a drop-down of all possible matches to a
 *     custom query. This component allows you to provide real-time suggestions as the user types
 *     in the input area.
 *
 * To start, you will need to specify the required parameters and provide a template for your
 *     results. The content inside &#x60;md-autocomplete&#x60; will be treated as a template.
 *
 * In more complex cases, you may want to include other content such as a message to display when
 *     no matches were found.  You can do this by wrapping your template in &#x60;md-item-template&#x60; and
 *     adding a tag for &#x60;md-not-found&#x60;.  An example of this is shown below.
 *
 * ### Validation
 *
 * You can use &#x60;ng-messages&#x60; to include validation the same way that you would normally validate;
 *     however, if you want to replicate a standard input with a floating label, you will have to
 *     do the following:
 *
 * - Make sure that your template is wrapped in &#x60;md-item-template&#x60;
 * - Add your &#x60;ng-messages&#x60; code inside of &#x60;md-autocomplete&#x60;
 * - Add your validation properties to &#x60;md-autocomplete&#x60; (ie. &#x60;required&#x60;)
 * - Add a &#x60;name&#x60; to &#x60;md-autocomplete&#x60; (to be used on the generated &#x60;input&#x60;)
 *
 * There is an example below of how this should look.
 *
 *
 * @param {expression} md-items An expression in the format of &#x60;item in items&#x60; to iterate over
 *     matches for your search.
 * @param {expression=} md-selected-item-change An expression to be run each time a new item is
 *     selected
 * @param {expression=} md-search-text-change An expression to be run each time the search text
 *     updates
 * @param {expression=} md-search-text A model to bind the search query text to
 * @param {object=} md-selected-item A model to bind the selected item to
 * @param {expression=} md-item-text An expression that will convert your object to a single string.
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete
 * @param {boolean=} ng-disabled Determines whether or not to disable the input field
 * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will
 *     make suggestions
 * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking
 *     for results
 * @param {boolean=} md-autofocus If true, the autocomplete will be automatically focused when a &#x60;$mdDialog&#x60;,
 *     &#x60;$mdBottomsheet&#x60; or &#x60;$mdSidenav&#x60;, which contains the autocomplete, is opening. &lt;br/&gt;&lt;br/&gt;
 *     Also the autocomplete will immediately focus the input element.
 * @param {boolean=} md-autoselect If true, the first item will be selected by default
 * @param {string=} md-menu-class This will be applied to the dropdown menu for styling
 * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in
 *     &#x60;md-input-container&#x60;
 * @param {string=} md-input-name The name attribute given to the input element to be used with
 *     FormController
 * @param {string=} md-input-id An ID to be added to the input element
 * @param {number=} md-input-minlength The minimum length for the input&#x27;s value for validation
 * @param {number=} md-input-maxlength The maximum length for the input&#x27;s value for validation
 * @param {boolean=} md-select-on-match When set, autocomplete will automatically select exact
 *     the item if the search text is an exact match
 *
 * @usage
 * ### Basic Example
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;md-autocomplete
 *       md-selected-item=&quot;selectedItem&quot;
 *       md-search-text=&quot;searchText&quot;
 *       md-items=&quot;item in getMatches(searchText)&quot;
 *       md-item-text=&quot;item.display&quot;&gt;
 *     &lt;span md-highlight-text=&quot;searchText&quot;&gt;{{item.display}}&lt;/span&gt;
 *   &lt;/md-autocomplete&gt;
 * &lt;/hljs&gt;
 *
 * ### Example with &quot;not found&quot; message
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-autocomplete
 *     md-selected-item=&quot;selectedItem&quot;
 *     md-search-text=&quot;searchText&quot;
 *     md-items=&quot;item in getMatches(searchText)&quot;
 *     md-item-text=&quot;item.display&quot;&gt;
 *   &lt;md-item-template&gt;
 *     &lt;span md-highlight-text=&quot;searchText&quot;&gt;{{item.display}}&lt;/span&gt;
 *   &lt;/md-item-template&gt;
 *   &lt;md-not-found&gt;
 *     No matches found.
 *   &lt;/md-not-found&gt;
 * &lt;/md-autocomplete&gt;
 * &lt;/hljs&gt;
 *
 * In this example, our code utilizes &#x60;md-item-template&#x60; and &#x60;md-not-found&#x60; to specify the
 *     different parts that make up our component.
 *
 * ### Example with validation
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;form name=&quot;autocompleteForm&quot;&gt;
 *   &lt;md-autocomplete
 *       required
 *       md-input-name=&quot;autocomplete&quot;
 *       md-selected-item=&quot;selectedItem&quot;
 *       md-search-text=&quot;searchText&quot;
 *       md-items=&quot;item in getMatches(searchText)&quot;
 *       md-item-text=&quot;item.display&quot;&gt;
 *     &lt;md-item-template&gt;
 *       &lt;span md-highlight-text=&quot;searchText&quot;&gt;{{item.display}}&lt;/span&gt;
 *     &lt;/md-item-template&gt;
 *     &lt;div ng-messages=&quot;autocompleteForm.autocomplete.$error&quot;&gt;
 *       &lt;div ng-message=&quot;required&quot;&gt;This field is required&lt;/div&gt;
 *     &lt;/div&gt;
 *   &lt;/md-autocomplete&gt;
 * &lt;/form&gt;
 * &lt;/hljs&gt;
 *
 * In this example, our code utilizes &#x60;md-item-template&#x60; and &#x60;md-not-found&#x60; to specify the
 *     different parts that make up our component.
 */

function MdAutocomplete () {

  return {
    controller:   &#x27;MdAutocompleteCtrl&#x27;,
    controllerAs: &#x27;$mdAutocompleteCtrl&#x27;,
    scope:        {
      inputName:      &#x27;@mdInputName&#x27;,
      inputMinlength: &#x27;@mdInputMinlength&#x27;,
      inputMaxlength: &#x27;@mdInputMaxlength&#x27;,
      searchText:     &#x27;=?mdSearchText&#x27;,
      selectedItem:   &#x27;=?mdSelectedItem&#x27;,
      itemsExpr:      &#x27;@mdItems&#x27;,
      itemText:       &#x27;&amp;mdItemText&#x27;,
      placeholder:    &#x27;@placeholder&#x27;,
      noCache:        &#x27;=?mdNoCache&#x27;,
      selectOnMatch:  &#x27;=?mdSelectOnMatch&#x27;,
      itemChange:     &#x27;&amp;?mdSelectedItemChange&#x27;,
      textChange:     &#x27;&amp;?mdSearchTextChange&#x27;,
      minLength:      &#x27;=?mdMinLength&#x27;,
      delay:          &#x27;=?mdDelay&#x27;,
      autofocus:      &#x27;=?mdAutofocus&#x27;,
      floatingLabel:  &#x27;@?mdFloatingLabel&#x27;,
      autoselect:     &#x27;=?mdAutoselect&#x27;,
      menuClass:      &#x27;@?mdMenuClass&#x27;,
      inputId:        &#x27;@?mdInputId&#x27;
    },
    link: function(scope, element, attrs, controller) {
      // Retrieve the state of using a md-not-found template by using our attribute, which will
      // be added to the element in the template function.
      controller.hasNotFound = !!element.attr(&#x27;md-has-not-found&#x27;);
    },
    template:     function (element, attr) {
      var noItemsTemplate = getNoItemsTemplate(),
          itemTemplate    = getItemTemplate(),
          leftover        = element.html(),
          tabindex        = attr.tabindex;

      // Set our attribute for the link function above which runs later.
      // We will set an attribute, because otherwise the stored variables will be trashed when
      // removing the element is hidden while retrieving the template. For example when using ngIf.
      if (noItemsTemplate) element.attr(&#x27;md-has-not-found&#x27;, true);

      if (!attr.hasOwnProperty(&#x27;tabindex&#x27;)) element.attr(&#x27;tabindex&#x27;, &#x27;-1&#x27;);

      return &#x27;\
        &lt;md-autocomplete-wrap\
            layout=&quot;row&quot;\
            ng-class=&quot;{ \&#x27;md-whiteframe-z1\&#x27;: !floatingLabel, \&#x27;md-menu-showing\&#x27;: !$mdAutocompleteCtrl.hidden }&quot;\
            role=&quot;listbox&quot;&gt;\
          &#x27; + getInputElement() + &#x27;\
          &lt;md-progress-linear\
              class=&quot;&#x27; + (attr.mdFloatingLabel ? &#x27;md-inline&#x27; : &#x27;&#x27;) + &#x27;&quot;\
              ng-if=&quot;$mdAutocompleteCtrl.loadingIsVisible()&quot;\
              md-mode=&quot;indeterminate&quot;&gt;&lt;/md-progress-linear&gt;\
          &lt;md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min=&quot;1&quot;\
              ng-mouseenter=&quot;$mdAutocompleteCtrl.listEnter()&quot;\
              ng-mouseleave=&quot;$mdAutocompleteCtrl.listLeave()&quot;\
              ng-mouseup=&quot;$mdAutocompleteCtrl.mouseUp()&quot;\
              ng-hide=&quot;$mdAutocompleteCtrl.hidden&quot;\
              class=&quot;md-autocomplete-suggestions-container md-whiteframe-z1&quot;\
              ng-class=&quot;{ \&#x27;md-not-found\&#x27;: $mdAutocompleteCtrl.notFoundVisible() }&quot;\
              role=&quot;presentation&quot;&gt;\
            &lt;ul class=&quot;md-autocomplete-suggestions&quot;\
                ng-class=&quot;::menuClass&quot;\
                id=&quot;ul-{{$mdAutocompleteCtrl.id}}&quot;&gt;\
              &lt;li md-virtual-repeat=&quot;item in $mdAutocompleteCtrl.matches&quot;\
                  ng-class=&quot;{ selected: $index === $mdAutocompleteCtrl.index }&quot;\
                  ng-click=&quot;$mdAutocompleteCtrl.select($index)&quot;\
                  md-extra-name=&quot;$mdAutocompleteCtrl.itemName&quot;&gt;\
                  &#x27; + itemTemplate + &#x27;\
                  &lt;/li&gt;&#x27; + noItemsTemplate + &#x27;\
            &lt;/ul&gt;\
          &lt;/md-virtual-repeat-container&gt;\
        &lt;/md-autocomplete-wrap&gt;\
        &lt;aria-status\
            class=&quot;md-visually-hidden&quot;\
            role=&quot;status&quot;\
            aria-live=&quot;assertive&quot;&gt;\
          &lt;p ng-repeat=&quot;message in $mdAutocompleteCtrl.messages track by $index&quot; ng-if=&quot;message&quot;&gt;{{message}}&lt;/p&gt;\
        &lt;/aria-status&gt;&#x27;;

      function getItemTemplate() {
        var templateTag = element.find(&#x27;md-item-template&#x27;).detach(),
            html = templateTag.length ? templateTag.html() : element.html();
        if (!templateTag.length) element.empty();
        return &#x27;&lt;md-autocomplete-parent-scope md-autocomplete-replace&gt;&#x27; + html + &#x27;&lt;/md-autocomplete-parent-scope&gt;&#x27;;
      }

      function getNoItemsTemplate() {
        var templateTag = element.find(&#x27;md-not-found&#x27;).detach(),
            template = templateTag.length ? templateTag.html() : &#x27;&#x27;;
        return template
            ? &#x27;&lt;li ng-if=&quot;$mdAutocompleteCtrl.notFoundVisible()&quot;\
                         md-autocomplete-parent-scope&gt;&#x27; + template + &#x27;&lt;/li&gt;&#x27;
            : &#x27;&#x27;;

      }

      function getInputElement () {
        if (attr.mdFloatingLabel) {
          return &#x27;\
            &lt;md-input-container flex ng-if=&quot;floatingLabel&quot;&gt;\
              &lt;label&gt;{{floatingLabel}}&lt;/label&gt;\
              &lt;input type=&quot;search&quot;\
                  &#x27; + (tabindex != null ? &#x27;tabindex=&quot;&#x27; + tabindex + &#x27;&quot;&#x27; : &#x27;&#x27;) + &#x27;\
                  id=&quot;{{ inputId || \&#x27;fl-input-\&#x27; + $mdAutocompleteCtrl.id }}&quot;\
                  name=&quot;{{inputName}}&quot;\
                  autocomplete=&quot;off&quot;\
                  ng-required=&quot;$mdAutocompleteCtrl.isRequired&quot;\
                  ng-minlength=&quot;inputMinlength&quot;\
                  ng-maxlength=&quot;inputMaxlength&quot;\
                  ng-disabled=&quot;$mdAutocompleteCtrl.isDisabled&quot;\
                  ng-model=&quot;$mdAutocompleteCtrl.scope.searchText&quot;\
                  ng-keydown=&quot;$mdAutocompleteCtrl.keydown($event)&quot;\
                  ng-blur=&quot;$mdAutocompleteCtrl.blur()&quot;\
                  ng-focus=&quot;$mdAutocompleteCtrl.focus()&quot;\
                  aria-owns=&quot;ul-{{$mdAutocompleteCtrl.id}}&quot;\
                  aria-label=&quot;{{floatingLabel}}&quot;\
                  aria-autocomplete=&quot;list&quot;\
                  aria-haspopup=&quot;true&quot;\
                  aria-activedescendant=&quot;&quot;\
                  aria-expanded=&quot;{{!$mdAutocompleteCtrl.hidden}}&quot;/&gt;\
              &lt;div md-autocomplete-parent-scope md-autocomplete-replace&gt;&#x27; + leftover + &#x27;&lt;/div&gt;\
            &lt;/md-input-container&gt;&#x27;;
        } else {
          return &#x27;\
            &lt;input flex type=&quot;search&quot;\
                &#x27; + (tabindex != null ? &#x27;tabindex=&quot;&#x27; + tabindex + &#x27;&quot;&#x27; : &#x27;&#x27;) + &#x27;\
                id=&quot;{{ inputId || \&#x27;input-\&#x27; + $mdAutocompleteCtrl.id }}&quot;\
                name=&quot;{{inputName}}&quot;\
                ng-if=&quot;!floatingLabel&quot;\
                autocomplete=&quot;off&quot;\
                ng-required=&quot;$mdAutocompleteCtrl.isRequired&quot;\
                ng-disabled=&quot;$mdAutocompleteCtrl.isDisabled&quot;\
                ng-model=&quot;$mdAutocompleteCtrl.scope.searchText&quot;\
                ng-keydown=&quot;$mdAutocompleteCtrl.keydown($event)&quot;\
                ng-blur=&quot;$mdAutocompleteCtrl.blur()&quot;\
                ng-focus=&quot;$mdAutocompleteCtrl.focus()&quot;\
                placeholder=&quot;{{placeholder}}&quot;\
                aria-owns=&quot;ul-{{$mdAutocompleteCtrl.id}}&quot;\
                aria-label=&quot;{{placeholder}}&quot;\
                aria-autocomplete=&quot;list&quot;\
                aria-haspopup=&quot;true&quot;\
                aria-activedescendant=&quot;&quot;\
                aria-expanded=&quot;{{!$mdAutocompleteCtrl.hidden}}&quot;/&gt;\
            &lt;button\
                type=&quot;button&quot;\
                tabindex=&quot;-1&quot;\
                ng-if=&quot;$mdAutocompleteCtrl.scope.searchText &amp;&amp; !$mdAutocompleteCtrl.isDisabled&quot;\
                ng-click=&quot;$mdAutocompleteCtrl.clear()&quot;&gt;\
              &lt;md-icon md-svg-icon=&quot;md-close&quot;&gt;&lt;/md-icon&gt;\
              &lt;span class=&quot;md-visually-hidden&quot;&gt;Clear&lt;/span&gt;\
            &lt;/button&gt;\
                &#x27;;
        }
      }
    }
  };
}

angular
  .module(&#x27;material.components.autocomplete&#x27;)
  .directive(&#x27;mdAutocompleteParentScope&#x27;, MdAutocompleteItemScopeDirective);

function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
  return {
    restrict: &#x27;AE&#x27;,
    compile: compile,
    terminal: true,
    transclude: &#x27;element&#x27;
  };

  function compile(tElement, tAttr, transclude) {
    return function postLink(scope, element, attr) {
      var ctrl = scope.$mdAutocompleteCtrl;
      var newScope = ctrl.parent.$new();
      var itemName = ctrl.itemName;

      // Watch for changes to our scope&#x27;s variables and copy them to the new scope
      watchVariable(&#x27;$index&#x27;, &#x27;$index&#x27;);
      watchVariable(&#x27;item&#x27;, itemName);

      // Ensure that $digest calls on our scope trigger $digest on newScope.
      connectScopes();

      // Link the element against newScope.
      transclude(newScope, function(clone) {
        element.after(clone);
      });

      /**
       * Creates a watcher for variables that are copied from the parent scope
       * @param variable
       * @param alias
       */
      function watchVariable(variable, alias) {
        newScope[alias] = scope[variable];

        scope.$watch(variable, function(value) {
          $mdUtil.nextTick(function() {
            newScope[alias] = value;
          });
        });
      }

      /**
       * Creates watchers on scope and newScope that ensure that for any
       * $digest of scope, newScope is also $digested.
       */
      function connectScopes() {
        var scopeDigesting = false;
        var newScopeDigesting = false;

        scope.$watch(function() {
          if (newScopeDigesting || scopeDigesting) {
            return;
          }

          scopeDigesting = true;
          scope.$$postDigest(function() {
            if (!newScopeDigesting) {
              newScope.$digest();
            }

            scopeDigesting = newScopeDigesting = false;
          });
        });

        newScope.$watch(function() {
          newScopeDigesting = true;
        });
      }
    };
  }
}
MdAutocompleteItemScopeDirective.$inject = [&quot;$compile&quot;, &quot;$mdUtil&quot;];
angular
    .module(&#x27;material.components.autocomplete&#x27;)
    .controller(&#x27;MdHighlightCtrl&#x27;, MdHighlightCtrl);

function MdHighlightCtrl ($scope, $element, $attrs) {
  this.init = init;

  function init (termExpr, unsafeTextExpr) {
    var text = null,
        regex = null,
        flags = $attrs.mdHighlightFlags || &#x27;&#x27;,
        watcher = $scope.$watch(function($scope) {
          return {
            term: termExpr($scope),
            unsafeText: unsafeTextExpr($scope)
          };
        }, function (state, prevState) {
          if (text === null || state.unsafeText !== prevState.unsafeText) {
            text = angular.element(&#x27;&lt;div&gt;&#x27;).text(state.unsafeText).html()
          }
          if (regex === null || state.term !== prevState.term) {
            regex = getRegExp(state.term, flags);
          }

          $element.html(text.replace(regex, &#x27;&lt;span class=&quot;highlight&quot;&gt;$&amp;&lt;/span&gt;&#x27;));
        }, true);
    $element.on(&#x27;$destroy&#x27;, watcher);
  }

  function sanitize (term) {
    return term &amp;&amp; term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, &#x27;\\$&amp;&#x27;);
  }

  function getRegExp (text, flags) {
    var str = &#x27;&#x27;;
    if (flags.indexOf(&#x27;^&#x27;) &gt;= 1) str += &#x27;^&#x27;;
    str += text;
    if (flags.indexOf(&#x27;$&#x27;) &gt;= 1) str += &#x27;$&#x27;;
    return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, &#x27;&#x27;));
  }
}
MdHighlightCtrl.$inject = [&quot;$scope&quot;, &quot;$element&quot;, &quot;$attrs&quot;];

angular
    .module(&#x27;material.components.autocomplete&#x27;)
    .directive(&#x27;mdHighlightText&#x27;, MdHighlight);

/**
 * @ngdoc directive
 * @name mdHighlightText
 * @module material.components.autocomplete
 *
 * @description
 * The &#x60;md-highlight-text&#x60; directive allows you to specify text that should be highlighted within
 *     an element.  Highlighted text will be wrapped in &#x60;&lt;span class=&quot;highlight&quot;&gt;&lt;/span&gt;&#x60; which can
 *     be styled through CSS.  Please note that child elements may not be used with this directive.
 *
 * @param {string} md-highlight-text A model to be searched for
 * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).
 * #### **Supported flags**:
 * - &#x60;g&#x60;: Find all matches within the provided text
 * - &#x60;i&#x60;: Ignore case when searching for matches
 * - &#x60;$&#x60;: Only match if the text ends with the search term
 * - &#x60;^&#x60;: Only match if the text begins with the search term
 *
 * @usage
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;input placeholder=&quot;Enter a search term...&quot; ng-model=&quot;searchTerm&quot; type=&quot;text&quot; /&gt;
 * &lt;ul&gt;
 *   &lt;li ng-repeat=&quot;result in results&quot; md-highlight-text=&quot;searchTerm&quot;&gt;
 *     {{result.text}}
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/hljs&gt;
 */

function MdHighlight ($interpolate, $parse) {
  return {
    terminal: true,
    controller: &#x27;MdHighlightCtrl&#x27;,
    compile: function mdHighlightCompile(tElement, tAttr) {
      var termExpr = $parse(tAttr.mdHighlightText);
      var unsafeTextExpr = $interpolate(tElement.html());

      return function mdHighlightLink(scope, element, attr, ctrl) {
        ctrl.init(termExpr, unsafeTextExpr);
      };
    }
  };
}
MdHighlight.$inject = [&quot;$interpolate&quot;, &quot;$parse&quot;];

ng.material.components.autocomplete = angular.module(&quot;material.components.autocomplete&quot;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
