<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>web\bower_components\angular-material\modules\closure\select\select.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/editController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">editController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/GruntFile
                
                Was attempting to do gruntdocs....html">GruntFile
                
                Was attempting to do gruntdocs...</a></li>
                                <li><a href="../classes/mentorshipNotificationController
                
                Notifications for mentorships are dealt with here..html">mentorshipNotificationController
                
                Notifications for mentorships are dealt with here.</a></li>
                                <li><a href="../classes/muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application..html">muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file..html">personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file.</a></li>
                                <li><a href="../classes/personNotificationController
                
                Notifications for persons are dealt with here..html">personNotificationController
                
                Notifications for persons are dealt with here.</a></li>
                                <li><a href="../classes/searchController
                
                Entire Search Functionality located here..html">searchController
                
                Entire Search Functionality located here.</a></li>
                                <li><a href="../classes/submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc.html">submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc</a></li>
                                <li><a href="../classes/supervisionNotificationController
                
                Notifications for supervision are dealt with here..html">supervisionNotificationController
                
                Notifications for supervision are dealt with here.</a></li>
                                <li><a href="../classes/userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions..html">userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions.</a></li>
                                <li><a href="../classes/viewController
                
                This controller does all that can be done with the view page..html">viewController
                
                This controller does all that can be done with the view page.</a></li>
                                <li><a href="../classes/visController
                
                Notifications for mentorships are dealt with here..html">visController
                
                Notifications for mentorships are dealt with here.</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/auditTrailController.html">auditTrailController</a></li>
                                <li><a href="../modules/editController.html">editController</a></li>
                                <li><a href="../modules/GruntFile.html">GruntFile</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/mentorshipNotificationController.html">mentorshipNotificationController</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                                <li><a href="../modules/personNotificationController.html">personNotificationController</a></li>
                                <li><a href="../modules/searchController.html">searchController</a></li>
                                <li><a href="../modules/submitController.html">submitController</a></li>
                                <li><a href="../modules/supervisionNotificationController.html">supervisionNotificationController</a></li>
                                <li><a href="../modules/userController.html">userController</a></li>
                                <li><a href="../modules/userDialogController.html">userDialogController</a></li>
                                <li><a href="../modules/viewController.html">viewController</a></li>
                                <li><a href="../modules/visController.html">visController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: web\bower_components\angular-material\modules\closure\select\select.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.6
 */
goog.provide(&#x27;ng.material.components.select&#x27;);
goog.require(&#x27;ng.material.components.backdrop&#x27;);
goog.require(&#x27;ng.material.core&#x27;);
/**
 * @ngdoc module
 * @name material.components.select
 */

/***************************************************

 ### TODO - POST RC1 ###
 - [ ] Abstract placement logic in $mdSelect service to $mdMenu service

 ***************************************************/

var SELECT_EDGE_MARGIN = 8;
var selectNextId = 0;

angular.module(&#x27;material.components.select&#x27;, [
    &#x27;material.core&#x27;,
    &#x27;material.components.backdrop&#x27;
  ])
  .directive(&#x27;mdSelect&#x27;, SelectDirective)
  .directive(&#x27;mdSelectMenu&#x27;, SelectMenuDirective)
  .directive(&#x27;mdOption&#x27;, OptionDirective)
  .directive(&#x27;mdOptgroup&#x27;, OptgroupDirective)
  .provider(&#x27;$mdSelect&#x27;, SelectProvider);

/**
 * @ngdoc directive
 * @name mdSelect
 * @restrict E
 * @module material.components.select
 *
 * @description Displays a select box, bound to an ng-model.
 *
 * @param {expression} ng-model The model!
 * @param {boolean=} multiple Whether it&#x27;s multiple.
 * @param {expression=} md-on-close Expression to be evaluated when the select is closed.
 * @param {expression=} md-on-open Expression to be evaluated when opening the select.
 * Will hide the select options and show a spinner until the evaluated promise resolves.
 * @param {string=} placeholder Placeholder hint text.
 * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or
 * explicit label is present.
 * @param {string=} md-container-class Class list to get applied to the &#x60;.md-select-menu-container&#x60;
 * element (for custom styling).
 *
 * @usage
 * With a placeholder (label and aria-label are added dynamically)
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;md-input-container&gt;
 *     &lt;md-select
 *       ng-model=&quot;someModel&quot;
 *       placeholder=&quot;Select a state&quot;&gt;
 *       &lt;md-option ng-value=&quot;opt&quot; ng-repeat=&quot;opt in neighborhoods2&quot;&gt;{{ opt }}&lt;/md-option&gt;
 *     &lt;/md-select&gt;
 *   &lt;/md-input-container&gt;
 * &lt;/hljs&gt;
 *
 * With an explicit label
 * &lt;hljs lang=&quot;html&quot;&gt;
 *   &lt;md-input-container&gt;
 *     &lt;label&gt;State&lt;/label&gt;
 *     &lt;md-select
 *       ng-model=&quot;someModel&quot;&gt;
 *       &lt;md-option ng-value=&quot;opt&quot; ng-repeat=&quot;opt in neighborhoods2&quot;&gt;{{ opt }}&lt;/md-option&gt;
 *     &lt;/md-select&gt;
 *   &lt;/md-input-container&gt;
 * &lt;/hljs&gt;
 *
 * ## Selects and object equality
 * When using a &#x60;md-select&#x60; to pick from a list of objects, it is important to realize how javascript handles
 * equality. Consider the following example:
 * &lt;hljs lang=&quot;js&quot;&gt;
 * angular.controller(&#x27;MyCtrl&#x27;, function($scope) {
 *   $scope.users = [
 *     { id: 1, name: &#x27;Bob&#x27; },
 *     { id: 2, name: &#x27;Alice&#x27; },
 *     { id: 3, name: &#x27;Steve&#x27; }
 *   ];
 *   $scope.selectedUser = { id: 1, name: &#x27;Bob&#x27; };
 * });
 * &lt;/hljs&gt;
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;div ng-controller=&quot;MyCtrl&quot;&gt;
 *   &lt;md-select ng-model=&quot;selectedUser&quot;&gt;
 *     &lt;md-option ng-value=&quot;user&quot; ng-repeat=&quot;user in users&quot;&gt;{{ user.name }}&lt;/md-option&gt;
 *   &lt;/md-select&gt;
 * &lt;/div&gt;
 * &lt;/hljs&gt;
 *
 * At first one might expect that the select should be populated with &quot;Bob&quot; as the selected user. However,
 * this is not true. To determine whether something is selected, 
 * &#x60;ngModelController&#x60; is looking at whether &#x60;$scope.selectedUser == (any user in $scope.users);&#x60;;
 * 
 * Javascript&#x27;s &#x60;==&#x60; operator does not check for deep equality (ie. that all properties
 * on the object are the same), but instead whether the objects are *the same object in memory*.
 * In this case, we have two instances of identical objects, but they exist in memory as unique
 * entities. Because of this, the select will have no value populated for a selected user.
 *
 * To get around this, &#x60;ngModelController&#x60; provides a &#x60;track by&#x60; option that allows us to specify a different
 * expression which will be used for the equality operator. As such, we can update our &#x60;html&#x60; to
 * make use of this by specifying the &#x60;ng-model-options=&quot;{trackBy: &#x27;$value.id&#x27;}&quot;&#x60; on the &#x60;md-select&#x60;
 * element. This converts our equality expression to be 
 * &#x60;$scope.selectedUser.id == (any id in $scope.users.map(function(u) { return u.id; }));&#x60;
 * which results in Bob being selected as desired.
 *
 * Working HTML:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;div ng-controller=&quot;MyCtrl&quot;&gt;
 *   &lt;md-select ng-model=&quot;selectedUser&quot; ng-model-options=&quot;{trackBy: &#x27;$value.id&#x27;}&quot;&gt;
 *     &lt;md-option ng-value=&quot;user&quot; ng-repeat=&quot;user in users&quot;&gt;{{ user.name }}&lt;/md-option&gt;
 *   &lt;/md-select&gt;
 * &lt;/div&gt;
 * &lt;/hljs&gt;
 */
function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
  return {
    restrict: &#x27;E&#x27;,
    require: [&#x27;^?mdInputContainer&#x27;, &#x27;mdSelect&#x27;, &#x27;ngModel&#x27;, &#x27;?^form&#x27;],
    compile: compile,
    controller: function() {
    } // empty placeholder controller to be initialized in link
  };

  function compile(element, attr) {
    // add the select value that will hold our placeholder or selected option value
    var valueEl = angular.element(&#x27;&lt;md-select-value&gt;&lt;span&gt;&lt;/span&gt;&lt;/md-select-value&gt;&#x27;);
    valueEl.append(&#x27;&lt;span class=&quot;md-select-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;&#x27;);
    valueEl.addClass(&#x27;md-select-value&#x27;);
    if (!valueEl[0].hasAttribute(&#x27;id&#x27;)) {
      valueEl.attr(&#x27;id&#x27;, &#x27;select_value_label_&#x27; + $mdUtil.nextUid());
    }

    // There&#x27;s got to be an md-content inside. If there&#x27;s not one, let&#x27;s add it.
    if (!element.find(&#x27;md-content&#x27;).length) {
      element.append(angular.element(&#x27;&lt;md-content&gt;&#x27;).append(element.contents()));
    }


    // Add progress spinner for md-options-loading
    if (attr.mdOnOpen) {

      // Show progress indicator while loading async
      // Use ng-hide for &#x60;display:none&#x60; so the indicator does not interfere with the options list
      element
        .find(&#x27;md-content&#x27;)
        .prepend(angular.element(
          &#x27;&lt;div&gt;&#x27; +
          &#x27; &lt;md-progress-circular md-mode=&quot;{{progressMode}}&quot; ng-hide=&quot;$$loadingAsyncDone&quot;&gt;&lt;/md-progress-circular&gt;&#x27; +
          &#x27;&lt;/div&gt;&#x27;
        ));

      // Hide list [of item options] while loading async
      element
        .find(&#x27;md-option&#x27;)
        .attr(&#x27;ng-show&#x27;, &#x27;$$loadingAsyncDone&#x27;);
    }

    if (attr.name) {
      var autofillClone = angular.element(&#x27;&lt;select class=&quot;md-visually-hidden&quot;&gt;&#x27;);
      autofillClone.attr({
        &#x27;name&#x27;: &#x27;.&#x27; + attr.name,
        &#x27;ng-model&#x27;: attr.ngModel,
        &#x27;aria-hidden&#x27;: &#x27;true&#x27;,
        &#x27;tabindex&#x27;: &#x27;-1&#x27;
      });
      var opts = element.find(&#x27;md-option&#x27;);
      angular.forEach(opts, function(el) {
        var newEl = angular.element(&#x27;&lt;option&gt;&#x27; + el.innerHTML + &#x27;&lt;/option&gt;&#x27;);
        if (el.hasAttribute(&#x27;ng-value&#x27;)) newEl.attr(&#x27;ng-value&#x27;, el.getAttribute(&#x27;ng-value&#x27;));
        else if (el.hasAttribute(&#x27;value&#x27;)) newEl.attr(&#x27;value&#x27;, el.getAttribute(&#x27;value&#x27;));
        autofillClone.append(newEl);
      });

      element.parent().append(autofillClone);
    }

    // Use everything that&#x27;s left inside element.contents() as the contents of the menu
    var multiple = angular.isDefined(attr.multiple) ? &#x27;multiple&#x27; : &#x27;&#x27;;
    var selectTemplate = &#x27;&#x27; +
      &#x27;&lt;div class=&quot;md-select-menu-container&quot; aria-hidden=&quot;true&quot;&gt;&#x27; +
      &#x27;&lt;md-select-menu {0}&gt;{1}&lt;/md-select-menu&gt;&#x27; +
      &#x27;&lt;/div&gt;&#x27;;

    selectTemplate = $mdUtil.supplant(selectTemplate, [multiple, element.html()]);
    element.empty().append(valueEl);
    element.append(selectTemplate);

    attr.tabindex = attr.tabindex || &#x27;0&#x27;;

    return function postLink(scope, element, attr, ctrls) {
      var untouched = true;
      var isDisabled, ariaLabelBase;

      var containerCtrl = ctrls[0];
      var mdSelectCtrl = ctrls[1];
      var ngModelCtrl = ctrls[2];
      var formCtrl = ctrls[3];
      // grab a reference to the select menu value label
      var valueEl = element.find(&#x27;md-select-value&#x27;);
      var isReadonly = angular.isDefined(attr.readonly);

      if (containerCtrl) {
        var isErrorGetter = containerCtrl.isErrorGetter || function() {
            return ngModelCtrl.$invalid &amp;&amp; ngModelCtrl.$touched;
          };

        if (containerCtrl.input) {
          throw new Error(&quot;&lt;md-input-container&gt; can only have *one* child &lt;input&gt;, &lt;textarea&gt; or &lt;select&gt; element!&quot;);
        }

        containerCtrl.input = element;
        if (!containerCtrl.label) {
          $mdAria.expect(element, &#x27;aria-label&#x27;, element.attr(&#x27;placeholder&#x27;));
        }

        scope.$watch(isErrorGetter, containerCtrl.setInvalid);
      }

      var selectContainer, selectScope, selectMenuCtrl;

      findSelectContainer();
      $mdTheming(element);

      if (attr.name &amp;&amp; formCtrl) {
        var selectEl = element.parent()[0].querySelector(&#x27;select[name=&quot;.&#x27; + attr.name + &#x27;&quot;]&#x27;);
        $mdUtil.nextTick(function() {
          var controller = angular.element(selectEl).controller(&#x27;ngModel&#x27;);
          if (controller) {
            formCtrl.$removeControl(controller);
          }
        });
      }

      if (formCtrl &amp;&amp; angular.isDefined(attr.multiple)) {
        $mdUtil.nextTick(function() {
          var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
          if (hasModelValue) {
            formCtrl.$setPristine();
          }
        });
      }

      var originalRender = ngModelCtrl.$render;
      ngModelCtrl.$render = function() {
        originalRender();
        syncLabelText();
        syncAriaLabel();
        inputCheckValue();
      };


      attr.$observe(&#x27;placeholder&#x27;, ngModelCtrl.$render);


      mdSelectCtrl.setLabelText = function(text) {
        mdSelectCtrl.setIsPlaceholder(!text);
        // Use placeholder attribute, otherwise fallback to the md-input-container label
        var tmpPlaceholder = attr.placeholder || (containerCtrl &amp;&amp; containerCtrl.label ? containerCtrl.label.text() : &#x27;&#x27;);
        text = text || tmpPlaceholder || &#x27;&#x27;;
        var target = valueEl.children().eq(0);
        target.html(text);
      };

      mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
        if (isPlaceholder) {
          valueEl.addClass(&#x27;md-select-placeholder&#x27;);
          if (containerCtrl &amp;&amp; containerCtrl.label) {
            containerCtrl.label.addClass(&#x27;md-placeholder&#x27;);
          }
        } else {
          valueEl.removeClass(&#x27;md-select-placeholder&#x27;);
          if (containerCtrl &amp;&amp; containerCtrl.label) {
            containerCtrl.label.removeClass(&#x27;md-placeholder&#x27;);
          }
        }
      };

      if (!isReadonly) {
        element
          .on(&#x27;focus&#x27;, function(ev) {
            // only set focus on if we don&#x27;t currently have a selected value. This avoids the &quot;bounce&quot;
            // on the label transition because the focus will immediately switch to the open menu.
            if (containerCtrl &amp;&amp; containerCtrl.element.hasClass(&#x27;md-input-has-value&#x27;)) {
              containerCtrl.setFocused(true);
            }
          });

        // Wait until postDigest so that we attach after ngModel&#x27;s 
        // blur listener so we can set untouched.
        $mdUtil.nextTick(function () {
          element.on(&#x27;blur&#x27;, function() {
            if (untouched) {
              untouched = false;
              ngModelCtrl.$setUntouched();
            }

            if (selectScope.isOpen) return;
            containerCtrl &amp;&amp; containerCtrl.setFocused(false);
            inputCheckValue();
          });
        });
      }

      mdSelectCtrl.triggerClose = function() {
        $parse(attr.mdOnClose)(scope);
      };

      scope.$$postDigest(function() {
        initAriaLabel();
        syncLabelText();
        syncAriaLabel();
      });

      function initAriaLabel() {
        var labelText = element.attr(&#x27;aria-label&#x27;) || element.attr(&#x27;placeholder&#x27;);
        if (!labelText &amp;&amp; containerCtrl &amp;&amp; containerCtrl.label) {
          labelText = containerCtrl.label.text();
        }
        ariaLabelBase = labelText;
        $mdAria.expect(element, &#x27;aria-label&#x27;, labelText);
      }

      scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);

      function syncLabelText() {
        if (selectContainer) {
          selectMenuCtrl = selectMenuCtrl || selectContainer.find(&#x27;md-select-menu&#x27;).controller(&#x27;mdSelectMenu&#x27;);
          mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
        }
      }

      function syncAriaLabel() {
        if (!ariaLabelBase) return;
        var ariaLabels = selectMenuCtrl.selectedLabels({mode: &#x27;aria&#x27;});
        element.attr(&#x27;aria-label&#x27;, ariaLabels.length ? ariaLabelBase + &#x27;: &#x27; + ariaLabels : ariaLabelBase);
      }

      var deregisterWatcher;
      attr.$observe(&#x27;ngMultiple&#x27;, function(val) {
        if (deregisterWatcher) deregisterWatcher();
        var parser = $parse(val);
        deregisterWatcher = scope.$watch(function() {
          return parser(scope);
        }, function(multiple, prevVal) {
          if (multiple === undefined &amp;&amp; prevVal === undefined) return; // assume compiler did a good job
          if (multiple) {
            element.attr(&#x27;multiple&#x27;, &#x27;multiple&#x27;);
          } else {
            element.removeAttr(&#x27;multiple&#x27;);
          }
          element.attr(&#x27;aria-multiselectable&#x27;, multiple ? &#x27;true&#x27; : &#x27;false&#x27;);
          if (selectContainer) {
            selectMenuCtrl.setMultiple(multiple);
            originalRender = ngModelCtrl.$render;
            ngModelCtrl.$render = function() {
              originalRender();
              syncLabelText();
              syncAriaLabel();
              inputCheckValue();
            };
            ngModelCtrl.$render();
          }
        });
      });

      attr.$observe(&#x27;disabled&#x27;, function(disabled) {
        if (angular.isString(disabled)) {
          disabled = true;
        }
        // Prevent click event being registered twice
        if (isDisabled !== undefined &amp;&amp; isDisabled === disabled) {
          return;
        }
        isDisabled = disabled;
        if (disabled) {
          element.attr({&#x27;tabindex&#x27;: -1, &#x27;aria-disabled&#x27;: &#x27;true&#x27;});
          element.off(&#x27;click&#x27;, openSelect);
          element.off(&#x27;keydown&#x27;, handleKeypress);
        } else {
          element.attr({&#x27;tabindex&#x27;: attr.tabindex, &#x27;aria-disabled&#x27;: &#x27;false&#x27;});
          element.on(&#x27;click&#x27;, openSelect);
          element.on(&#x27;keydown&#x27;, handleKeypress);
        }
      });

      if (!attr.disabled &amp;&amp; !attr.ngDisabled) {
        element.attr({&#x27;tabindex&#x27;: attr.tabindex, &#x27;aria-disabled&#x27;: &#x27;false&#x27;});
        element.on(&#x27;click&#x27;, openSelect);
        element.on(&#x27;keydown&#x27;, handleKeypress);
      }


      var ariaAttrs = {
        role: &#x27;listbox&#x27;,
        &#x27;aria-expanded&#x27;: &#x27;false&#x27;,
        &#x27;aria-multiselectable&#x27;: attr.multiple !== undefined &amp;&amp; !attr.ngMultiple ? &#x27;true&#x27; : &#x27;false&#x27;
      };

      if (!element[0].hasAttribute(&#x27;id&#x27;)) {
        ariaAttrs.id = &#x27;select_&#x27; + $mdUtil.nextUid();
      }

      var containerId = &#x27;select_container_&#x27; + $mdUtil.nextUid();
      selectContainer.attr(&#x27;id&#x27;, containerId);
      ariaAttrs[&#x27;aria-owns&#x27;] = containerId;
      element.attr(ariaAttrs);

      scope.$on(&#x27;$destroy&#x27;, function() {
        $mdSelect
          .destroy()
          .finally(function() {
            if (containerCtrl) {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            }
            ngModelCtrl.$setTouched();
          });
      });



      function inputCheckValue() {
        // The select counts as having a value if one or more options are selected,
        // or if the input&#x27;s validity state says it has bad input (eg string in a number input)
        containerCtrl &amp;&amp; containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length &gt; 0 || (element[0].validity || {}).badInput);
      }

      function findSelectContainer() {
        selectContainer = angular.element(
          element[0].querySelector(&#x27;.md-select-menu-container&#x27;)
        );
        selectScope = scope;
        if (attr.mdContainerClass) {
          var value = selectContainer[0].getAttribute(&#x27;class&#x27;) + &#x27; &#x27; + attr.mdContainerClass;
          selectContainer[0].setAttribute(&#x27;class&#x27;, value);
        }
        selectMenuCtrl = selectContainer.find(&#x27;md-select-menu&#x27;).controller(&#x27;mdSelectMenu&#x27;);
        selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
        element.on(&#x27;$destroy&#x27;, function() {
          selectContainer.remove();
        });
      }

      function handleKeypress(e) {
        var allowedCodes = [32, 13, 38, 40];
        if (allowedCodes.indexOf(e.keyCode) != -1) {
          // prevent page scrolling on interaction
          e.preventDefault();
          openSelect(e);
        } else {
          if (e.keyCode &lt;= 90 &amp;&amp; e.keyCode &gt;= 31) {
            e.preventDefault();
            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
            if (!node) return;
            var optionCtrl = angular.element(node).controller(&#x27;mdOption&#x27;);
            if (!selectMenuCtrl.isMultiple) {
              selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
            }
            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
            selectMenuCtrl.refreshViewValue();
          }
        }
      }

      function openSelect() {
        selectScope.isOpen = true;
        element.attr(&#x27;aria-expanded&#x27;, &#x27;true&#x27;);

        $mdSelect.show({
          scope: selectScope,
          preserveScope: true,
          skipCompile: true,
          element: selectContainer,
          target: element[0],
          selectCtrl: mdSelectCtrl,
          preserveElement: true,
          hasBackdrop: true,
          loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
        }).finally(function() {
          selectScope.isOpen = false;
          element.focus();
          element.attr(&#x27;aria-expanded&#x27;, &#x27;false&#x27;);
          ngModelCtrl.$setTouched();
        });
      }
    };
  }
}
SelectDirective.$inject = [&quot;$mdSelect&quot;, &quot;$mdUtil&quot;, &quot;$mdTheming&quot;, &quot;$mdAria&quot;, &quot;$compile&quot;, &quot;$parse&quot;];

function SelectMenuDirective($parse, $mdUtil, $mdTheming) {

  SelectMenuController.$inject = [&quot;$scope&quot;, &quot;$attrs&quot;, &quot;$element&quot;];
  return {
    restrict: &#x27;E&#x27;,
    require: [&#x27;mdSelectMenu&#x27;],
    scope: true,
    controller: SelectMenuController,
    link: {pre: preLink}
  };

  // We use preLink instead of postLink to ensure that the select is initialized before
  // its child options run postLink.
  function preLink(scope, element, attr, ctrls) {
    var selectCtrl = ctrls[0];

    $mdTheming(element);
    element.on(&#x27;click&#x27;, clickListener);
    element.on(&#x27;keypress&#x27;, keyListener);

    function keyListener(e) {
      if (e.keyCode == 13 || e.keyCode == 32) {
        clickListener(e);
      }
    }

    function clickListener(ev) {
      var option = $mdUtil.getClosest(ev.target, &#x27;md-option&#x27;);
      var optionCtrl = option &amp;&amp; angular.element(option).data(&#x27;$mdOptionController&#x27;);
      if (!option || !optionCtrl) return;
      if (option.hasAttribute(&#x27;disabled&#x27;)) {
        ev.stopImmediatePropagation();
        return false;
      }

      var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
      var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);

      scope.$apply(function() {
        if (selectCtrl.isMultiple) {
          if (isSelected) {
            selectCtrl.deselect(optionHashKey);
          } else {
            selectCtrl.select(optionHashKey, optionCtrl.value);
          }
        } else {
          if (!isSelected) {
            selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
            selectCtrl.select(optionHashKey, optionCtrl.value);
          }
        }
        selectCtrl.refreshViewValue();
      });
    }
  }

  function SelectMenuController($scope, $attrs, $element) {
    var self = this;
    self.isMultiple = angular.isDefined($attrs.multiple);
    // selected is an object with keys matching all of the selected options&#x27; hashed values
    self.selected = {};
    // options is an object with keys matching every option&#x27;s hash value,
    // and values matching every option&#x27;s controller.
    self.options = {};

    $scope.$watchCollection(function() {
      return self.options;
    }, function() {
      self.ngModel.$render();
    });

    var deregisterCollectionWatch;
    var defaultIsEmpty;
    self.setMultiple = function(isMultiple) {
      var ngModel = self.ngModel;
      defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;

      self.isMultiple = isMultiple;
      if (deregisterCollectionWatch) deregisterCollectionWatch();

      if (self.isMultiple) {
        ngModel.$validators[&#x27;md-multiple&#x27;] = validateArray;
        ngModel.$render = renderMultiple;

        // watchCollection on the model because by default ngModel only watches the model&#x27;s
        // reference. This allowed the developer to also push and pop from their array.
        $scope.$watchCollection(self.modelBinding, function(value) {
          if (validateArray(value)) renderMultiple(value);
          self.ngModel.$setPristine();
        });

        ngModel.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      } else {
        delete ngModel.$validators[&#x27;md-multiple&#x27;];
        ngModel.$render = renderSingular;
      }

      function validateArray(modelValue, viewValue) {
        // If a value is truthy but not an array, reject it.
        // If value is undefined/falsy, accept that it&#x27;s an empty array.
        return angular.isArray(modelValue || viewValue || []);
      }
    };

    var searchStr = &#x27;&#x27;;
    var clearSearchTimeout, optNodes, optText;
    var CLEAR_SEARCH_AFTER = 300;
    self.optNodeForKeyboardSearch = function(e) {
      clearSearchTimeout &amp;&amp; clearTimeout(clearSearchTimeout);
      clearSearchTimeout = setTimeout(function() {
        clearSearchTimeout = undefined;
        searchStr = &#x27;&#x27;;
        optText = undefined;
        optNodes = undefined;
      }, CLEAR_SEARCH_AFTER);
      searchStr += String.fromCharCode(e.keyCode);
      var search = new RegExp(&#x27;^&#x27; + searchStr, &#x27;i&#x27;);
      if (!optNodes) {
        optNodes = $element.find(&#x27;md-option&#x27;);
        optText = new Array(optNodes.length);
        angular.forEach(optNodes, function(el, i) {
          optText[i] = el.textContent.trim();
        });
      }
      for (var i = 0; i &lt; optText.length; ++i) {
        if (search.test(optText[i])) {
          return optNodes[i];
        }
      }
    };

    self.init = function(ngModel, binding) {
      self.ngModel = ngModel;
      self.modelBinding = binding;

      // Allow users to provide &#x60;ng-model=&quot;foo&quot; ng-model-options=&quot;{trackBy: &#x27;foo.id&#x27;}&quot;&#x60; so
      // that we can properly compare objects set on the model to the available options
      if (ngModel.$options &amp;&amp; ngModel.$options.trackBy) {
        var trackByLocals = {};
        var trackByParsed = $parse(ngModel.$options.trackBy);
        self.hashGetter = function(value, valueScope) {
          trackByLocals.$value = value;
          return trackByParsed(valueScope || $scope, trackByLocals);
        };
        // If the user doesn&#x27;t provide a trackBy, we automatically generate an id for every
        // value passed in
      } else {
        self.hashGetter = function getHashValue(value) {
          if (angular.isObject(value)) {
            return &#x27;object_&#x27; + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
          }
          return value;
        };
      }
      self.setMultiple(self.isMultiple);
    };

    self.selectedLabels = function(opts) {
      opts = opts || {};
      var mode = opts.mode || &#x27;html&#x27;;
      var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll(&#x27;md-option[selected]&#x27;));
      if (selectedOptionEls.length) {
        var mapFn;

        if (mode == &#x27;html&#x27;) {
          // Map the given element to its innerHTML string. If the element has a child ripple
          // container remove it from the HTML string, before returning the string.
          mapFn = function(el) {
            var html = el.innerHTML;
            // Remove the ripple container from the selected option, copying it would cause a CSP violation.
            var rippleContainer = el.querySelector(&#x27;.md-ripple-container&#x27;);
            return rippleContainer ? html.replace(rippleContainer.outerHTML, &#x27;&#x27;) : html;
          };
        } else if (mode == &#x27;aria&#x27;) {
          mapFn = function(el) { return el.hasAttribute(&#x27;aria-label&#x27;) ? el.getAttribute(&#x27;aria-label&#x27;) : el.textContent; };
        }
        return selectedOptionEls.map(mapFn).join(&#x27;, &#x27;);
      } else {
        return &#x27;&#x27;;
      }
    };

    self.select = function(hashKey, hashedValue) {
      var option = self.options[hashKey];
      option &amp;&amp; option.setSelected(true);
      self.selected[hashKey] = hashedValue;
    };
    self.deselect = function(hashKey) {
      var option = self.options[hashKey];
      option &amp;&amp; option.setSelected(false);
      delete self.selected[hashKey];
    };

    self.addOption = function(hashKey, optionCtrl) {
      if (angular.isDefined(self.options[hashKey])) {
        throw new Error(&#x27;Duplicate md-option values are not allowed in a select. &#x27; +
          &#x27;Duplicate value &quot;&#x27; + optionCtrl.value + &#x27;&quot; found.&#x27;);
      }
      self.options[hashKey] = optionCtrl;

      // If this option&#x27;s value was already in our ngModel, go ahead and select it.
      if (angular.isDefined(self.selected[hashKey])) {
        self.select(hashKey, optionCtrl.value);
        self.refreshViewValue();
      }
    };
    self.removeOption = function(hashKey) {
      delete self.options[hashKey];
      // Don&#x27;t deselect an option when it&#x27;s removed - the user&#x27;s ngModel should be allowed
      // to have values that do not match a currently available option.
    };

    self.refreshViewValue = function() {
      var values = [];
      var option;
      for (var hashKey in self.selected) {
        // If this hashKey has an associated option, push that option&#x27;s value to the model.
        if ((option = self.options[hashKey])) {
          values.push(option.value);
        } else {
          // Otherwise, the given hashKey has no associated option, and we got it
          // from an ngModel value at an earlier time. Push the unhashed value of
          // this hashKey to the model.
          // This allows the developer to put a value in the model that doesn&#x27;t yet have
          // an associated option.
          values.push(self.selected[hashKey]);
        }
      }
      var usingTrackBy = self.ngModel.$options &amp;&amp; self.ngModel.$options.trackBy;

      var newVal = self.isMultiple ? values : values[0];
      var prevVal = self.ngModel.$modelValue;

      if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
        self.ngModel.$setViewValue(newVal);
        self.ngModel.$render();
      }
    };

    function renderMultiple() {
      var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
      if (!angular.isArray(newSelectedValues)) return;

      var oldSelected = Object.keys(self.selected);

      var newSelectedHashes = newSelectedValues.map(self.hashGetter);
      var deselected = oldSelected.filter(function(hash) {
        return newSelectedHashes.indexOf(hash) === -1;
      });

      deselected.forEach(self.deselect);
      newSelectedHashes.forEach(function(hashKey, i) {
        self.select(hashKey, newSelectedValues[i]);
      });
    }

    function renderSingular() {
      var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
      Object.keys(self.selected).forEach(self.deselect);
      self.select(self.hashGetter(value), value);
    }
  }

}
SelectMenuDirective.$inject = [&quot;$parse&quot;, &quot;$mdUtil&quot;, &quot;$mdTheming&quot;];

function OptionDirective($mdButtonInkRipple, $mdUtil) {

  OptionController.$inject = [&quot;$element&quot;];
  return {
    restrict: &#x27;E&#x27;,
    require: [&#x27;mdOption&#x27;, &#x27;^^mdSelectMenu&#x27;],
    controller: OptionController,
    compile: compile
  };

  function compile(element, attr) {
    // Manual transclusion to avoid the extra inner &lt;span&gt; that ng-transclude generates
    element.append(angular.element(&#x27;&lt;div class=&quot;md-text&quot;&gt;&#x27;).append(element.contents()));

    element.attr(&#x27;tabindex&#x27;, attr.tabindex || &#x27;0&#x27;);
    return postLink;
  }

  function postLink(scope, element, attr, ctrls) {
    var optionCtrl = ctrls[0];
    var selectCtrl = ctrls[1];

    if (angular.isDefined(attr.ngValue)) {
      scope.$watch(attr.ngValue, setOptionValue);
    } else if (angular.isDefined(attr.value)) {
      setOptionValue(attr.value);
    } else {
      scope.$watch(function() {
        return element.text().trim();
      }, setOptionValue);
    }

    attr.$observe(&#x27;disabled&#x27;, function(disabled) {
      if (disabled) {
        element.attr(&#x27;tabindex&#x27;, &#x27;-1&#x27;);
      } else {
        element.attr(&#x27;tabindex&#x27;, &#x27;0&#x27;);
      }
    });

    scope.$$postDigest(function() {
      attr.$observe(&#x27;selected&#x27;, function(selected) {
        if (!angular.isDefined(selected)) return;
        if (typeof selected == &#x27;string&#x27;) selected = true;
        if (selected) {
          if (!selectCtrl.isMultiple) {
            selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
          }
          selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
        } else {
          selectCtrl.deselect(optionCtrl.hashKey);
        }
        selectCtrl.refreshViewValue();
      });
    });

    $mdButtonInkRipple.attach(scope, element);
    configureAria();

    function setOptionValue(newValue, oldValue, prevAttempt) {
      if (!selectCtrl.hashGetter) {
        if (!prevAttempt) {
          scope.$$postDigest(function() {
            setOptionValue(newValue, oldValue, true);
          });
        }
        return;
      }
      var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
      var newHashKey = selectCtrl.hashGetter(newValue, scope);

      optionCtrl.hashKey = newHashKey;
      optionCtrl.value = newValue;

      selectCtrl.removeOption(oldHashKey, optionCtrl);
      selectCtrl.addOption(newHashKey, optionCtrl);
    }

    scope.$on(&#x27;$destroy&#x27;, function() {
      selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
    });

    function configureAria() {
      var ariaAttrs = {
        &#x27;role&#x27;: &#x27;option&#x27;,
        &#x27;aria-selected&#x27;: &#x27;false&#x27;
      };

      if (!element[0].hasAttribute(&#x27;id&#x27;)) {
        ariaAttrs.id = &#x27;select_option_&#x27; + $mdUtil.nextUid();
      }
      element.attr(ariaAttrs);
    }
  }

  function OptionController($element) {
    this.selected = false;
    this.setSelected = function(isSelected) {
      if (isSelected &amp;&amp; !this.selected) {
        $element.attr({
          &#x27;selected&#x27;: &#x27;selected&#x27;,
          &#x27;aria-selected&#x27;: &#x27;true&#x27;
        });
      } else if (!isSelected &amp;&amp; this.selected) {
        $element.removeAttr(&#x27;selected&#x27;);
        $element.attr(&#x27;aria-selected&#x27;, &#x27;false&#x27;);
      }
      this.selected = isSelected;
    };
  }

}
OptionDirective.$inject = [&quot;$mdButtonInkRipple&quot;, &quot;$mdUtil&quot;];

function OptgroupDirective() {
  return {
    restrict: &#x27;E&#x27;,
    compile: compile
  };
  function compile(el, attrs) {
    var labelElement = el.find(&#x27;label&#x27;);
    if (!labelElement.length) {
      labelElement = angular.element(&#x27;&lt;label&gt;&#x27;);
      el.prepend(labelElement);
    }
    labelElement.addClass(&#x27;md-container-ignore&#x27;);
    if (attrs.label) labelElement.text(attrs.label);
  }
}

function SelectProvider($$interimElementProvider) {
  selectDefaultOptions.$inject = [&quot;$mdSelect&quot;, &quot;$mdConstant&quot;, &quot;$mdUtil&quot;, &quot;$window&quot;, &quot;$q&quot;, &quot;$$rAF&quot;, &quot;$animateCss&quot;, &quot;$animate&quot;, &quot;$document&quot;];
  return $$interimElementProvider(&#x27;$mdSelect&#x27;)
    .setDefaults({
      methods: [&#x27;target&#x27;],
      options: selectDefaultOptions
    });

  /* ngInject */
  function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
    var ERRROR_TARGET_EXPECTED = &quot;$mdSelect.show() expected a target element in options.target but got &#x27;{0}&#x27;!&quot;;
    var animator = $mdUtil.dom.animator;

    return {
      parent: &#x27;body&#x27;,
      themable: true,
      onShow: onShow,
      onRemove: onRemove,
      hasBackdrop: true,
      disableParentScroll: true
    };

    /**
     * Interim-element onRemove logic....
     */
    function onRemove(scope, element, opts) {
      opts = opts || { };
      opts.cleanupInteraction();
      opts.cleanupResizing();
      opts.hideBackdrop();

      // For navigation $destroy events, do a quick, non-animated removal,
      // but for normal closes (from clicks, etc) animate the removal

      return  (opts.$destroy === true) ? cleanElement() : animateRemoval().then( cleanElement );

      /**
       * For normal closes (eg clicks), animate the removal.
       * For forced closes (like $destroy events from navigation),
       * skip the animations
       */
      function animateRemoval() {
        return $animateCss(element, {addClass: &#x27;md-leave&#x27;}).start();
      }

      /**
       * Restore the element to a closed state
       */
      function cleanElement() {

        element.removeClass(&#x27;md-active&#x27;);
        element.attr(&#x27;aria-hidden&#x27;, &#x27;true&#x27;);
        element[0].style.display = &#x27;none&#x27;;

        announceClosed(opts);

        if (!opts.$destroy &amp;&amp; opts.restoreFocus) {
          opts.target.focus();
        }
      }

    }

    /**
     * Interim-element onShow logic....
     */
    function onShow(scope, element, opts) {

      watchAsyncLoad();
      sanitizeAndConfigure(scope, opts);

      opts.hideBackdrop = showBackdrop(scope, element, opts);

      return showDropDown(scope, element, opts)
        .then(function(response) {
          element.attr(&#x27;aria-hidden&#x27;, &#x27;false&#x27;);
          opts.alreadyOpen = true;
          opts.cleanupInteraction = activateInteraction();
          opts.cleanupResizing = activateResizing();

          return response;
        }, opts.hideBackdrop);

      // ************************************
      // Closure Functions
      // ************************************

      /**
       *  Attach the select DOM element(s) and animate to the correct positions
       *  and scalings...
       */
      function showDropDown(scope, element, opts) {
        opts.parent.append(element);

        return $q(function(resolve, reject) {

          try {

            $animateCss(element, {removeClass: &#x27;md-leave&#x27;, duration: 0})
              .start()
              .then(positionAndFocusMenu)
              .then(resolve);

          } catch (e) {
            reject(e);
          }

        });
      }

      /**
       * Initialize container and dropDown menu positions/scale, then animate
       * to show... and autoFocus.
       */
      function positionAndFocusMenu() {
        return $q(function(resolve) {
          if (opts.isRemoved) return $q.reject(false);

          var info = calculateMenuPositions(scope, element, opts);

          info.container.element.css(animator.toCss(info.container.styles));
          info.dropDown.element.css(animator.toCss(info.dropDown.styles));

          $$rAF(function() {
            element.addClass(&#x27;md-active&#x27;);
            info.dropDown.element.css(animator.toCss({transform: &#x27;&#x27;}));

            autoFocus(opts.focusedNode);
            resolve();
          });

        });
      }

      /**
       * Show modal backdrop element...
       */
      function showBackdrop(scope, element, options) {

        // If we are not within a dialog...
        if (options.disableParentScroll &amp;&amp; !$mdUtil.getClosest(options.target, &#x27;MD-DIALOG&#x27;)) {
          // !! DO this before creating the backdrop; since disableScrollAround()
          //    configures the scroll offset; which is used by mdBackDrop postLink()
          options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
        } else {
          options.disableParentScroll = false;
        }

        if (options.hasBackdrop) {
          // Override duration to immediately show invisible backdrop
          options.backdrop = $mdUtil.createBackdrop(scope, &quot;md-select-backdrop md-click-catcher&quot;);
          $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
        }

        /**
         * Hide modal backdrop element...
         */
        return function hideBackdrop() {
          if (options.backdrop) options.backdrop.remove();
          if (options.disableParentScroll) options.restoreScroll();

          delete options.restoreScroll;
        };
      }

      /**
       *
       */
      function autoFocus(focusedNode) {
        if (focusedNode &amp;&amp; !focusedNode.hasAttribute(&#x27;disabled&#x27;)) {
          focusedNode.focus();
        }
      }

      /**
       * Check for valid opts and set some sane defaults
       */
      function sanitizeAndConfigure(scope, options) {
        var selectEl = element.find(&#x27;md-select-menu&#x27;);

        if (!options.target) {
          throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [options.target]));
        }

        angular.extend(options, {
          isRemoved: false,
          target: angular.element(options.target), //make sure it&#x27;s not a naked dom node
          parent: angular.element(options.parent),
          selectEl: selectEl,
          contentEl: element.find(&#x27;md-content&#x27;),
          optionNodes: selectEl[0].getElementsByTagName(&#x27;md-option&#x27;)
        });
      }

      /**
       * Configure various resize listeners for screen changes
       */
      function activateResizing() {
        var debouncedOnResize = (function(scope, target, options) {

          return function() {
            if (options.isRemoved) return;

            var updates = calculateMenuPositions(scope, target, options);
            var container = updates.container;
            var dropDown = updates.dropDown;

            container.element.css(animator.toCss(container.styles));
            dropDown.element.css(animator.toCss(dropDown.styles));
          };

        })(scope, element, opts);

        var window = angular.element($window);
        window.on(&#x27;resize&#x27;, debouncedOnResize);
        window.on(&#x27;orientationchange&#x27;, debouncedOnResize);

        // Publish deactivation closure...
        return function deactivateResizing() {

          // Disable resizing handlers
          window.off(&#x27;resize&#x27;, debouncedOnResize);
          window.off(&#x27;orientationchange&#x27;, debouncedOnResize);
        };
      }

      /**
       *  If asynchronously loading, watch and update internal
       *  &#x27;$$loadingAsyncDone&#x27; flag
       */
      function watchAsyncLoad() {
        if (opts.loadingAsync &amp;&amp; !opts.isRemoved) {
          scope.$$loadingAsyncDone = false;
          scope.progressMode = &#x27;indeterminate&#x27;;

          $q.when(opts.loadingAsync)
            .then(function() {
              scope.$$loadingAsyncDone = true;
              scope.progressMode = &#x27;&#x27;;
              delete opts.loadingAsync;
            }).then(function() {
              $$rAF(positionAndFocusMenu);
            });
        }
      }

      /**
       *
       */
      function activateInteraction() {
        if (opts.isRemoved) return;

        var dropDown = opts.selectEl;
        var selectCtrl = dropDown.controller(&#x27;mdSelectMenu&#x27;) || {};

        element.addClass(&#x27;md-clickable&#x27;);

        // Close on backdrop click
        opts.backdrop &amp;&amp; opts.backdrop.on(&#x27;click&#x27;, onBackdropClick);

        // Escape to close
        // Cycling of options, and closing on enter
        dropDown.on(&#x27;keydown&#x27;, onMenuKeyDown);
        dropDown.on(&#x27;click&#x27;, checkCloseMenu);

        return function cleanupInteraction() {
          opts.backdrop &amp;&amp; opts.backdrop.off(&#x27;click&#x27;, onBackdropClick);
          dropDown.off(&#x27;keydown&#x27;, onMenuKeyDown);
          dropDown.off(&#x27;click&#x27;, checkCloseMenu);

          element.removeClass(&#x27;md-clickable&#x27;);
          opts.isRemoved = true;
        };

        // ************************************
        // Closure Functions
        // ************************************

        function onBackdropClick(e) {
          e.preventDefault();
          e.stopPropagation();
          opts.restoreFocus = false;
          $mdUtil.nextTick($mdSelect.hide, true);
        }

        function onMenuKeyDown(ev) {
          var keyCodes = $mdConstant.KEY_CODE;
          ev.preventDefault();
          ev.stopPropagation();

          switch (ev.keyCode) {
            case keyCodes.UP_ARROW:
              return focusPrevOption();
            case keyCodes.DOWN_ARROW:
              return focusNextOption();
            case keyCodes.SPACE:
            case keyCodes.ENTER:
              var option = $mdUtil.getClosest(ev.target, &#x27;md-option&#x27;);
              if (option) {
                dropDown.triggerHandler({
                  type: &#x27;click&#x27;,
                  target: option
                });
                ev.preventDefault();
              }
              checkCloseMenu(ev);
              break;
            case keyCodes.TAB:
            case keyCodes.ESCAPE:
              ev.stopPropagation();
              ev.preventDefault();
              opts.restoreFocus = true;
              $mdUtil.nextTick($mdSelect.hide, true);
              break;
            default:
              if (ev.keyCode &gt;= 31 &amp;&amp; ev.keyCode &lt;= 90) {
                var optNode = dropDown.controller(&#x27;mdSelectMenu&#x27;).optNodeForKeyboardSearch(ev);
                opts.focusedNode = optNode || opts.focusedNode;
                optNode &amp;&amp; optNode.focus();
              }
          }
        }

        function focusOption(direction) {
          var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
          var index = optionsArray.indexOf(opts.focusedNode);

          var newOption;

          do {
            if (index === -1) {
              // We lost the previously focused element, reset to first option
              index = 0;
            } else if (direction === &#x27;next&#x27; &amp;&amp; index &lt; optionsArray.length - 1) {
              index++;
            } else if (direction === &#x27;prev&#x27; &amp;&amp; index &gt; 0) {
              index--;
            }
            newOption = optionsArray[index];
            if (newOption.hasAttribute(&#x27;disabled&#x27;)) newOption = undefined;
          } while (!newOption &amp;&amp; index &lt; optionsArray.length - 1 &amp;&amp; index &gt; 0)
          newOption &amp;&amp; newOption.focus();
          opts.focusedNode = newOption;
        }

        function focusNextOption() {
          focusOption(&#x27;next&#x27;);
        }

        function focusPrevOption() {
          focusOption(&#x27;prev&#x27;);
        }

        function checkCloseMenu(ev) {
          if (ev &amp;&amp; ( ev.type == &#x27;click&#x27;) &amp;&amp; (ev.currentTarget != dropDown[0])) return;
          if ( mouseOnScrollbar() ) return;

          var option = $mdUtil.getClosest(ev.target, &#x27;md-option&#x27;);
          if (option &amp;&amp; option.hasAttribute &amp;&amp; !option.hasAttribute(&#x27;disabled&#x27;)) {
            ev.preventDefault();
            ev.stopPropagation();
            if (!selectCtrl.isMultiple) {
              opts.restoreFocus = true;

              $mdUtil.nextTick(function () {
                $mdSelect.hide(selectCtrl.ngModel.$viewValue);
              }, true);
            }
          }
          /**
           * check if the mouseup event was on a scrollbar
           */
          function mouseOnScrollbar() {
            var clickOnScrollbar = false;
            if (ev &amp;&amp; (ev.currentTarget.children.length &gt; 0)) {
              var child = ev.currentTarget.children[0];
              var hasScrollbar = child.scrollHeight &gt; child.clientHeight;
              if (hasScrollbar &amp;&amp; child.children.length &gt; 0) {
                var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                if (relPosX &gt; child.querySelector(&#x27;md-option&#x27;).offsetWidth)
                  clickOnScrollbar = true;
              }
            }
            return clickOnScrollbar;
          }
        }
      }

    }

    /**
     * To notify listeners that the Select menu has closed,
     * trigger the [optional] user-defined expression
     */
    function announceClosed(opts) {
      var mdSelect = opts.selectCtrl;
      if (mdSelect) {
        var menuController = opts.selectEl.controller(&#x27;mdSelectMenu&#x27;);
        mdSelect.setLabelText(menuController.selectedLabels());
        mdSelect.triggerClose();
      }
    }


    /**
     * Calculate the
     */
    function calculateMenuPositions(scope, element, opts) {
      var
        containerNode = element[0],
        targetNode = opts.target[0].children[0], // target the label
        parentNode = $document[0].body,
        selectNode = opts.selectEl[0],
        contentNode = opts.contentEl[0],
        parentRect = parentNode.getBoundingClientRect(),
        targetRect = targetNode.getBoundingClientRect(),
        shouldOpenAroundTarget = false,
        bounds = {
          left: parentRect.left + SELECT_EDGE_MARGIN,
          top: SELECT_EDGE_MARGIN,
          bottom: parentRect.height - SELECT_EDGE_MARGIN,
          right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
        },
        spaceAvailable = {
          top: targetRect.top - bounds.top,
          left: targetRect.left - bounds.left,
          right: bounds.right - (targetRect.left + targetRect.width),
          bottom: bounds.bottom - (targetRect.top + targetRect.height)
        },
        maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
        selectedNode = selectNode.querySelector(&#x27;md-option[selected]&#x27;),
        optionNodes = selectNode.getElementsByTagName(&#x27;md-option&#x27;),
        optgroupNodes = selectNode.getElementsByTagName(&#x27;md-optgroup&#x27;),
        isScrollable = calculateScrollable(element, contentNode),
        centeredNode;

      var loading = isPromiseLike(opts.loadingAsync);
      if (!loading) {
        // If a selected node, center around that
        if (selectedNode) {
          centeredNode = selectedNode;
          // If there are option groups, center around the first option group
        } else if (optgroupNodes.length) {
          centeredNode = optgroupNodes[0];
          // Otherwise - if we are not loading async - center around the first optionNode
        } else if (optionNodes.length) {
          centeredNode = optionNodes[0];
          // In case there are no options, center on whatever&#x27;s in there... (eg progress indicator)
        } else {
          centeredNode = contentNode.firstElementChild || contentNode;
        }
      } else {
        // If loading, center on progress indicator
        centeredNode = contentNode.firstElementChild || contentNode;
      }

      if (contentNode.offsetWidth &gt; maxWidth) {
        contentNode.style[&#x27;max-width&#x27;] = maxWidth + &#x27;px&#x27;;
      } else {
        contentNode.style.maxWidth = null;
      }
      if (shouldOpenAroundTarget) {
        contentNode.style[&#x27;min-width&#x27;] = targetRect.width + &#x27;px&#x27;;
      }

      // Remove padding before we compute the position of the menu
      if (isScrollable) {
        selectNode.classList.add(&#x27;md-overflow&#x27;);
      }

      var focusedNode = centeredNode;
      if ((focusedNode.tagName || &#x27;&#x27;).toUpperCase() === &#x27;MD-OPTGROUP&#x27;) {
        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
        centeredNode = focusedNode;
      }
      // Cache for autoFocus()
      opts.focusedNode = focusedNode;

      // Get the selectMenuRect *after* max-width is possibly set above
      containerNode.style.display = &#x27;block&#x27;;
      var selectMenuRect = selectNode.getBoundingClientRect();
      var centeredRect = getOffsetRect(centeredNode);

      if (centeredNode) {
        var centeredStyle = $window.getComputedStyle(centeredNode);
        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
      }

      if (isScrollable) {
        var scrollBuffer = contentNode.offsetHeight / 2;
        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;

        if (spaceAvailable.top &lt; scrollBuffer) {
          contentNode.scrollTop = Math.min(
            centeredRect.top,
            contentNode.scrollTop + scrollBuffer - spaceAvailable.top
          );
        } else if (spaceAvailable.bottom &lt; scrollBuffer) {
          contentNode.scrollTop = Math.max(
            centeredRect.top + centeredRect.height - selectMenuRect.height,
            contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom
          );
        }
      }

      var left, top, transformOrigin, minWidth;
      if (shouldOpenAroundTarget) {
        left = targetRect.left;
        top = targetRect.top + targetRect.height;
        transformOrigin = &#x27;50% 0&#x27;;
        if (top + selectMenuRect.height &gt; bounds.bottom) {
          top = targetRect.top - selectMenuRect.height;
          transformOrigin = &#x27;50% 100%&#x27;;
        }
      } else {
        left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -
            centeredRect.top + contentNode.scrollTop) + 2;

        transformOrigin = (centeredRect.left + targetRect.width / 2) + &#x27;px &#x27; +
          (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + &#x27;px 0px&#x27;;

        minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
      }

      // Keep left and top within the window
      var containerRect = containerNode.getBoundingClientRect();
      var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
      var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;

      return {
        container: {
          element: angular.element(containerNode),
          styles: {
            left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
            top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
            &#x27;min-width&#x27;: minWidth
          }
        },
        dropDown: {
          element: angular.element(selectNode),
          styles: {
            transformOrigin: transformOrigin,
            transform: !opts.alreadyOpen ? $mdUtil.supplant(&#x27;scale({0},{1})&#x27;, [scaleX, scaleY]) : &quot;&quot;
          }
        }
      };

    }

  }

  function isPromiseLike(obj) {
    return obj &amp;&amp; angular.isFunction(obj.then);
  }

  function clamp(min, n, max) {
    return Math.max(min, Math.min(n, max));
  }

  function getOffsetRect(node) {
    return node ? {
      left: node.offsetLeft,
      top: node.offsetTop,
      width: node.offsetWidth,
      height: node.offsetHeight
    } : {left: 0, top: 0, width: 0, height: 0};
  }

  function calculateScrollable(element, contentNode) {
    var isScrollable = false;

    try {
      var oldDisplay = element[0].style.display;

      // Set the element&#x27;s display to block so that this calculation is correct
      element[0].style.display = &#x27;block&#x27;;

      isScrollable = contentNode.scrollHeight &gt; contentNode.offsetHeight;

      // Reset it back afterwards
      element[0].style.display = oldDisplay;
    } finally {
      // Nothing to do
    }
    return isScrollable;
  }
}
SelectProvider.$inject = [&quot;$$interimElementProvider&quot;];


ng.material.components.select = angular.module(&quot;material.components.select&quot;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
