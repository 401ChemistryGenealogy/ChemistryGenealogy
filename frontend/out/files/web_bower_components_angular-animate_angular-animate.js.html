<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>web\bower_components\angular-animate\angular-animate.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">auditTrailController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/editController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">editController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/GruntFile
                
                Was attempting to do gruntdocs....html">GruntFile
                
                Was attempting to do gruntdocs...</a></li>
                                <li><a href="../classes/mentorshipNotificationController
                
                Notifications for mentorships are dealt with here..html">mentorshipNotificationController
                
                Notifications for mentorships are dealt with here.</a></li>
                                <li><a href="../classes/muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application..html">muserController
                
                The user controller is located here, that handles the affairs dealing with the users of the application
                working with the application.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file..html">personAutoController
                
                Deals with the automatic updating and searching for the people supplied into the query string provided
                through the search bar at the top of the main html file.</a></li>
                                <li><a href="../classes/personNotificationController
                
                Notifications for persons are dealt with here..html">personNotificationController
                
                Notifications for persons are dealt with here.</a></li>
                                <li><a href="../classes/searchController
                
                Entire Search Functionality located here..html">searchController
                
                Entire Search Functionality located here.</a></li>
                                <li><a href="../classes/submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc.html">submitController
                
                Controller for the Submission page.
                
                
                Status: CONTROLLER
                Associated files: submit.html
                
                The submission page is going to be the core of where the users will be able to supply information to begin a new
                page for a given particular user. This page is going to be essentially a massive collection of information that
                we will be inserting into the system.
                
                Things that we&#x27;re collecting include basic information like:
                -first name
                -last name
                -degree type
                -postdoc postings
                -etc</a></li>
                                <li><a href="../classes/supervisionNotificationController
                
                Notifications for supervision are dealt with here..html">supervisionNotificationController
                
                Notifications for supervision are dealt with here.</a></li>
                                <li><a href="../classes/userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions..html">userDialogController
                
                 Controller for the User Dialogue
                
                Status: CONTROLLER
                Associated files: userDialog.html,
                
                The user dialog controller is associated with registration and submission of login information. So it is
                slightly associated with the User Controller (userController.js), yet is kept distinct for clarity of functions.</a></li>
                                <li><a href="../classes/viewController
                
                This controller does all that can be done with the view page..html">viewController
                
                This controller does all that can be done with the view page.</a></li>
                                <li><a href="../classes/visController
                
                Notifications for mentorships are dealt with here..html">visController
                
                Notifications for mentorships are dealt with here.</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/auditTrailController.html">auditTrailController</a></li>
                                <li><a href="../modules/editController.html">editController</a></li>
                                <li><a href="../modules/GruntFile.html">GruntFile</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/mentorshipNotificationController.html">mentorshipNotificationController</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                                <li><a href="../modules/personNotificationController.html">personNotificationController</a></li>
                                <li><a href="../modules/searchController.html">searchController</a></li>
                                <li><a href="../modules/submitController.html">submitController</a></li>
                                <li><a href="../modules/supervisionNotificationController.html">supervisionNotificationController</a></li>
                                <li><a href="../modules/userController.html">userController</a></li>
                                <li><a href="../modules/userDialogController.html">userDialogController</a></li>
                                <li><a href="../modules/viewController.html">viewController</a></li>
                                <li><a href="../modules/visController.html">visController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: web\bower_components\angular-animate\angular-animate.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @license AngularJS v1.5.0
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {&#x27;use strict&#x27;;

/* jshint ignore:start */
var noop        = angular.noop;
var copy        = angular.copy;
var extend      = angular.extend;
var jqLite      = angular.element;
var forEach     = angular.forEach;
var isArray     = angular.isArray;
var isString    = angular.isString;
var isObject    = angular.isObject;
var isUndefined = angular.isUndefined;
var isDefined   = angular.isDefined;
var isFunction  = angular.isFunction;
var isElement   = angular.isElement;

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = &#x27;-add&#x27;;
var REMOVE_CLASS_SUFFIX = &#x27;-remove&#x27;;
var EVENT_CLASS_PREFIX = &#x27;ng-&#x27;;
var ACTIVE_CLASS_SUFFIX = &#x27;-active&#x27;;
var PREPARE_CLASS_SUFFIX = &#x27;-prepare&#x27;;

var NG_ANIMATE_CLASSNAME = &#x27;ng-animate&#x27;;
var NG_ANIMATE_CHILDREN_DATA = &#x27;$$ngAnimateChildren&#x27;;

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = &#x27;&#x27;, TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements &#x60;window.onwebkitanimationend&#x60; and doesn&#x27;t implement &#x60;window.onanimationend&#x60;
// but at the same time dispatches the &#x60;animationend&#x60; event and not &#x60;webkitAnimationEnd&#x60;.
// Register both events in case &#x60;window.onanimationend&#x60; is not supported because of that,
// do the same for &#x60;transitionend&#x60; as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if (isUndefined(window.ontransitionend) &amp;&amp; isDefined(window.onwebkittransitionend)) {
  CSS_PREFIX = &#x27;-webkit-&#x27;;
  TRANSITION_PROP = &#x27;WebkitTransition&#x27;;
  TRANSITIONEND_EVENT = &#x27;webkitTransitionEnd transitionend&#x27;;
} else {
  TRANSITION_PROP = &#x27;transition&#x27;;
  TRANSITIONEND_EVENT = &#x27;transitionend&#x27;;
}

if (isUndefined(window.onanimationend) &amp;&amp; isDefined(window.onwebkitanimationend)) {
  CSS_PREFIX = &#x27;-webkit-&#x27;;
  ANIMATION_PROP = &#x27;WebkitAnimation&#x27;;
  ANIMATIONEND_EVENT = &#x27;webkitAnimationEnd animationend&#x27;;
} else {
  ANIMATION_PROP = &#x27;animation&#x27;;
  ANIMATIONEND_EVENT = &#x27;animationend&#x27;;
}

var DURATION_KEY = &#x27;Duration&#x27;;
var PROPERTY_KEY = &#x27;Property&#x27;;
var DELAY_KEY = &#x27;Delay&#x27;;
var TIMING_KEY = &#x27;TimingFunction&#x27;;
var ANIMATION_ITERATION_COUNT_KEY = &#x27;IterationCount&#x27;;
var ANIMATION_PLAYSTATE_KEY = &#x27;PlayState&#x27;;
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var isPromiseLike = function(p) {
  return p &amp;&amp; p.then ? true : false;
};

var ngMinErr = angular.$$minErr(&#x27;ng&#x27;);
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr(&#x27;areq&#x27;, &quot;Argument &#x27;{0}&#x27; is {1}&quot;, (name || &#x27;?&#x27;), (reason || &quot;required&quot;));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a &amp;&amp; !b) return &#x27;&#x27;;
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(&#x27; &#x27;);
  if (isArray(b)) b = b.join(&#x27; &#x27;);
  return a + &#x27; &#x27; + b;
}

function packageStyles(options) {
  var styles = {};
  if (options &amp;&amp; (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = &#x27;&#x27;;
  classes = isArray(classes)
      ? classes
      : classes &amp;&amp; isString(classes) &amp;&amp; classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass &amp;&amp; klass.length &gt; 0) {
      className += (i &gt; 0) ? &#x27; &#x27; : &#x27;&#x27;;
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val &gt;= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return [];
        break;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it&#x27;s important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
        break;
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i &lt; element.length; i++) {
    var elm = element[i];
    if (elm.nodeType == ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  }
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  var target = oldAnimation.options || {};
  var newOptions = newAnimation.options || {};

  var toAdd = (target.addClass || &#x27;&#x27;) + &#x27; &#x27; + (newOptions.addClass || &#x27;&#x27;);
  var toRemove = (target.removeClass || &#x27;&#x27;) + &#x27; &#x27; + (newOptions.removeClass || &#x27;&#x27;);
  var classes = resolveElementClasses(element.attr(&#x27;class&#x27;), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: &#x27;&#x27;,
    removeClass: &#x27;&#x27;
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = &#x27;addClass&#x27;;
      allow = !existing[klass];
    } else if (val === REMOVE_CLASS) {
      prop = &#x27;removeClass&#x27;;
      allow = existing[klass];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += &#x27; &#x27;;
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(&#x27; &#x27;);
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof angular.element) ? element[0] : element;
}

function applyGeneratedPreparationClasses(element, event, options) {
  var classes = &#x27;&#x27;;
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn&#x27;t kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  var value = duration ? &#x27;-&#x27; + duration + &#x27;s&#x27; : &#x27;&#x27;;
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? &#x27;paused&#x27; : &#x27;&#x27;;
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + &#x27; &#x27; + b;
}

var $$rAFSchedulerFactory = [&#x27;$$rAF&#x27;, function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL &#x60;fn&#x60; value only when an uncanceled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet &#x60;fn&#x60; has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i &lt; items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

/**
 * @ngdoc directive
 * @name ngAnimateChildren
 * @restrict AE
 * @element ANY
 *
 * @description
 *
 * ngAnimateChildren allows you to specify that children of this element should animate even if any
 * of the children&#x27;s parents are currently animating. By default, when an element has an active &#x60;enter&#x60;, &#x60;leave&#x60;, or &#x60;move&#x60;
 * (structural) animation, child elements that also have an active structural animation are not animated.
 *
 * Note that even if &#x60;ngAnimteChildren&#x60; is set, no child animations will run when the parent element is removed from the DOM (&#x60;leave&#x60; animation).
 *
 *
 * @param {string} ngAnimateChildren If the value is empty, &#x60;true&#x60; or &#x60;on&#x60;,
 *     then child animations are allowed. If the value is &#x60;false&#x60;, child animations are not allowed.
 *
 * @example
 * &lt;example module=&quot;ngAnimateChildren&quot; name=&quot;ngAnimateChildren&quot; deps=&quot;angular-animate.js&quot; animations=&quot;true&quot;&gt;
     &lt;file name=&quot;index.html&quot;&gt;
       &lt;div ng-controller=&quot;mainController as main&quot;&gt;
         &lt;label&gt;Show container? &lt;input type=&quot;checkbox&quot; ng-model=&quot;main.enterElement&quot; /&gt;&lt;/label&gt;
         &lt;label&gt;Animate children? &lt;input type=&quot;checkbox&quot; ng-model=&quot;main.animateChildren&quot; /&gt;&lt;/label&gt;
         &lt;hr&gt;
         &lt;div ng-animate-children=&quot;{{main.animateChildren}}&quot;&gt;
           &lt;div ng-if=&quot;main.enterElement&quot; class=&quot;container&quot;&gt;
             List of items:
             &lt;div ng-repeat=&quot;item in [0, 1, 2, 3]&quot; class=&quot;item&quot;&gt;Item {{item}}&lt;/div&gt;
           &lt;/div&gt;
         &lt;/div&gt;
       &lt;/div&gt;
     &lt;/file&gt;
     &lt;file name=&quot;animations.css&quot;&gt;

      .container.ng-enter,
      .container.ng-leave {
        transition: all ease 1.5s;
      }

      .container.ng-enter,
      .container.ng-leave-active {
        opacity: 0;
      }

      .container.ng-leave,
      .container.ng-enter-active {
        opacity: 1;
      }

      .item {
        background: firebrick;
        color: #FFF;
        margin-bottom: 10px;
      }

      .item.ng-enter,
      .item.ng-leave {
        transition: transform 1.5s ease;
      }

      .item.ng-enter {
        transform: translateX(50px);
      }

      .item.ng-enter-active {
        transform: translateX(0);
      }
    &lt;/file&gt;
    &lt;file name=&quot;script.js&quot;&gt;
      angular.module(&#x27;ngAnimateChildren&#x27;, [&#x27;ngAnimate&#x27;])
        .controller(&#x27;mainController&#x27;, function() {
          this.animateChildren = false;
          this.enterElement = false;
        });
    &lt;/file&gt;
  &lt;/example&gt;
 */
var $$AnimateChildrenDirective = [&#x27;$interpolate&#x27;, function($interpolate) {
  return {
    link: function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (angular.isString(val) &amp;&amp; val.length === 0) { //empty attribute
        element.data(NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe(&#x27;ngAnimateChildren&#x27;, setData);
      }

      function setData(value) {
        value = value === &#x27;on&#x27; || value === &#x27;true&#x27;;
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      }
    }
  };
}];

var ANIMATE_TIMER_KEY = &#x27;$$animateCss&#x27;;

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The &#x60;$animateCss&#x60; service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of &#x60;$animateCss&#x60; is NOT
 * to side-step how &#x60;$animate&#x60; and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via &#x60;$animateCss&#x60; (bad news for IE9 and lower).
 *
 * ## Usage
 * Once again, &#x60;$animateCss&#x60; is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use &#x60;$animateCss&#x60; directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by Angular. For this to work as expected, please use &#x60;$animate&#x60; to
 * trigger the animation and then setup a JavaScript animation that injects &#x60;$animateCss&#x60; to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using &#x60;ng-if&#x60;:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;!-- notice the &#x60;fold-animation&#x60; CSS class --&gt;
 * &lt;div ng-if=&quot;onOff&quot; class=&quot;fold-animation&quot;&gt;
 *   This element will go BOOM
 * &lt;/div&gt;
 * &lt;button ng-click=&quot;onOff=true&quot;&gt;Fold In&lt;/button&gt;
 * &#x60;&#x60;&#x60;
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * &#x60;&#x60;&#x60;js
 * ngModule.animation(&#x27;.fold-animation&#x27;, [&#x27;$animateCss&#x27;, function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:&#x27;0px&#x27; },
 *         to: { height:height + &#x27;px&#x27; },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * ## More Advanced Uses
 *
 * &#x60;$animateCss&#x60; is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like &#x60;.ng-EVENT&#x60;, &#x60;.ng-EVENT-active&#x60;, &#x60;.ng-EVENT-stagger&#x60; are all features that can be triggered using &#x60;$animateCss&#x60; via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * &#x60;$animateCss&#x60;. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the &#x60;.fold-animation&#x60; from the example above:
 *
 * &#x60;&#x60;&#x60;js
 * ngModule.animation(&#x27;.fold-animation&#x27;, [&#x27;$animateCss&#x27;, function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: &#x27;red large-text pulse-twice&#x27;,
 *         easing: &#x27;ease-out&#x27;,
 *         from: { height:&#x27;0px&#x27; },
 *         to: { height:height + &#x27;px&#x27; },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * Since we&#x27;re adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &amp;#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&amp;#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &amp;#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * &#x60;&#x60;&#x60;
 *
 * Given this complex combination of CSS classes, styles and options, &#x60;$animateCss&#x60; will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * &#x60;$animateCss&#x60; is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the &#x60;from&#x60; and &#x60;to&#x60; properties.
 *
 * &#x60;&#x60;&#x60;js
 * var animator = $animateCss(element, {
 *   from: { background:&#x27;red&#x27; },
 *   to: { background:&#x27;blue&#x27; }
 * });
 * animator.start();
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * &#x60;&#x60;&#x60;
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the &#x60;$animateCss&#x60; options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, &#x60;$animateCss&#x60; will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided &#x60;from&#x60; and &#x60;to&#x60; CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * &#x60;$animateCss&#x60; works in two stages: a preparation phase and an animation phase. Therefore when &#x60;$animateCss&#x60; is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once &#x60;$animateCss&#x60; is called it will return an object with the following properties:
 *
 * &#x60;&#x60;&#x60;js
 * var animator = $animateCss(element, { ... });
 * &#x60;&#x60;&#x60;
 *
 * Now what do the contents of our &#x60;animator&#x60; variable look like:
 *
 * &#x60;&#x60;&#x60;js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * &#x60;&#x60;&#x60;
 *
 * To actually start the animation we need to run &#x60;animation.start()&#x60; which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run &#x60;animation.end()&#x60; to perform a cleanup on the element (since some CSS classes and styles may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that &#x60;animation.start()&#x60; will return a promise object and this is true, however, there is also an additional method available on the
 * runner called &#x60;.done(callbackFn)&#x60;. The done method works the same as &#x60;.finally(callbackFn)&#x60;, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it&#x27;s always best to use &#x60;runner.done(callback)&#x60; instead of &#x60;runner.then()&#x60;, &#x60;runner.catch()&#x60; or &#x60;runner.finally()&#x60;
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call &#x60;runner.done(doneFn)&#x60; inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * &#x60;event&#x60; - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of &#x60;ng-EVENT&#x60; and &#x60;ng-EVENT-active&#x60; will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * &#x60;structural&#x60; - Indicates that the &#x60;ng-&#x60; prefix will be added to the event class. Setting to &#x60;false&#x60; or omitting will turn &#x60;ng-EVENT&#x60; and
 * &#x60;ng-EVENT-active&#x60; in &#x60;EVENT&#x60; and &#x60;EVENT-active&#x60;. Unused if &#x60;event&#x60; is omitted.
 * * &#x60;easing&#x60; - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * &#x60;transitionStyle&#x60; - The raw CSS transition style that will be used (e.g. &#x60;1s linear all&#x60;).
 * * &#x60;keyframeStyle&#x60; - The raw CSS keyframe animation style that will be used (e.g. &#x60;1s my_animation linear&#x60;).
 * * &#x60;from&#x60; - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * &#x60;to&#x60; - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * &#x60;addClass&#x60; - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * &#x60;removeClass&#x60; - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * &#x60;duration&#x60; - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of &#x60;0&#x60;
 * is provided then the animation will be skipped entirely.
 * * &#x60;delay&#x60; - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of &#x60;true&#x60; is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be &#x60;transition-delay: DETECTED_VALUE&#x60;). Using &#x60;true&#x60; is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * &#x60;stagger&#x60; - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * &#x60;staggerIndex&#x60; - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 *   &#x60;stagger&#x60; option value of &#x60;0.1&#x60; is used then there will be a stagger delay of &#x60;600ms&#x60;)
 * * &#x60;applyClassesEarly&#x60; - Whether or not the classes being added or removed will be used when detecting the animation. This is set by &#x60;$animate&#x60; when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
 * * &#x60;cleanupStyles&#x60; - Whether or not the provided &#x60;from&#x60; and &#x60;to&#x60; styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
 *    By default this value is set to &#x60;false&#x60;.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * &#x60;start&#x60; - The method to start the animation. This will return a &#x60;Promise&#x60; when called.
 * * &#x60;end&#x60; - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;
var BASE_TEN = 10;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + &#x27;s&#x27;];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + &#x27;s&#x27;];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === &#x27;-&#x27; || c === &#x27;+&#x27; || c &gt;= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it&#x27;s always safe to consider only second values and omit &#x60;ms&#x60; values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) == &#x27;s&#x27;) {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + &#x27;s&#x27;;
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += &#x27; linear all&#x27;;
  }
  return [style, value];
}

function createLocalCacheLookup() {
  var cache = Object.create(null);
  return {
    flush: function() {
      cache = Object.create(null);
    },

    count: function(key) {
      var entry = cache[key];
      return entry ? entry.total : 0;
    },

    get: function(key) {
      var entry = cache[key];
      return entry &amp;&amp; entry.value;
    },

    put: function(key, value) {
      if (!cache[key]) {
        cache[key] = { total: 1, value: value };
      } else {
        cache[key].total++;
      }
    }
  };
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the &#x60;from&#x60; styles.
// We make use of &#x60;isDefined&#x60; here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// &quot;OR&quot; statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = [&#x27;$animateProvider&#x27;, function($animateProvider) {
  var gcsLookup = createLocalCacheLookup();
  var gcsStaggerLookup = createLocalCacheLookup();

  this.$get = [&#x27;$window&#x27;, &#x27;$$jqLite&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$timeout&#x27;,
               &#x27;$$forceReflow&#x27;, &#x27;$sniffer&#x27;, &#x27;$$rAFScheduler&#x27;, &#x27;$$animateQueue&#x27;,
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    var parentCounter = 0;
    function gcsHashFn(node, extraClasses) {
      var KEY = &quot;$$ngAnimateParentKey&quot;;
      var parentNode = node.parentNode;
      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
      return parentID + &#x27;-&#x27; + node.getAttribute(&#x27;class&#x27;) + &#x27;-&#x27; + extraClasses;
    }

    function computeCachedCssStyles(node, className, cacheKey, properties) {
      var timings = gcsLookup.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === &#x27;infinite&#x27;) {
          timings.animationIterationCount = 1;
        }
      }

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we&#x27;re keeping an internal tally of how many duplicate animations are detected.
      gcsLookup.put(cacheKey, timings);
      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if (gcsLookup.count(cacheKey) &gt; 0) {
        stagger = gcsStaggerLookup.get(cacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, &#x27;-stagger&#x27;);

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          gcsStaggerLookup.put(cacheKey, stagger);
        }
      }

      return stagger || {};
    }

    var cancelLastRAFRequest;
    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        gcsLookup.flush();
        gcsStaggerLookup.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE &#x60;pageWidth&#x60; variable.
        // PLEASE EXAMINE THE &#x60;$$forceReflow&#x60; service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i &lt; rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey) {
      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD &amp;&amp; tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, initialOptions) {
      // all of the animation functions should create
      // a copy of the options data, however, if a
      // parent service has already created a copy then
      // we should stick to using that
      var options = initialOptions || {};
      if (!options.$$prepared) {
        options = prepareAnimationOptions(copy(options));
      }

      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$$animateQueue.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      var temporaryStyles = [];
      var classes = element.attr(&#x27;class&#x27;);
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;
      var startTime;
      var events = [];

      if (options.duration === 0 || (!$sniffer.animations &amp;&amp; !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event &amp;&amp; isArray(options.event)
            ? options.event.join(&#x27; &#x27;)
            : options.event;

      var isStructural = method &amp;&amp; options.structural;
      var structuralClassName = &#x27;&#x27;;
      var addRemoveClassName = &#x27;&#x27;;

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += &#x27; &#x27;;
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly &amp;&amp; addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(&#x27; &#x27;).trim();
      var fullClassName = classes + &#x27; &#x27; + preparationClasses;
      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
      var hasToStyles = styles.to &amp;&amp; Object.keys(styles.to).length &gt; 0;
      var containsKeyframeAnimation = (options.keyframeStyle || &#x27;&#x27;).length &gt; 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           &amp;&amp; !hasToStyles
           &amp;&amp; !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var cacheKey, stagger;
      if (options.stagger &gt; 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        cacheKey = gcsHashFn(node, fullClassName);
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration &gt;= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length &gt; 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex &gt;= 0
              ? options.staggerIndex
              : gcsLookup.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class&#x27; transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it&#x27;s thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst &amp;&amp; !options.skipBlocking) {
        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration &gt; 0;
      flags.hasAnimations           = timings.animationDuration &gt; 0;
      flags.hasTransitionAll        = flags.hasTransitions &amp;&amp; timings.transitionProperty == &#x27;all&#x27;;
      flags.applyTransitionDuration = hasToStyles &amp;&amp; (
                                        (flags.hasTransitions &amp;&amp; !flags.hasTransitionAll)
                                         || (flags.hasAnimations &amp;&amp; !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration &amp;&amp; flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) &amp;&amp; (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) &amp;&amp; flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length &gt; 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length &gt; 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 &amp;&amp; !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      if (options.delay != null) {
        var delayStyle;
        if (typeof options.delay !== &quot;boolean&quot;) {
          delayStyle = parseFloat(options.delay);
          // number in options.delay means we have to recalculate the delay for the closing timeout
          maxDelay = Math.max(delayStyle, 0);
        }

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null &amp;&amp; timings.transitionDuration &gt; 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration &gt; 0;
        flags.blockKeyframeAnimation = timings.animationDuration &gt; 0 &amp;&amp;
                                       stagger.animationDelay &gt; 0 &amp;&amp;
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don&#x27;t have access to pause/resume the animation
          // since it hasn&#x27;t run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) { // jshint ignore:line
        // if the promise has been called already then we shouldn&#x27;t close
        // the animation again
        if (animationClosed || (animationCompleted &amp;&amp; animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (!options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }
        $$jqLite.removeClass(element, activeClasses);

        blockKeyframeAnimations(node, false);
        blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using &#x60;removeProperty&#x60; this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = &#x27;&#x27;;
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            value ? node.style.setProperty(prop, value)
                  : node.style.removeProperty(prop);
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        if (events &amp;&amp; events.length) {
          // Remove the transitionend / animationend listener(s)
          element.off(events.join(&#x27; &#x27;), onAnimationProgress);
        }

        //Cancel the fallback closing timeout and remove the timer data
        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
        if (animationTimerData) {
          $timeout.cancel(animationTimerData[0].timer);
          element.removeData(ANIMATE_TIMER_KEY);
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function onAnimationProgress(event) {
        event.stopPropagation();
        var ev = event.originalEvent || event;

        // we now always use &#x60;Date.now()&#x60; due to the recent changes with
        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
        var timeStamp = ev.$manualTimeStamp || Date.now();

        /* Firefox (or possibly just Gecko) likes to not round values up
         * when a ms measurement is used for the animation */
        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

        /* $manualTimeStamp is a mocked timeStamp value which is set
         * within browserTrigger(). This is only here so that tests can
         * mock animations properly. Real events fallback to event.timeStamp,
         * or, if they don&#x27;t, then a timeStamp is automatically created for them.
         * We&#x27;re checking to see if the timeStamp surpasses the expected delay,
         * but we&#x27;re using elapsedTime instead of the timeStamp on the 2nd
         * pre-condition since animationPauseds sometimes close off early */
        if (Math.max(timeStamp - startTime, 0) &gt;= maxDelayTime &amp;&amp; elapsedTime &gt;= maxDuration) {
          // we set this flag to ensure that if the transition is paused then, when resumed,
          // the animation will automatically close itself since transitions cannot be paused.
          animationCompleted = true;
          close();
        }
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              animationPaused
                  ? temporaryStyles.push(value)
                  : removeFromArray(temporaryStyles, value);
            }
          } else if (animationPaused &amp;&amp; playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intentional stagger delay style.
        var maxStagger = itemIndex &gt; 0
                         &amp;&amp; ((timings.transitionDuration &amp;&amp; stagger.transitionDuration === 0) ||
                            (timings.animationDuration &amp;&amp; stagger.animationDuration === 0))
                         &amp;&amp; Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.className + &#x27; &#x27; + preparationClasses;
            cacheKey = gcsHashFn(node, fullClassName);

            timings = computeTimings(node, fullClassName, cacheKey);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration &gt; 0;
            flags.hasAnimations = timings.animationDuration &gt; 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== &quot;boolean&quot; &amp;&amp; truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime &gt; currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          if (events.length) {
            element.on(events.join(&#x27; &#x27;), onAnimationProgress);
          }

          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i &lt; animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = [&#x27;$$animationProvider&#x27;, function($$animationProvider) {
  $$animationProvider.drivers.push(&#x27;$$animateCssDriver&#x27;);

  var NG_ANIMATE_SHIM_CLASS_NAME = &#x27;ng-animate-shim&#x27;;
  var NG_ANIMATE_ANCHOR_CLASS_NAME = &#x27;ng-anchor&#x27;;

  var NG_OUT_ANCHOR_CLASS_NAME = &#x27;ng-anchor-out&#x27;;
  var NG_IN_ANCHOR_CLASS_NAME = &#x27;ng-anchor-in&#x27;;

  function isDocumentFragment(node) {
    return node.parentNode &amp;&amp; node.parentNode.nodeType === 11;
  }

  this.$get = [&#x27;$animateCss&#x27;, &#x27;$rootScope&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$rootElement&#x27;, &#x27;$sniffer&#x27;, &#x27;$$jqLite&#x27;, &#x27;$document&#x27;,
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations &amp;&amp; !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragment case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    return function initDriverFn(animationDetails) {
      return animationDetails.from &amp;&amp; animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the &#x60;ng-&#x60; stuff
      return classes.replace(/\bng-\S+\b/g, &#x27;&#x27;);
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(&#x27; &#x27;);
      if (isString(b)) b = b.split(&#x27; &#x27;);
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(&#x27; &#x27;);
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the &#x60;out&#x60; animation and
      // only making use of the &#x60;in&#x60; animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no &#x60;in&#x60; animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn&#x27;t return
        // all the keys for the coords object when iterated
        forEach([&#x27;width&#x27;,&#x27;height&#x27;,&#x27;top&#x27;,&#x27;left&#x27;], function(key) {
          var value = coords[key];
          switch (key) {
            case &#x27;top&#x27;:
              value += bodyNode.scrollTop;
              break;
            case &#x27;left&#x27;:
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + &#x27;px&#x27;;
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within &#x60;prepareRegularAnimation&#x60; to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr(&#x27;class&#x27;) || &#x27;&#x27;;
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + &#x27; &#x27; + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + &#x27; &#x27; + toRemove,
          delay: true
        });

        // read the comment within &#x60;prepareRegularAnimation&#x60; to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor[&#x27;out&#x27;];
        var inElement = anchor[&#x27;in&#x27;];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation &amp;&amp; !toAnimation &amp;&amp; anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === &#x27;leave&#x27;) {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with &#x60;-active&#x60; to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = [&#x27;$animateProvider&#x27;, function($animateProvider) {
  this.$get = [&#x27;$injector&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$$jqLite&#x27;,
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, &#x27;enter&#x27;);
    return function(element, event, classes, options) {
      var animationClosed = false;

      // the &#x60;classes&#x60; argument is optional and if it is not used
      // then the classes will be resolved from the element&#x27;s className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 &amp;&amp; isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr(&#x27;class&#x27;) || &#x27;&#x27;;
        if (options.addClass) {
          classes += &#x27; &#x27; + options.addClass;
        }
        if (options.removeClass) {
          classes += &#x27; &#x27; + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don&#x27;t return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event == &#x27;leave&#x27;) {
          beforeFn = &#x27;leave&#x27;;
          afterFn = &#x27;afterLeave&#x27;; // TODO(matsko): get rid of this
        } else {
          beforeFn = &#x27;before&#x27; + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== &#x27;enter&#x27; &amp;&amp; event !== &#x27;move&#x27;) {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before &amp;&amp; !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      function close() {
        animationClosed = true;
        applyOptions();
        applyAnimationStyles(element, options);
      }

      var runner;

      return {
        $$willAnimate: true,
        end: function() {
          if (runner) {
            runner.end();
          } else {
            close();
            runner = new $$AnimateRunner();
            runner.complete(true);
          }
          return runner;
        },
        start: function() {
          if (runner) {
            return runner;
          }

          runner = new $$AnimateRunner();
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          runner.setHost({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            close(success);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case &#x27;animate&#x27;:
            args = [element, options.from, options.to, onDone];
            break;

          case &#x27;setClass&#x27;:
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case &#x27;addClass&#x27;:
            args = [element, classesToAdd, onDone];
            break;

          case &#x27;removeClass&#x27;:
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a,b;
          if (fnName === &#x27;beforeSetClass&#x27;) {
            a = groupEventedAnimations(element, &#x27;removeClass&#x27;, options, animations, &#x27;beforeRemoveClass&#x27;);
            b = groupEventedAnimations(element, &#x27;addClass&#x27;, options, animations, &#x27;beforeAddClass&#x27;);
          } else if (fnName === &#x27;setClass&#x27;) {
            a = groupEventedAnimations(element, &#x27;removeClass&#x27;, options, animations, &#x27;removeClass&#x27;);
            b = groupEventedAnimations(element, &#x27;addClass&#x27;, options, animations, &#x27;addClass&#x27;);
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          runners.length ? $$AnimateRunner.all(runners, callback) : callback();

          return function endFn(reject) {
            forEach(runners, function(runner) {
              reject ? runner.cancel() : runner.end();
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(&#x27; &#x27;);
      var matches = [], flagMap = {};
      for (var i=0; i &lt; classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory &amp;&amp; !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = [&#x27;$$animationProvider&#x27;, function($$animationProvider) {
  $$animationProvider.drivers.push(&#x27;$$animateJsDriver&#x27;);
  this.$get = [&#x27;$$animateJs&#x27;, &#x27;$$AnimateRunner&#x27;, function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from &amp;&amp; animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation &amp;&amp; !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = &#x27;data-ng-animate&#x27;;
var NG_ANIMATE_PIN_DATA = &#x27;$ngAnimatePin&#x27;;
var $$AnimateQueueProvider = [&#x27;$animateProvider&#x27;, function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;
  var ONE_SPACE = &#x27; &#x27;;

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    var keys = classString.split(ONE_SPACE);
    var map = Object.create(null);

    forEach(keys, function(key) {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString &amp;&amp; currentClassString) {
      var currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString.split(ONE_SPACE).some(function(className) {
        return currentClassMap[className];
      });
    }
  }

  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(element, currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(animation, and) {
    var a = (animation.addClass || &#x27;&#x27;).length &gt; 0;
    var b = (animation.removeClass || &#x27;&#x27;).length &gt; 0;
    return and ? a &amp;&amp; b : a || b;
  }

  rules.join.push(function(element, newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural &amp;&amp; hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural &amp;&amp; !hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event == &#x27;leave&#x27; &amp;&amp; newAnimation.structural;
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don&#x27;t even bother running the class-based animation
    return currentAnimation.structural &amp;&amp; currentAnimation.state === RUNNING_STATE &amp;&amp; !newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural &amp;&amp; newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE &amp;&amp; newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    var nA = newAnimation.addClass;
    var nR = newAnimation.removeClass;
    var cA = currentAnimation.addClass;
    var cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if ((isUndefined(nA) &amp;&amp; isUndefined(nR)) || (isUndefined(cA) &amp;&amp; isUndefined(cR))) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = [&#x27;$$rAF&#x27;, &#x27;$rootScope&#x27;, &#x27;$rootElement&#x27;, &#x27;$document&#x27;, &#x27;$$HashMap&#x27;,
               &#x27;$$animation&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$templateRequest&#x27;, &#x27;$$jqLite&#x27;, &#x27;$$forceReflow&#x27;,
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {

    var activeAnimationsLookup = new $$HashMap();
    var disabledElementsLookup = new $$HashMap();
    var animationsEnabled = null;

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it&#x27;s important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = {};

    // remember that the classNameFilter is set during the provider/config
    // stage therefore we can optimize here and setup a helper function
    var classNameFilter = $animateProvider.classNameFilter();
    var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationDetails(element, animation) {
      return mergeAnimationDetails(element, animation, {});
    }

    // IE9-11 has no method &quot;contains&quot; in SVG element and in Node.prototype. Bug #10259.
    var contains = Node.prototype.contains || function(arg) {
      // jshint bitwise: false
      return this === arg || !!(this.compareDocumentPosition(arg) &amp; 16);
      // jshint bitwise: true
    };

    function findCallbacks(parent, element, event) {
      var targetNode = getDomNode(element);
      var targetParentNode = getDomNode(parent);

      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (contains.call(entry.node, targetNode)) {
            matches.push(entry.callback);
          } else if (event === &#x27;leave&#x27; &amp;&amp; contains.call(entry.node, targetParentNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    return {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });
      },

      off: function(event, container, callback) {
        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);

        function filterFromRegistry(list, matchContainer, matchCallback) {
          var containerNode = extractElementNode(matchContainer);
          return list.filter(function(entry) {
            var isMatch = entry.node === containerNode &amp;&amp;
                            (!matchCallback || entry.callback === matchCallback);
            return !isMatch;
          });
        }
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), &#x27;element&#x27;, &#x27;not an element&#x27;);
        assertArg(isElement(parentElement), &#x27;parentElement&#x27;, &#x27;not an element&#x27;);
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter&lt;F37&gt;
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);
            var recordExists = disabledElementsLookup.get(node);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !recordExists;
            } else {
              // (element, bool) - Element setter
              disabledElementsLookup.put(node, !bool);
            }
          }
        }

        return bool;
      }
    };

    function queueAnimation(element, event, initialOptions) {
      // we always make a copy of the options since
      // there should never be any side effects on
      // the input data when running &#x60;$animateCss&#x60;.
      var options = copy(initialOptions);

      var node, parent;
      element = stripCommentsFromElement(element);
      if (element) {
        node = getDomNode(element);
        parent = element.parent();
      }

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(&#x27; &#x27;);
      }

      if (options.addClass &amp;&amp; !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(&#x27; &#x27;);
      }

      if (options.removeClass &amp;&amp; !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from &amp;&amp; !isObject(options.from)) {
        options.from = null;
      }

      if (options.to &amp;&amp; !isObject(options.to)) {
        options.to = null;
      }

      // there are situations where a directive issues an animation for
      // a jqLite wrapper that contains only comment nodes... If this
      // happens then there is no way we can perform an animation
      if (!node) {
        close();
        return runner;
      }

      var className = [node.className, options.addClass, options.removeClass].join(&#x27; &#x27;);
      if (!isAnimatableClassName(className)) {
        close();
        return runner;
      }

      var isStructural = [&#x27;enter&#x27;, &#x27;move&#x27;, &#x27;leave&#x27;].indexOf(event) &gt;= 0;

      // this is a hard disable of all animations for the application or on
      // the element itself, therefore  there is no need to continue further
      // past this point if not enabled
      // Animations are also disabled if the document is currently hidden (page is not visible
      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
      var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations &amp;&amp; activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations &amp;&amp; (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(element, parent, event);
      }

      if (skipAnimations) {
        close();
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(element);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        addClass: options.addClass,
        removeClass: options.removeClass,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed(&#x27;skip&#x27;, element, newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
        }
        var cancelAnimationFlag = isAllowed(&#x27;cancel&#x27;, element, newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn&#x27;t started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationDetails(element, existingAnimation, newAnimation);

            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed(&#x27;join&#x27;, element, newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationDetails(element, newAnimation);
            } else {
              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

              //we return the same runner since only the option values of this animation will
              //be fed into the &#x60;existingAnimation&#x60;.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationDetails(element, newAnimation);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === &#x27;animate&#x27; &amp;&amp; Object.keys(newAnimation.options.to || {}).length &gt; 0)
                            || hasAnimationClasses(newAnimation);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(element);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length &gt; 0
                                &amp;&amp; (animationDetails.event === &#x27;animate&#x27;
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it&#x27;s the same then the end result will be the same too
          if (animationCancelled || (isStructural &amp;&amp; animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn&#x27;t allowed to animate from here then we need to clear the state of the element
          // so that any future animations won&#x27;t read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(element);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural &amp;&amp; hasAnimationClasses(animationDetails, true)
            ? &#x27;setClass&#x27;
            : animationDetails.event;

        markElementAnimationState(element, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails &amp;&amp; animationDetails.counter === counter) {
            clearElementAnimationState(getDomNode(element));
          }
          notifyProgress(runner, event, &#x27;close&#x27;, {});
        });

        // this will update the runner&#x27;s flow-control events based on
        // the &#x60;realRunner&#x60; object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, &#x27;start&#x27;, {});
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(parent, element, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don&#x27;t know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
            });
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) { // jshint ignore:line
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(element) {
      var node = getDomNode(element);
      var children = node.querySelectorAll(&#x27;[&#x27; + NG_ANIMATE_ATTR_NAME + &#x27;]&#x27;);
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
        var animationDetails = activeAnimationsLookup.get(child);
        if (animationDetails) {
          switch (state) {
            case RUNNING_STATE:
              animationDetails.runner.end();
              /* falls through */
            case PRE_DIGEST_STATE:
              activeAnimationsLookup.remove(child);
              break;
          }
        }
      });
    }

    function clearElementAnimationState(element) {
      var node = getDomNode(element);
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.remove(node);
    }

    function isMatchingElement(nodeOrElmA, nodeOrElmB) {
      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
    }

    /**
     * This fn returns false if any of the following is true:
     * a) animations on any parent element are disabled, and animations on the element aren&#x27;t explicitly allowed
     * b) a parent element has an ongoing structural animation, and animateChildren is false
     * c) the element is not a child of the body
     * d) the element is not a child of the $rootElement
     */
    function areAnimationsAllowed(element, parentElement, event) {
      var bodyElement = jqLite($document[0].body);
      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === &#x27;HTML&#x27;;
      var rootElementDetected = isMatchingElement(element, $rootElement);
      var parentAnimationDetected = false;
      var animateChildren;
      var elementDisabled = disabledElementsLookup.get(getDomNode(element));

      var parentHost = element.data(NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentElement = parentHost;
      }

      while (parentElement &amp;&amp; parentElement.length) {
        if (!rootElementDetected) {
          // angular doesn&#x27;t want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootElementDetected = isMatchingElement(parentElement, $rootElement);
        }

        var parentNode = parentElement[0];
        if (parentNode.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentNode) || {};
        // either an enter, leave or move animation will commence
        // therefore we can&#x27;t allow any animations to take place
        // but if a parent animation is class-based then that&#x27;s ok
        if (!parentAnimationDetected) {
          var parentElementDisabled = disabledElementsLookup.get(parentNode);

          if (parentElementDisabled === true &amp;&amp; elementDisabled !== false) {
            // disable animations if the user hasn&#x27;t explicitly enabled animations on the
            // current element
            elementDisabled = true;
            // element is disabled via parent element, no need to check anything else
            break;
          } else if (parentElementDisabled === false) {
            elementDisabled = false;
          }
          parentAnimationDetected = details.structural;
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected &amp;&amp; animateChildren === false) break;

        if (!bodyElementDetected) {
          // we also need to ensure that the element is or will be a part of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyElementDetected = isMatchingElement(parentElement, bodyElement);
        }

        if (bodyElementDetected &amp;&amp; rootElementDetected) {
          // If both body and root have been found, any other checks are pointless,
          // as no animation data should live outside the application
          break;
        }

        if (!rootElementDetected) {
          // If no rootElement is detected, check if the parentElement is pinned to another element
          parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            // The pin target element becomes the next parent element
            parentElement = parentHost;
            continue;
          }
        }

        parentElement = parentElement.parent();
      }

      var allowAnimation = (!parentAnimationDetected || animateChildren) &amp;&amp; elementDisabled !== true;
      return allowAnimation &amp;&amp; rootElementDetected &amp;&amp; bodyElementDetected;
    }

    function markElementAnimationState(element, state, details) {
      details = details || {};
      details.state = state;

      var node = getDomNode(element);
      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.put(node, newValue);
    }
  }];
}];

var $$AnimationProvider = [&#x27;$animateProvider&#x27;, function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = &#x27;ng-animate-ref&#x27;;

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = &#x27;$$animationRunner&#x27;;

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = [&#x27;$$jqLite&#x27;, &#x27;$rootScope&#x27;, &#x27;$injector&#x27;, &#x27;$$AnimateRunner&#x27;, &#x27;$$HashMap&#x27;, &#x27;$$rAFScheduler&#x27;,
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$HashMap();

      // this is done first beforehand so that the hashmap
      // is filled with a list of the elements that will be animated
      for (i = 0; i &lt; animations.length; i++) {
        var animation = animations[i];
        lookup.put(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i &lt; animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.put(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i &lt; tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i &lt; queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries &lt;= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry.fn);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = [&#x27;enter&#x27;, &#x27;move&#x27;, &#x27;leave&#x27;].indexOf(event) &gt;= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver&#x27;s end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      setRunner(element, runner);

      var classes = mergeClasses(element.attr(&#x27;class&#x27;), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += &#x27; &#x27; + tempClasses;
        options.tempClasses = null;
      }

      var prepareClassName;
      if (isStructural) {
        prepareClassName = &#x27;ng-&#x27; + event + PREPARE_CLASS_SUFFIX;
        $$jqLite.addClass(element, prepareClassName);
      }

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on(&#x27;$destroy&#x27;, handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length &gt; 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can&#x27;t animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          toBeSortedAnimations.push({
            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
            fn: function triggerAnimationStart() {
              // it&#x27;s important that we apply the &#x60;ng-animate&#x60; CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = &#x27;[&#x27; + NG_ANIMATE_REF_ATTR + &#x27;]&#x27;;
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr &amp;&amp; attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = [&#x27;enter&#x27;, &#x27;move&#x27;].indexOf(event) &gt;= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? &#x27;to&#x27; : &#x27;from&#x27;;

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can&#x27;t have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effectively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            &#x27;out&#x27;: from.element, &#x27;in&#x27;: to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(&#x27; &#x27;);
        b = b.split(&#x27; &#x27;);
        var matches = [];

        for (var i = 0; i &lt; a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === &#x27;ng-&#x27;) continue;

          for (var j = 0; j &lt; b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(&#x27; &#x27;);
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i &gt;= 0; i--) {
          var driverName = drivers[i];
          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check

          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        element.addClass(NG_ANIMATE_CLASSNAME);
        if (tempClasses) {
          $$jqLite.addClass(element, tempClasses);
        }
        if (prepareClassName) {
          $$jqLite.removeClass(element, prepareClassName);
          prepareClassName = null;
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from &amp;&amp; animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          getRunner(element).setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner &amp;&amp; (event !== &#x27;leave&#x27; || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) { // jshint ignore:line
        element.off(&#x27;$destroy&#x27;, handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        element.removeClass(NG_ANIMATE_CLASSNAME);
        runner.complete(!rejected);
      }
    };
  }];
}];

/**
 * @ngdoc directive
 * @name ngAnimateSwap
 * @restrict A
 * @scope
 *
 * @description
 *
 * ngAnimateSwap is a animation-oriented directive that allows for the container to
 * be removed and entered in whenever the associated expression changes. A
 * common usecase for this directive is a rotating banner component which
 * contains one image being present at a time. When the active image changes
 * then the old image will perform a &#x60;leave&#x60; animation and the new element
 * will be inserted via an &#x60;enter&#x60; animation.
 *
 * @example
 * &lt;example name=&quot;ngAnimateSwap-directive&quot; module=&quot;ngAnimateSwapExample&quot;
 *          deps=&quot;angular-animate.js&quot;
 *          animations=&quot;true&quot; fixBase=&quot;true&quot;&gt;
 *   &lt;file name=&quot;index.html&quot;&gt;
 *     &lt;div class=&quot;container&quot; ng-controller=&quot;AppCtrl&quot;&gt;
 *       &lt;div ng-animate-swap=&quot;number&quot; class=&quot;cell swap-animation&quot; ng-class=&quot;colorClass(number)&quot;&gt;
 *         {{ number }}
 *       &lt;/div&gt;
 *     &lt;/div&gt;
 *   &lt;/file&gt;
 *   &lt;file name=&quot;script.js&quot;&gt;
 *     angular.module(&#x27;ngAnimateSwapExample&#x27;, [&#x27;ngAnimate&#x27;])
 *       .controller(&#x27;AppCtrl&#x27;, [&#x27;$scope&#x27;, &#x27;$interval&#x27;, function($scope, $interval) {
 *         $scope.number = 0;
 *         $interval(function() {
 *           $scope.number++;
 *         }, 1000);
 *
 *         var colors = [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;yellow&#x27;,&#x27;orange&#x27;];
 *         $scope.colorClass = function(number) {
 *           return colors[number % colors.length];
 *         };
 *       }]);
 *   &lt;/file&gt;
 *  &lt;file name=&quot;animations.css&quot;&gt;
 *  .container {
 *    height:250px;
 *    width:250px;
 *    position:relative;
 *    overflow:hidden;
 *    border:2px solid black;
 *  }
 *  .container .cell {
 *    font-size:150px;
 *    text-align:center;
 *    line-height:250px;
 *    position:absolute;
 *    top:0;
 *    left:0;
 *    right:0;
 *    border-bottom:2px solid black;
 *  }
 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
 *    transition:0.5s linear all;
 *  }
 *  .swap-animation.ng-enter {
 *    top:-250px;
 *  }
 *  .swap-animation.ng-enter-active {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave-active {
 *    top:250px;
 *  }
 *  .red { background:red; }
 *  .green { background:green; }
 *  .blue { background:blue; }
 *  .yellow { background:yellow; }
 *  .orange { background:orange; }
 *  &lt;/file&gt;
 * &lt;/example&gt;
 */
var ngAnimateSwapDirective = [&#x27;$animate&#x27;, &#x27;$rootScope&#x27;, function($animate, $rootScope) {
  return {
    restrict: &#x27;A&#x27;,
    transclude: &#x27;element&#x27;,
    terminal: true,
    priority: 600, // we use 600 here to ensure that the directive is caught before others
    link: function(scope, $element, attrs, ctrl, $transclude) {
      var previousElement, previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs[&#x27;for&#x27;], function(value) {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value || value === 0) {
          previousScope = scope.$new();
          $transclude(previousScope, function(element) {
            previousElement = element;
            $animate.enter(element, null, $element);
          });
        }
      });
    }
  };
}];

/* global angularAnimateModule: true,

   ngAnimateSwapDirective,
   $$AnimateAsyncRunFactory,
   $$rAFSchedulerFactory,
   $$AnimateChildrenDirective,
   $$AnimateQueueProvider,
   $$AnimationProvider,
   $AnimateCssProvider,
   $$AnimateCssDriverProvider,
   $$AnimateJsProvider,
   $$AnimateJsDriverProvider,
*/

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The &#x60;ngAnimate&#x60; module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including &#x60;ngAnimate&#x60; the animation hooks are enabled for an Angular app.
 *
 * &lt;div doc-module-components=&quot;ngAnimate&quot;&gt;&lt;/div&gt;
 *
 * # Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via &#x60;module.animation()&#x60;. For
 * both CSS and JS animations the sole requirement is to have a matching &#x60;CSS class&#x60; that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are &quot;animation aware&quot;:
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} &amp; {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} &amp; {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid &amp; all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active &amp; ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * (More information can be found by visiting each the documentation associated with each directive.)
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.
 *
 * The example below shows how an &#x60;enter&#x60; animation can be made possible on an element using &#x60;ng-if&#x60;:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-if=&quot;bool&quot; class=&quot;fade&quot;&gt;
 *    Fade me in out
 * &lt;/div&gt;
 * &lt;button ng-click=&quot;bool=true&quot;&gt;Fade In!&lt;/button&gt;
 * &lt;button ng-click=&quot;bool=false&quot;&gt;Fade Out!&lt;/button&gt;
 * &#x60;&#x60;&#x60;
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; The starting CSS styles for the enter animation &amp;#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&amp;#42; The finishing CSS styles for the enter animation &amp;#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * &#x60;&#x60;&#x60;
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what&#x27;s going on) two
 * generated CSS classes will be applied to the element; in the example above we have &#x60;.ng-enter&#x60; and &#x60;.ng-enter-active&#x60;. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case &#x60;.ng-enter&#x60;). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for &#x60;leave&#x60; and &#x60;move&#x60; (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; now the element will fade out before it is removed from the DOM &amp;#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * &#x60;&#x60;&#x60;
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &amp;#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * &#x60;&#x60;&#x60;
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via &#x60;ngClass&#x60;, &#x60;ngShow&#x60;, &#x60;ngHide&#x60; and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for &#x60;ngHide&#x60; then we place an animation on the &#x60;.ng-hide&#x60; CSS class:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-show=&quot;bool&quot; class=&quot;fade&quot;&gt;
 *   Show and hide me
 * &lt;/div&gt;
 * &lt;button ng-click=&quot;bool=true&quot;&gt;Toggle&lt;/button&gt;
 *
 * &lt;style&gt;
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * &lt;/style&gt;
 * &#x60;&#x60;&#x60;
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the &#x60;.ng-hide&#x60; class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-class=&quot;{on:onOff}&quot; class=&quot;highlight&quot;&gt;
 *   Highlight this box
 * &lt;/div&gt;
 * &lt;button ng-click=&quot;onOff=!onOff&quot;&gt;Toggle&lt;/button&gt;
 *
 * &lt;style&gt;
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * &lt;/style&gt;
 * &#x60;&#x60;&#x60;
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions &gt;=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * &#x60;&#x60;&#x60;css
 * .my-animation.ng-enter {
 *   /&amp;#42; standard transition code &amp;#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&amp;#42; this will have a 100ms delay between each successive leave animation &amp;#42;/
 *   transition-delay: 0.1s;
 *
 *   /&amp;#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &amp;#42;/
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&amp;#42; standard transition styles &amp;#42;/
 *   opacity:1;
 * }
 * &#x60;&#x60;&#x60;
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to &#x60;$animate&#x60; were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * &#x60;&#x60;&#x60;js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * &#x60;&#x60;&#x60;
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The &#x60;ng-animate&#x60; CSS class
 *
 * When ngAnimate is animating an element it will apply the &#x60;ng-animate&#x60; CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * &#x60;&#x60;&#x60;css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * &#x60;&#x60;&#x60;
 *
 * (Note that the &#x60;ng-animate&#x60; CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ### The &#x60;ng-[event]-prepare&#x60; class
 *
 * This is a special class that can be used to prevent unwanted flickering / flash of content before
 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
 * before the actual animation starts (after waiting for a $digest).
 * It is also only added for *structural* animations (&#x60;enter&#x60;, &#x60;move&#x60;, and &#x60;leave&#x60;).
 *
 * In practice, flickering can appear when nesting elements with structural animations such as &#x60;ngIf&#x60;
 * into elements that have class-based animations such as &#x60;ngClass&#x60;.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-class=&quot;{red: myProp}&quot;&gt;
 *   &lt;div ng-class=&quot;{blue: myProp}&quot;&gt;
 *     &lt;div class=&quot;message&quot; ng-if=&quot;myProp&quot;&gt;&lt;/div&gt;
 *   &lt;/div&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * It is possible that during the &#x60;enter&#x60; animation, the &#x60;.message&#x60; div will be briefly visible before it starts animating.
 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
 *
 * &#x60;&#x60;&#x60;css
 * .message.ng-enter-prepare {
 *   opacity: 0;
 * }
 *
 * &#x60;&#x60;&#x60;
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * &#x60;module.animation()&#x60; module function we can register the animation.
 *
 * Let&#x27;s see an example of a enter/leave animation using &#x60;ngRepeat&#x60;:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-repeat=&quot;item in items&quot; class=&quot;slide&quot;&gt;
 *   {{ item }}
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * See the **slide** CSS class? Let&#x27;s use that class to define an animation that we&#x27;ll structure in our module code by using &#x60;module.animation&#x60;:
 *
 * &#x60;&#x60;&#x60;js
 * myModule.animation(&#x27;.slide&#x27;, [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that angular
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like &#x60;ngClass&#x60;, &#x60;ngHide&#x60; and &#x60;ngShow&#x60; triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-class=&quot;color&quot; class=&quot;colorful&quot;&gt;
 *   this box is moody
 * &lt;/div&gt;
 * &lt;button ng-click=&quot;color=&#x27;red&#x27;&quot;&gt;Change to red&lt;/button&gt;
 * &lt;button ng-click=&quot;color=&#x27;blue&#x27;&quot;&gt;Change to blue&lt;/button&gt;
 * &lt;button ng-click=&quot;color=&#x27;green&#x27;&quot;&gt;Change to green&lt;/button&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;js
 * myModule.animation(&#x27;.colorful&#x27;, [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div ng-if=&quot;bool&quot; class=&quot;slide&quot;&gt;
 *   Slide in and out
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;js
 * myModule.animation(&#x27;.slide&#x27;, [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * &#x60;&#x60;&#x60;
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the &#x60;$animateCss&#x60; service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * &#x60;&#x60;&#x60;js
 * myModule.animation(&#x27;.slide&#x27;, [&#x27;$animateCss&#x27;, function($animateCss) {
 *   return {
 *     enter: function(element) {
*        // this will trigger &#x60;.slide.ng-enter&#x60; and &#x60;.slide.ng-enter-active&#x60;.
 *       return $animateCss(element, {
 *         event: &#x27;enter&#x27;,
 *         structural: true
 *       });
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don&#x27;t need to rely on a 3rd-party animation framework.
 *
 * The &#x60;$animateCss&#x60; service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into &#x60;$animateCss&#x60; directly:
 *
 * &#x60;&#x60;&#x60;js
 * myModule.animation(&#x27;.slide&#x27;, [&#x27;$animateCss&#x27;, function($animateCss) {
 *   return {
 *     enter: function(element) {
 *       return $animateCss(element, {
 *         event: &#x27;enter&#x27;,
 *         structural: true,
 *         addClass: &#x27;maroon-setting&#x27;,
 *         from: { height:0 },
 *         to: { height: 200 }
 *       });
 *     }
 *   }
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; the transition tells ngAnimate to make the animation happen &amp;#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&amp;#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &amp;#42;/
 * .maroon-setting { background:red; }
 * &#x60;&#x60;&#x60;
 *
 * And &#x60;$animateCss&#x60; will figure out the rest. Just make sure to have the &#x60;done()&#x60; callback fire the &#x60;doneFn&#x60; function to signal when the animation is over.
 *
 * To learn more about what&#x27;s possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via &#x60;ng-animate-ref&#x60;)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called &#x60;ng-animate-ref&#x60;.
 *
 * Let&#x27;s say for example we have two views that are managed by &#x60;ng-view&#x60; and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * &#x60;ng-animate-ref&#x60; attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;!-- index.html --&gt;
 * &lt;div ng-view class=&quot;view-animation&quot;&gt;
 * &lt;/div&gt;
 *
 * &lt;!-- home.html --&gt;
 * &lt;a href=&quot;#/banner-page&quot;&gt;
 *   &lt;img src=&quot;./banner.jpg&quot; class=&quot;banner&quot; ng-animate-ref=&quot;banner&quot;&gt;
 * &lt;/a&gt;
 *
 * &lt;!-- banner-page.html --&gt;
 * &lt;img src=&quot;./banner.jpg&quot; class=&quot;banner&quot; ng-animate-ref=&quot;banner&quot;&gt;
 * &#x60;&#x60;&#x60;
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called &#x60;ng-anchor&#x60; will be added to the transported element.
 *
 * We can now attach a transition onto the &#x60;.banner.ng-anchor&#x60; CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * &#x60;&#x60;&#x60;css
 * .banner.ng-anchor {
 *   /&amp;#42; this animation will last for 1 second since there are
 *          two phases to the animation (an &#x60;in&#x60; and an &#x60;out&#x60; phase) &amp;#42;/
 *   transition:0.5s linear all;
 * }
 * &#x60;&#x60;&#x60;
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn&#x27;t be possible since the new view would be inserted right away).
 *
 * &#x60;&#x60;&#x60;css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * &#x60;&#x60;&#x60;
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an &#x60;out&#x60; and an &#x60;in&#x60; stage. The &#x60;out&#x60; stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the &#x60;in&#x60; stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via &#x60;ng-anchor-out&#x60; and &#x60;ng-anchor-in&#x60;.
 *
 * &#x60;&#x60;&#x60;css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&amp;#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &amp;#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * &#x60;&#x60;&#x60;
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  &lt;example module=&quot;anchoringExample&quot;
           name=&quot;anchoringExample&quot;
           id=&quot;anchoringExample&quot;
           deps=&quot;angular-animate.js;angular-route.js&quot;
           animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      &lt;a href=&quot;#/&quot;&gt;Home&lt;/a&gt;
      &lt;hr /&gt;
      &lt;div class=&quot;view-container&quot;&gt;
        &lt;div ng-view class=&quot;view&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;script.js&quot;&gt;
      angular.module(&#x27;anchoringExample&#x27;, [&#x27;ngAnimate&#x27;, &#x27;ngRoute&#x27;])
        .config([&#x27;$routeProvider&#x27;, function($routeProvider) {
          $routeProvider.when(&#x27;/&#x27;, {
            templateUrl: &#x27;home.html&#x27;,
            controller: &#x27;HomeController as home&#x27;
          });
          $routeProvider.when(&#x27;/profile/:id&#x27;, {
            templateUrl: &#x27;profile.html&#x27;,
            controller: &#x27;ProfileController as profile&#x27;
          });
        }])
        .run([&#x27;$rootScope&#x27;, function($rootScope) {
          $rootScope.records = [
            { id:1, title: &quot;Miss Beulah Roob&quot; },
            { id:2, title: &quot;Trent Morissette&quot; },
            { id:3, title: &quot;Miss Ava Pouros&quot; },
            { id:4, title: &quot;Rod Pouros&quot; },
            { id:5, title: &quot;Abdul Rice&quot; },
            { id:6, title: &quot;Laurie Rutherford Sr.&quot; },
            { id:7, title: &quot;Nakia McLaughlin&quot; },
            { id:8, title: &quot;Jordon Blanda DVM&quot; },
            { id:9, title: &quot;Rhoda Hand&quot; },
            { id:10, title: &quot;Alexandrea Sauer&quot; }
          ];
        }])
        .controller(&#x27;HomeController&#x27;, [function() {
          //empty
        }])
        .controller(&#x27;ProfileController&#x27;, [&#x27;$rootScope&#x27;, &#x27;$routeParams&#x27;, function($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    &lt;/file&gt;
    &lt;file name=&quot;home.html&quot;&gt;
      &lt;h2&gt;Welcome to the home page&lt;/h1&gt;
      &lt;p&gt;Please click on an element&lt;/p&gt;
      &lt;a class=&quot;record&quot;
         ng-href=&quot;#/profile/{{ record.id }}&quot;
         ng-animate-ref=&quot;{{ record.id }}&quot;
         ng-repeat=&quot;record in records&quot;&gt;
        {{ record.title }}
      &lt;/a&gt;
    &lt;/file&gt;
    &lt;file name=&quot;profile.html&quot;&gt;
      &lt;div class=&quot;profile record&quot; ng-animate-ref=&quot;{{ profile.id }}&quot;&gt;
        {{ profile.title }}
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container &gt; .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    &lt;/file&gt;
  &lt;/example&gt;
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the &#x60;out&#x60; and &#x60;in&#x60; animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of &#x60;.ng-animate-shim&#x60; will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: &#x60;visibility:hidden&#x60;). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the &#x60;&lt;html&gt;&#x60; element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we&#x27;ve explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
 * By injecting the &#x60;$animate&#x60; service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let&#x27;s
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * &#x60;&#x60;&#x60;html
 * &lt;greeting-box active=&quot;onOrOff&quot;&gt;Hi there&lt;/greeting-box&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;js
 * ngModule.directive(&#x27;greetingBox&#x27;, [&#x27;$animate&#x27;, function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe(&#x27;active&#x27;, function(value) {
 *       value ? $animate.addClass(element, &#x27;on&#x27;) : $animate.removeClass(element, &#x27;on&#x27;);
 *     });
 *   });
 * }]);
 * &#x60;&#x60;&#x60;
 *
 * Now the &#x60;on&#x60; CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; normally we would create a CSS class to reference on the element &amp;#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * &#x60;&#x60;&#x60;
 *
 * The &#x60;$animate&#x60; service contains a variety of other methods like &#x60;enter&#x60;, &#x60;leave&#x60;, &#x60;animate&#x60; and &#x60;setClass&#x60;. To learn more about what&#x27;s
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ### Preventing Collisions With Third Party Libraries
 *
 * Some third-party frameworks place animation duration defaults across many element or className
 * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which
 * is expecting actual animations on these elements and has to wait for their completion.
 *
 * You can prevent this unwanted behavior by using a prefix on all your animation classes:
 *
 * &#x60;&#x60;&#x60;css
 * /&amp;#42; prefixed with animate- &amp;#42;/
 * .animate-fade-add.animate-fade-add-active {
 *   transition:1s linear all;
 *   opacity:0;
 * }
 * &#x60;&#x60;&#x60;
 *
 * You then configure &#x60;$animate&#x60; to enforce this prefix:
 *
 * &#x60;&#x60;&#x60;js
 * $animateProvider.classNameFilter(/animate-/);
 * &#x60;&#x60;&#x60;
 *
 * This also may provide your application with a speed boost since only specific elements containing CSS class prefix
 * will be evaluated for animation when any DOM changes occur in the application.
 *
 * ## Callbacks and Promises
 *
 * When &#x60;$animate&#x60; is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * &#x60;&#x60;&#x60;js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * &#x60;&#x60;&#x60;
 *
 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using &#x60;$scope.$apply(...)&#x60;. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the &#x60;$animate&#x60; service. Let&#x27;s say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * &#x60;&#x60;&#x60;js
 * ngModule.controller(&#x27;HomePageController&#x27;, [&#x27;$animate&#x27;, function($animate) {
 *   $animate.on(&#x27;enter&#x27;, ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * &#x60;&#x60;&#x60;
 *
 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
 */

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate &#x60;$animate&#x60; service documentation is the same for the core &#x60;$animate&#x60; service.
 *
 * Click here {@link ng.$animate to learn more about animations with &#x60;$animate&#x60;}.
 */
angular.module(&#x27;ngAnimate&#x27;, [])
  .directive(&#x27;ngAnimateSwap&#x27;, ngAnimateSwapDirective)

  .directive(&#x27;ngAnimateChildren&#x27;, $$AnimateChildrenDirective)
  .factory(&#x27;$$rAFScheduler&#x27;, $$rAFSchedulerFactory)

  .provider(&#x27;$$animateQueue&#x27;, $$AnimateQueueProvider)
  .provider(&#x27;$$animation&#x27;, $$AnimationProvider)

  .provider(&#x27;$animateCss&#x27;, $AnimateCssProvider)
  .provider(&#x27;$$animateCssDriver&#x27;, $$AnimateCssDriverProvider)

  .provider(&#x27;$$animateJs&#x27;, $$AnimateJsProvider)
  .provider(&#x27;$$animateJsDriver&#x27;, $$AnimateJsDriverProvider);


})(window, window.angular);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
