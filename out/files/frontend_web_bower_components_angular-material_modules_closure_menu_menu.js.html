<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>frontend\web\bower_components\angular-material\modules\closure\menu\menu.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController.html">personAutoController</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: frontend\web\bower_components\angular-material\modules\closure\menu\menu.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.6
 */
goog.provide(&#x27;ng.material.components.menu&#x27;);
goog.require(&#x27;ng.material.components.backdrop&#x27;);
goog.require(&#x27;ng.material.core&#x27;);
/**
 * @ngdoc module
 * @name material.components.menu
 */

angular.module(&#x27;material.components.menu&#x27;, [
  &#x27;material.core&#x27;,
  &#x27;material.components.backdrop&#x27;
]);



angular
    .module(&#x27;material.components.menu&#x27;)
    .controller(&#x27;mdMenuCtrl&#x27;, MenuController);

/**
 * ngInject
 */
function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {

  var menuContainer;
  var self = this;
  var triggerElement;

  this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;

  /**
   * Called by our linking fn to provide access to the menu-content
   * element removed during link
   */
  this.init = function init(setMenuContainer, opts) {
    opts = opts || {};
    menuContainer = setMenuContainer;
    // Default element for ARIA attributes has the ngClick or ngMouseenter expression
    triggerElement = $element[0].querySelector(&#x27;[ng-click],[ng-mouseenter]&#x27;);
    triggerElement.setAttribute(&#x27;aria-expanded&#x27;, &#x27;false&#x27;);

    this.isInMenuBar = opts.isInMenuBar;
    this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll(&#x27;.md-nested-menu&#x27;));

    menuContainer.on(&#x27;$mdInterimElementRemove&#x27;, function() {
      self.isOpen = false;
    });

    var menuContainerId = &#x27;menu_container_&#x27; + $mdUtil.nextUid();
    menuContainer.attr(&#x27;id&#x27;, menuContainerId);
    angular.element(triggerElement).attr({
      &#x27;aria-owns&#x27;: menuContainerId,
      &#x27;aria-haspopup&#x27;: &#x27;true&#x27;
    });

    $scope.$on(&#x27;$destroy&#x27;, this.disableHoverListener);
    menuContainer.on(&#x27;$destroy&#x27;, function() {
      $mdMenu.destroy();
    });
  };

  var openMenuTimeout, menuItems, deregisterScopeListeners = [];
  this.enableHoverListener = function() {
    deregisterScopeListeners.push($rootScope.$on(&#x27;$mdMenuOpen&#x27;, function(event, el) {
      if (menuContainer[0].contains(el[0])) {
        self.currentlyOpenMenu = el.controller(&#x27;mdMenu&#x27;);
        self.isAlreadyOpening = false;
        self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
      }
    }));
    deregisterScopeListeners.push($rootScope.$on(&#x27;$mdMenuClose&#x27;, function(event, el) {
      if (menuContainer[0].contains(el[0])) {
        self.currentlyOpenMenu = undefined;
      }
    }));
    menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
    menuItems.on(&#x27;mouseenter&#x27;, self.handleMenuItemHover);
    menuItems.on(&#x27;mouseleave&#x27;, self.handleMenuItemMouseLeave);
  };

  this.disableHoverListener = function() {
    while (deregisterScopeListeners.length) {
      deregisterScopeListeners.shift()();
    }
    menuItems &amp;&amp; menuItems.off(&#x27;mouseenter&#x27;, self.handleMenuItemHover);
    menuItems &amp;&amp; menuItems.off(&#x27;mouseleave&#x27;, self.handleMenuMouseLeave);
  };

  this.handleMenuItemHover = function(event) {
    if (self.isAlreadyOpening) return;
    var nestedMenu = (
      event.target.querySelector(&#x27;md-menu&#x27;)
        || $mdUtil.getClosest(event.target, &#x27;MD-MENU&#x27;)
    );
    openMenuTimeout = $timeout(function() {
      if (nestedMenu) {
        nestedMenu = angular.element(nestedMenu).controller(&#x27;mdMenu&#x27;);
      }

      if (self.currentlyOpenMenu &amp;&amp; self.currentlyOpenMenu != nestedMenu) {
        var closeTo = self.nestLevel + 1;
        self.currentlyOpenMenu.close(true, { closeTo: closeTo });
      } else if (nestedMenu &amp;&amp; !nestedMenu.isOpen &amp;&amp; nestedMenu.open) {
        self.isAlreadyOpening = true;
        nestedMenu.open();
      }
    }, nestedMenu ? 100 : 250);
    var focusableTarget = event.currentTarget.querySelector(&#x27;.md-button:not([disabled])&#x27;);
    focusableTarget &amp;&amp; focusableTarget.focus();
  };

  this.handleMenuItemMouseLeave = function() {
    if (openMenuTimeout) {
      $timeout.cancel(openMenuTimeout);
      openMenuTimeout = undefined;
    }
  };


  /**
   * Uses the $mdMenu interim element service to open the menu contents
   */
  this.open = function openMenu(ev) {
    ev &amp;&amp; ev.stopPropagation();
    ev &amp;&amp; ev.preventDefault();
    if (self.isOpen) return;
    self.enableHoverListener();
    self.isOpen = true;
    triggerElement = triggerElement || (ev ? ev.target : $element[0]);
    triggerElement.setAttribute(&#x27;aria-expanded&#x27;, &#x27;true&#x27;);
    $scope.$emit(&#x27;$mdMenuOpen&#x27;, $element);
    $mdMenu.show({
      scope: $scope,
      mdMenuCtrl: self,
      nestLevel: self.nestLevel,
      element: menuContainer,
      target: triggerElement,
      preserveElement: true,
      parent: &#x27;body&#x27;
    }).finally(function() {
      triggerElement.setAttribute(&#x27;aria-expanded&#x27;, &#x27;false&#x27;);
      self.disableHoverListener();
    });
  };

  // Expose a open function to the child scope for html to use
  $scope.$mdOpenMenu = this.open;

  $scope.$watch(function() { return self.isOpen; }, function(isOpen) {
    if (isOpen) {
      menuContainer.attr(&#x27;aria-hidden&#x27;, &#x27;false&#x27;);
      $element[0].classList.add(&#x27;md-open&#x27;);
      angular.forEach(self.nestedMenus, function(el) {
        el.classList.remove(&#x27;md-open&#x27;);
      });
    } else {
      menuContainer.attr(&#x27;aria-hidden&#x27;, &#x27;true&#x27;);
      $element[0].classList.remove(&#x27;md-open&#x27;);
    }
    $scope.$mdMenuIsOpen = self.isOpen;
  });

  this.focusMenuContainer = function focusMenuContainer() {
    var focusTarget = menuContainer[0].querySelector(&#x27;[md-menu-focus-target]&#x27;);
    if (!focusTarget) focusTarget = menuContainer[0].querySelector(&#x27;.md-button&#x27;);
    focusTarget.focus();
  };

  this.registerContainerProxy = function registerContainerProxy(handler) {
    this.containerProxy = handler;
  };

  this.triggerContainerProxy = function triggerContainerProxy(ev) {
    this.containerProxy &amp;&amp; this.containerProxy(ev);
  };

  this.destroy = function() {
    return self.isOpen ? $mdMenu.destroy() : $q.when(false);
  };

  // Use the $mdMenu interim element service to close the menu contents
  this.close = function closeMenu(skipFocus, closeOpts) {
    if ( !self.isOpen ) return;
    self.isOpen = false;

    var eventDetails = angular.extend({}, closeOpts, { skipFocus: skipFocus });
    $scope.$emit(&#x27;$mdMenuClose&#x27;, $element, eventDetails);
    $mdMenu.hide(null, closeOpts);

    if (!skipFocus) {
      var el = self.restoreFocusTo || $element.find(&#x27;button&#x27;)[0];
      if (el instanceof angular.element) el = el[0];
      if (el) el.focus();
    }
  };

  /**
   * Build a nice object out of our string attribute which specifies the
   * target mode for left and top positioning
   */
  this.positionMode = function positionMode() {
    var attachment = ($attrs.mdPositionMode || &#x27;target&#x27;).split(&#x27; &#x27;);

    // If attachment is a single item, duplicate it for our second value.
    // ie. &#x27;target&#x27; -&gt; &#x27;target target&#x27;
    if (attachment.length == 1) {
      attachment.push(attachment[0]);
    }

    return {
      left: attachment[0],
      top: attachment[1]
    };
  };

  /**
   * Build a nice object out of our string attribute which specifies
   * the offset of top and left in pixels.
   */
  this.offsets = function offsets() {
    var position = ($attrs.mdOffset || &#x27;0 0&#x27;).split(&#x27; &#x27;).map(parseFloat);
    if (position.length == 2) {
      return {
        left: position[0],
        top: position[1]
      };
    } else if (position.length == 1) {
      return {
        top: position[0],
        left: position[0]
      };
    } else {
      throw Error(&#x27;Invalid offsets specified. Please follow format &lt;x, y&gt; or &lt;n&gt;&#x27;);
    }
  };
}
MenuController.$inject = [&quot;$mdMenu&quot;, &quot;$attrs&quot;, &quot;$element&quot;, &quot;$scope&quot;, &quot;$mdUtil&quot;, &quot;$timeout&quot;, &quot;$rootScope&quot;, &quot;$q&quot;];

/**
 * @ngdoc directive
 * @name mdMenu
 * @module material.components.menu
 * @restrict E
 * @description
 *
 * Menus are elements that open when clicked. They are useful for displaying
 * additional options within the context of an action.
 *
 * Every &#x60;md-menu&#x60; must specify exactly two child elements. The first element is what is
 * left in the DOM and is used to open the menu. This element is called the trigger element.
 * The trigger element&#x27;s scope has access to &#x60;$mdOpenMenu($event)&#x60;
 * which it may call to open the menu. By passing $event as argument, the
 * corresponding event is stopped from propagating up the DOM-tree.
 *
 * The second element is the &#x60;md-menu-content&#x60; element which represents the
 * contents of the menu when it is open. Typically this will contain &#x60;md-menu-item&#x60;s,
 * but you can do custom content as well.
 *
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-menu&gt;
 *  &lt;!-- Trigger element is a md-button with an icon --&gt;
 *  &lt;md-button ng-click=&quot;$mdOpenMenu($event)&quot; class=&quot;md-icon-button&quot; aria-label=&quot;Open sample menu&quot;&gt;
 *    &lt;md-icon md-svg-icon=&quot;call:phone&quot;&gt;&lt;/md-icon&gt;
 *  &lt;/md-button&gt;
 *  &lt;md-menu-content&gt;
 *    &lt;md-menu-item&gt;&lt;md-button ng-click=&quot;doSomething()&quot;&gt;Do Something&lt;/md-button&gt;&lt;/md-menu-item&gt;
 *  &lt;/md-menu-content&gt;
 * &lt;/md-menu&gt;
 * &lt;/hljs&gt;

 * ## Sizing Menus
 *
 * The width of the menu when it is open may be specified by specifying a &#x60;width&#x60;
 * attribute on the &#x60;md-menu-content&#x60; element.
 * See the [Material Design Spec](http://www.google.com/design/spec/components/menus.html#menus-specs)
 * for more information.
 *
 *
 * ## Aligning Menus
 *
 * When a menu opens, it is important that the content aligns with the trigger element.
 * Failure to align menus can result in jarring experiences for users as content
 * suddenly shifts. To help with this, &#x60;md-menu&#x60; provides serveral APIs to help
 * with alignment.
 *
 * ### Target Mode
 *
 * By default, &#x60;md-menu&#x60; will attempt to align the &#x60;md-menu-content&#x60; by aligning
 * designated child elements in both the trigger and the menu content.
 *
 * To specify the alignment element in the &#x60;trigger&#x60; you can use the &#x60;md-menu-origin&#x60;
 * attribute on a child element. If no &#x60;md-menu-origin&#x60; is specified, the &#x60;md-menu&#x60;
 * will be used as the origin element.
 *
 * Similarly, the &#x60;md-menu-content&#x60; may specify a &#x60;md-menu-align-target&#x60; for a
 * &#x60;md-menu-item&#x60; to specify the node that it should try and align with.
 *
 * In this example code, we specify an icon to be our origin element, and an
 * icon in our menu content to be our alignment target. This ensures that both
 * icons are aligned when the menu opens.
 *
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-menu&gt;
 *  &lt;md-button ng-click=&quot;$mdOpenMenu($event)&quot; class=&quot;md-icon-button&quot; aria-label=&quot;Open some menu&quot;&gt;
 *    &lt;md-icon md-menu-origin md-svg-icon=&quot;call:phone&quot;&gt;&lt;/md-icon&gt;
 *  &lt;/md-button&gt;
 *  &lt;md-menu-content&gt;
 *    &lt;md-menu-item&gt;
 *      &lt;md-button ng-click=&quot;doSomething()&quot; aria-label=&quot;Do something&quot;&gt;
 *        &lt;md-icon md-menu-align-target md-svg-icon=&quot;call:phone&quot;&gt;&lt;/md-icon&gt;
 *        Do Something
 *      &lt;/md-button&gt;
 *    &lt;/md-menu-item&gt;
 *  &lt;/md-menu-content&gt;
 * &lt;/md-menu&gt;
 * &lt;/hljs&gt;
 *
 * Sometimes we want to specify alignment on the right side of an element, for example
 * if we have a menu on the right side a toolbar, we want to right align our menu content.
 *
 * We can specify the origin by using the &#x60;md-position-mode&#x60; attribute on both
 * the &#x60;x&#x60; and &#x60;y&#x60; axis. Right now only the &#x60;x-axis&#x60; has more than one option.
 * You may specify the default mode of &#x60;target target&#x60; or
 * &#x60;target-right target&#x60; to specify a right-oriented alignment target. See the
 * position section of the demos for more examples.
 *
 * ### Menu Offsets
 *
 * It is sometimes unavoidable to need to have a deeper level of control for
 * the positioning of a menu to ensure perfect alignment. &#x60;md-menu&#x60; provides
 * the &#x60;md-offset&#x60; attribute to allow pixel level specificty of adjusting the
 * exact positioning.
 *
 * This offset is provided in the format of &#x60;x y&#x60; or &#x60;n&#x60; where &#x60;n&#x60; will be used
 * in both the &#x60;x&#x60; and &#x60;y&#x60; axis.
 *
 * For example, to move a menu by &#x60;2px&#x60; from the top, we can use:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-menu md-offset=&quot;2 0&quot;&gt;
 *   &lt;!-- menu-content --&gt;
 * &lt;/md-menu&gt;
 * &lt;/hljs&gt;

 * ### Preventing close
 *
 * Sometimes you would like to be able to click on a menu item without having the menu
 * close. To do this, ngMaterial exposes the &#x60;md-prevent-menu-close&#x60; attribute which
 * can be added to a button inside a menu to stop the menu from automatically closing.
 * You can then close the menu programatically by injecting &#x60;$mdMenu&#x60; and calling 
 * &#x60;$mdMenu.hide()&#x60;.
 *
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-menu-item&gt;
 *   &lt;md-button ng-click=&quot;doSomething()&quot; aria-label=&quot;Do something&quot; md-prevent-menu-close=&quot;md-prevent-menu-close&quot;&gt;
 *     &lt;md-icon md-menu-align-target md-svg-icon=&quot;call:phone&quot;&gt;&lt;/md-icon&gt;
 *     Do Something
 *   &lt;/md-button&gt;
 * &lt;/md-menu-item&gt;
 * &lt;/hljs&gt;
 *
 * @usage
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-menu&gt;
 *  &lt;md-button ng-click=&quot;$mdOpenMenu($event)&quot; class=&quot;md-icon-button&quot;&gt;
 *    &lt;md-icon md-svg-icon=&quot;call:phone&quot;&gt;&lt;/md-icon&gt;
 *  &lt;/md-button&gt;
 *  &lt;md-menu-content&gt;
 *    &lt;md-menu-item&gt;&lt;md-button ng-click=&quot;doSomething()&quot;&gt;Do Something&lt;/md-button&gt;&lt;/md-menu-item&gt;
 *  &lt;/md-menu-content&gt;
 * &lt;/md-menu&gt;
 * &lt;/hljs&gt;
 *
 * @param {string} md-position-mode The position mode in the form of
 *           &#x60;x&#x60;, &#x60;y&#x60;. Default value is &#x60;target&#x60;,&#x60;target&#x60;. Right now the &#x60;x&#x60; axis
 *           also suppports &#x60;target-right&#x60;.
 * @param {string} md-offset An offset to apply to the dropdown after positioning
 *           &#x60;x&#x60;, &#x60;y&#x60;. Default value is &#x60;0&#x60;,&#x60;0&#x60;.
 *
 */

angular
    .module(&#x27;material.components.menu&#x27;)
    .directive(&#x27;mdMenu&#x27;, MenuDirective);

/**
 * ngInject
 */
function MenuDirective($mdUtil) {
  var INVALID_PREFIX = &#x27;Invalid HTML for md-menu: &#x27;;
  return {
    restrict: &#x27;E&#x27;,
    require: [&#x27;mdMenu&#x27;, &#x27;?^mdMenuBar&#x27;],
    controller: &#x27;mdMenuCtrl&#x27;, // empty function to be built by link
    scope: true,
    compile: compile
  };

  function compile(templateElement) {
    templateElement.addClass(&#x27;md-menu&#x27;);
    var triggerElement = templateElement.children()[0];
    if (!triggerElement.hasAttribute(&#x27;ng-click&#x27;)) {
      triggerElement = triggerElement.querySelector(&#x27;[ng-click],[ng-mouseenter]&#x27;) || triggerElement;
    }
    if (triggerElement &amp;&amp; (
      triggerElement.nodeName == &#x27;MD-BUTTON&#x27; ||
      triggerElement.nodeName == &#x27;BUTTON&#x27;
    ) &amp;&amp; !triggerElement.hasAttribute(&#x27;type&#x27;)) {
      triggerElement.setAttribute(&#x27;type&#x27;, &#x27;button&#x27;);
    }

    if (templateElement.children().length != 2) {
      throw Error(INVALID_PREFIX + &#x27;Expected two children elements.&#x27;);
    }

    // Default element for ARIA attributes has the ngClick or ngMouseenter expression
    triggerElement &amp;&amp; triggerElement.setAttribute(&#x27;aria-haspopup&#x27;, &#x27;true&#x27;);

    var nestedMenus = templateElement[0].querySelectorAll(&#x27;md-menu&#x27;);
    var nestingDepth = parseInt(templateElement[0].getAttribute(&#x27;md-nest-level&#x27;), 10) || 0;
    if (nestedMenus) {
      angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
        if (!menuEl.hasAttribute(&#x27;md-position-mode&#x27;)) {
          menuEl.setAttribute(&#x27;md-position-mode&#x27;, &#x27;cascade&#x27;);
        }
        menuEl.classList.add(&#x27;md-nested-menu&#x27;);
        menuEl.setAttribute(&#x27;md-nest-level&#x27;, nestingDepth + 1);
      });
    }
    return link;
  }

  function link(scope, element, attrs, ctrls) {
    var mdMenuCtrl = ctrls[0];
    var isInMenuBar = ctrls[1] != undefined;
    // Move everything into a md-menu-container and pass it to the controller
    var menuContainer = angular.element(
      &#x27;&lt;div class=&quot;md-open-menu-container md-whiteframe-z2&quot;&gt;&lt;/div&gt;&#x27;
    );
    var menuContents = element.children()[1];
    if (!menuContents.hasAttribute(&#x27;role&#x27;)) {
      menuContents.setAttribute(&#x27;role&#x27;, &#x27;menu&#x27;);
    }
    menuContainer.append(menuContents);

    element.on(&#x27;$destroy&#x27;, function() {
      menuContainer.remove();
    });

    element.append(menuContainer);
    menuContainer[0].style.display = &#x27;none&#x27;;
    mdMenuCtrl.init(menuContainer, { isInMenuBar: isInMenuBar });
  }
}
MenuDirective.$inject = [&quot;$mdUtil&quot;];

angular
  .module(&#x27;material.components.menu&#x27;)
  .provider(&#x27;$mdMenu&#x27;, MenuProvider);

/*
 * Interim element provider for the menu.
 * Handles behavior for a menu while it is open, including:
 *    - handling animating the menu opening/closing
 *    - handling key/mouse events on the menu element
 *    - handling enabling/disabling scroll while the menu is open
 *    - handling redrawing during resizes and orientation changes
 *
 */

function MenuProvider($$interimElementProvider) {
  var MENU_EDGE_MARGIN = 8;

  menuDefaultOptions.$inject = [&quot;$mdUtil&quot;, &quot;$mdTheming&quot;, &quot;$mdConstant&quot;, &quot;$document&quot;, &quot;$window&quot;, &quot;$q&quot;, &quot;$$rAF&quot;, &quot;$animateCss&quot;, &quot;$animate&quot;];
  return $$interimElementProvider(&#x27;$mdMenu&#x27;)
    .setDefaults({
      methods: [&#x27;target&#x27;],
      options: menuDefaultOptions
    });

  /* ngInject */
  function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
    var animator = $mdUtil.dom.animator;

    return {
      parent: &#x27;body&#x27;,
      onShow: onShow,
      onRemove: onRemove,
      hasBackdrop: true,
      disableParentScroll: true,
      skipCompile: true,
      preserveScope: true,
      skipHide: true,
      themable: true
    };

    /**
     * Show modal backdrop element...
     * @returns {function(): void} A function that removes this backdrop
     */
    function showBackdrop(scope, element, options) {
      if (options.nestLevel) return angular.noop;

      // If we are not within a dialog...
      if (options.disableParentScroll &amp;&amp; !$mdUtil.getClosest(options.target, &#x27;MD-DIALOG&#x27;)) {
        // !! DO this before creating the backdrop; since disableScrollAround()
        //    configures the scroll offset; which is used by mdBackDrop postLink()
        options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
      } else {
        options.disableParentScroll = false;
      }

      if (options.hasBackdrop) {
        options.backdrop = $mdUtil.createBackdrop(scope, &quot;md-menu-backdrop md-click-catcher&quot;);

        $animate.enter(options.backdrop, $document[0].body);
      }

      /**
       * Hide and destroys the backdrop created by showBackdrop()
       */
      return function hideBackdrop() {
        if (options.backdrop) options.backdrop.remove();
        if (options.disableParentScroll) options.restoreScroll();
      };
    }

    /**
     * Removing the menu element from the DOM and remove all associated event listeners
     * and backdrop
     */
    function onRemove(scope, element, opts) {
      opts.cleanupInteraction();
      opts.cleanupResizing();
      opts.hideBackdrop();

      // For navigation $destroy events, do a quick, non-animated removal,
      // but for normal closes (from clicks, etc) animate the removal

      return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then( detachAndClean );

      /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
      function animateRemoval() {
        return $animateCss(element, {addClass: &#x27;md-leave&#x27;}).start();
      }

      /**
       * Detach the element
       */
      function detachAndClean() {
        element.removeClass(&#x27;md-active&#x27;);
        detachElement(element, opts);
        opts.alreadyOpen = false;
      }

    }

    /**
     * Inserts and configures the staged Menu element into the DOM, positioning it,
     * and wiring up various interaction events
     */
    function onShow(scope, element, opts) {
      sanitizeAndConfigure(opts);

      // Wire up theming on our menu element
      $mdTheming.inherit(opts.menuContentEl, opts.target);

      // Register various listeners to move menu on resize/orientation change
      opts.cleanupResizing = startRepositioningOnResize();
      opts.hideBackdrop = showBackdrop(scope, element, opts);

      // Return the promise for when our menu is done animating in
      return showMenu()
        .then(function(response) {
          opts.alreadyOpen = true;
          opts.cleanupInteraction = activateInteraction();
          return response;
        });

      /**
       * Place the menu into the DOM and call positioning related functions
       */
      function showMenu() {
        opts.parent.append(element);
        element[0].style.display = &#x27;&#x27;;

        return $q(function(resolve) {
          var position = calculateMenuPosition(element, opts);

          element.removeClass(&#x27;md-leave&#x27;);

          // Animate the menu scaling, and opacity [from its position origin (default == top-left)]
          // to normal scale.
          $animateCss(element, {
            addClass: &#x27;md-active&#x27;,
            from: animator.toCss(position),
            to: animator.toCss({transform: &#x27;&#x27;})
          })
          .start()
          .then(resolve);

        });
      }

      /**
       * Check for valid opts and set some sane defaults
       */
      function sanitizeAndConfigure() {
        if (!opts.target) {
          throw Error(
            &#x27;$mdMenu.show() expected a target to animate from in options.target&#x27;
          );
        }
        angular.extend(opts, {
          alreadyOpen: false,
          isRemoved: false,
          target: angular.element(opts.target), //make sure it&#x27;s not a naked dom node
          parent: angular.element(opts.parent),
          menuContentEl: angular.element(element[0].querySelector(&#x27;md-menu-content&#x27;))
        });
      }

      /**
       * Configure various resize listeners for screen changes
       */
      function startRepositioningOnResize() {

        var repositionMenu = (function(target, options) {
          return $$rAF.throttle(function() {
            if (opts.isRemoved) return;
            var position = calculateMenuPosition(target, options);

            target.css(animator.toCss(position));
          });
        })(element, opts);

        $window.addEventListener(&#x27;resize&#x27;, repositionMenu);
        $window.addEventListener(&#x27;orientationchange&#x27;, repositionMenu);

        return function stopRepositioningOnResize() {

          // Disable resizing handlers
          $window.removeEventListener(&#x27;resize&#x27;, repositionMenu);
          $window.removeEventListener(&#x27;orientationchange&#x27;, repositionMenu);

        }
      }

      /**
       * Activate interaction on the menu. Wire up keyboard listerns for
       * clicks, keypresses, backdrop closing, etc.
       */
      function activateInteraction() {
        element.addClass(&#x27;md-clickable&#x27;);

        // close on backdrop click
        if (opts.backdrop) opts.backdrop.on(&#x27;click&#x27;, onBackdropClick);

        // Wire up keyboard listeners.
        // - Close on escape,
        // - focus next item on down arrow,
        // - focus prev item on up
        opts.menuContentEl.on(&#x27;keydown&#x27;, onMenuKeyDown);
        opts.menuContentEl[0].addEventListener(&#x27;click&#x27;, captureClickListener, true);

        // kick off initial focus in the menu on the first element
        var focusTarget = opts.menuContentEl[0].querySelector(&#x27;[md-menu-focus-target]&#x27;);
        if ( !focusTarget ) {
          var firstChild = opts.menuContentEl[0].firstElementChild;

          focusTarget = firstChild &amp;&amp; (firstChild.querySelector(&#x27;.md-button:not([disabled])&#x27;) || firstChild.firstElementChild);
        }

        focusTarget &amp;&amp; focusTarget.focus();

        return function cleanupInteraction() {
          element.removeClass(&#x27;md-clickable&#x27;);
          if (opts.backdrop) opts.backdrop.off(&#x27;click&#x27;, onBackdropClick);
          opts.menuContentEl.off(&#x27;keydown&#x27;, onMenuKeyDown);
          opts.menuContentEl[0].removeEventListener(&#x27;click&#x27;, captureClickListener, true);
        };

        // ************************************
        // internal functions
        // ************************************

        function onMenuKeyDown(ev) {
          var handled;
          switch (ev.keyCode) {
            case $mdConstant.KEY_CODE.ESCAPE:
              opts.mdMenuCtrl.close(false, { closeAll: true });
              handled = true;
              break;
            case $mdConstant.KEY_CODE.UP_ARROW:
              if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) &amp;&amp; !opts.nestLevel) {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.DOWN_ARROW:
              if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) &amp;&amp; !opts.nestLevel) {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.LEFT_ARROW:
              if (opts.nestLevel) {
                opts.mdMenuCtrl.close();
              } else {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.RIGHT_ARROW:
              var parentMenu = $mdUtil.getClosest(ev.target, &#x27;MD-MENU&#x27;);
              if (parentMenu &amp;&amp; parentMenu != opts.parent[0]) {
                ev.target.click();
              } else {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
          }
          if (handled) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
        }

        function onBackdropClick(e) {
          e.preventDefault();
          e.stopPropagation();
          scope.$apply(function() {
            opts.mdMenuCtrl.close(true, { closeAll: true });
          });
        }

        // Close menu on menu item click, if said menu-item is not disabled
        function captureClickListener(e) {
          var target = e.target;
          // Traverse up the event until we get to the menuContentEl to see if
          // there is an ng-click and that the ng-click is not disabled
          do {
            if (target == opts.menuContentEl[0]) return;
            if ((hasAnyAttribute(target, [&#x27;ng-click&#x27;, &#x27;ng-href&#x27;, &#x27;ui-sref&#x27;]) ||
                target.nodeName == &#x27;BUTTON&#x27; || target.nodeName == &#x27;MD-BUTTON&#x27;) &amp;&amp; !hasAnyAttribute(target, [&#x27;md-prevent-menu-close&#x27;])) {
              var closestMenu = $mdUtil.getClosest(target, &#x27;MD-MENU&#x27;);
              if (!target.hasAttribute(&#x27;disabled&#x27;) &amp;&amp; (!closestMenu || closestMenu == opts.parent[0])) {
                close();
              }
              break;
            }
          } while (target = target.parentNode)

          function close() {
            scope.$apply(function() {
              opts.mdMenuCtrl.close(true, { closeAll: true });
            });
          }

          function hasAnyAttribute(target, attrs) {
            if (!target) return false;
            for (var i = 0, attr; attr = attrs[i]; ++i) {
              var altForms = [attr, &#x27;data-&#x27; + attr, &#x27;x-&#x27; + attr];
              for (var j = 0, rawAttr; rawAttr = altForms[j]; ++j) {
                if (target.hasAttribute(rawAttr)) {
                  return true;
                }
              }
            }
            return false;
          }
        }

        opts.menuContentEl[0].addEventListener(&#x27;click&#x27;, captureClickListener, true);

        return function cleanupInteraction() {
          element.removeClass(&#x27;md-clickable&#x27;);
          opts.menuContentEl.off(&#x27;keydown&#x27;);
          opts.menuContentEl[0].removeEventListener(&#x27;click&#x27;, captureClickListener, true);
        };
      }
    }

    /**
     * Takes a keypress event and focuses the next/previous menu
     * item from the emitting element
     * @param {event} e - The origin keypress event
     * @param {angular.element} menuEl - The menu element
     * @param {object} opts - The interim element options for the mdMenu
     * @param {number} direction - The direction to move in (+1 = next, -1 = prev)
     */
    function focusMenuItem(e, menuEl, opts, direction) {
      var currentItem = $mdUtil.getClosest(e.target, &#x27;MD-MENU-ITEM&#x27;);

      var items = $mdUtil.nodesToArray(menuEl[0].children);
      var currentIndex = items.indexOf(currentItem);

      // Traverse through our elements in the specified direction (+/-1) and try to
      // focus them until we find one that accepts focus
      var didFocus;
      for (var i = currentIndex + direction; i &gt;= 0 &amp;&amp; i &lt; items.length; i = i + direction) {
        var focusTarget = items[i].querySelector(&#x27;.md-button&#x27;);
        didFocus = attemptFocus(focusTarget);
        if (didFocus) {
          break;
        }
      }
      return didFocus;
    }

    /**
     * Attempts to focus an element. Checks whether that element is the currently
     * focused element after attempting.
     * @param {HTMLElement} el - the element to attempt focus on
     * @returns {bool} - whether the element was successfully focused
     */
    function attemptFocus(el) {
      if (el &amp;&amp; el.getAttribute(&#x27;tabindex&#x27;) != -1) {
        el.focus();
        return ($document[0].activeElement == el);
      }
    }

    /**
     * Use browser to remove this element without triggering a $destroy event
     */
    function detachElement(element, opts) {
      if (!opts.preserveElement) {
        if (toNode(element).parentNode === toNode(opts.parent)) {
          toNode(opts.parent).removeChild(toNode(element));
        }
      } else {
        toNode(element).style.display = &#x27;none&#x27;;
      }
    }

    /**
     * Computes menu position and sets the style on the menu container
     * @param {HTMLElement} el - the menu container element
     * @param {object} opts - the interim element options object
     */
    function calculateMenuPosition(el, opts) {

      var containerNode = el[0],
        openMenuNode = el[0].firstElementChild,
        openMenuNodeRect = openMenuNode.getBoundingClientRect(),
        boundryNode = $document[0].body,
        boundryNodeRect = boundryNode.getBoundingClientRect();

      var menuStyle = $window.getComputedStyle(openMenuNode);

      var originNode = opts.target[0].querySelector(&#x27;[md-menu-origin]&#x27;) || opts.target[0],
        originNodeRect = originNode.getBoundingClientRect();

      var bounds = {
        left: boundryNodeRect.left + MENU_EDGE_MARGIN,
        top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
        bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
        right: boundryNodeRect.right - MENU_EDGE_MARGIN
      };

      var alignTarget, alignTargetRect = { top:0, left : 0, right:0, bottom:0 }, existingOffsets  = { top:0, left : 0, right:0, bottom:0  };
      var positionMode = opts.mdMenuCtrl.positionMode();

      if (positionMode.top == &#x27;target&#x27; || positionMode.left == &#x27;target&#x27; || positionMode.left == &#x27;target-right&#x27;) {
        alignTarget = firstVisibleChild();
        if ( alignTarget ) {
          // TODO: Allow centering on an arbitrary node, for now center on first menu-item&#x27;s child
          alignTarget = alignTarget.firstElementChild || alignTarget;
          alignTarget = alignTarget.querySelector(&#x27;[md-menu-align-target]&#x27;) || alignTarget;
          alignTargetRect = alignTarget.getBoundingClientRect();

          existingOffsets = {
            top: parseFloat(containerNode.style.top || 0),
            left: parseFloat(containerNode.style.left || 0)
          };
        }
      }

      var position = {};
      var transformOrigin = &#x27;top &#x27;;

      switch (positionMode.top) {
        case &#x27;target&#x27;:
          position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
          break;
        case &#x27;cascade&#x27;:
          position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
          break;
        case &#x27;bottom&#x27;:
          position.top = originNodeRect.top + originNodeRect.height;
          break;
        default:
          throw new Error(&#x27;Invalid target mode &quot;&#x27; + positionMode.top + &#x27;&quot; specified for md-menu on Y axis.&#x27;);
      }

      switch (positionMode.left) {
        case &#x27;target&#x27;:
          position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
          transformOrigin += &#x27;left&#x27;;
          break;
        case &#x27;target-right&#x27;:
          position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
          transformOrigin += &#x27;right&#x27;;
          break;
        case &#x27;cascade&#x27;:
          var willFitRight = (originNodeRect.right + openMenuNodeRect.width) &lt; bounds.right;
          position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
          transformOrigin += willFitRight ? &#x27;left&#x27; : &#x27;right&#x27;;
          break;
        case &#x27;left&#x27;:
          position.left = originNodeRect.left;
          transformOrigin += &#x27;left&#x27;;
          break;
        default:
          throw new Error(&#x27;Invalid target mode &quot;&#x27; + positionMode.left + &#x27;&quot; specified for md-menu on X axis.&#x27;);
      }

      var offsets = opts.mdMenuCtrl.offsets();
      position.top += offsets.top;
      position.left += offsets.left;

      clamp(position);

      var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
      var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;

      return {
        top: Math.round(position.top),
        left: Math.round(position.left),
        // Animate a scale out if we aren&#x27;t just repositioning
        transform: !opts.alreadyOpen ? $mdUtil.supplant(&#x27;scale({0},{1})&#x27;, [scaleX, scaleY]) : undefined,
        transformOrigin: transformOrigin
      };

      /**
       * Clamps the repositioning of the menu within the confines of
       * bounding element (often the screen/body)
       */
      function clamp(pos) {
        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
      }

      /**
       * Gets the first visible child in the openMenuNode
       * Necessary incase menu nodes are being dynamically hidden
       */
      function firstVisibleChild() {
        for (var i = 0; i &lt; openMenuNode.children.length; ++i) {
          if ($window.getComputedStyle(openMenuNode.children[i]).display != &#x27;none&#x27;) {
            return openMenuNode.children[i];
          }
        }
      }
    }
  }
  function toNode(el) {
    if (el instanceof angular.element) {
      el = el[0];
    }
    return el;
  }
}
MenuProvider.$inject = [&quot;$$interimElementProvider&quot;];

ng.material.components.menu = angular.module(&quot;material.components.menu&quot;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
