<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>frontend\web\bower_components\angular-material\modules\closure\gridList\gridList.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend..html">adminPanelController
                
                Responsible for every functionality given by the administrator panel for the frontend.</a></li>
                                <li><a href="../classes/our routes.html">our routes</a></li>
                                <li><a href="../classes/personAutoController.html">personAutoController</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/adminPanelController.html">adminPanelController</a></li>
                                <li><a href="../modules/material.components.autocomplete.html">material.components.autocomplete</a></li>
                                <li><a href="../modules/material.components.backdrop.html">material.components.backdrop</a></li>
                                <li><a href="../modules/material.components.bottomSheet.html">material.components.bottomSheet</a></li>
                                <li><a href="../modules/material.components.button.html">material.components.button</a></li>
                                <li><a href="../modules/material.components.card.html">material.components.card</a></li>
                                <li><a href="../modules/material.components.checkbox.html">material.components.checkbox</a></li>
                                <li><a href="../modules/material.components.chips.html">material.components.chips</a></li>
                                <li><a href="../modules/material.components.content.html">material.components.content</a></li>
                                <li><a href="../modules/material.components.datepicker.html">material.components.datepicker</a></li>
                                <li><a href="../modules/material.components.dialog.html">material.components.dialog</a></li>
                                <li><a href="../modules/material.components.divider.html">material.components.divider</a></li>
                                <li><a href="../modules/material.components.fabActions.html">material.components.fabActions</a></li>
                                <li><a href="../modules/material.components.fabSpeedDial.html">material.components.fabSpeedDial</a></li>
                                <li><a href="../modules/material.components.fabToolbar.html">material.components.fabToolbar</a></li>
                                <li><a href="../modules/material.components.gridList.html">material.components.gridList</a></li>
                                <li><a href="../modules/material.components.icon.html">material.components.icon</a></li>
                                <li><a href="../modules/material.components.input.html">material.components.input</a></li>
                                <li><a href="../modules/material.components.list.html">material.components.list</a></li>
                                <li><a href="../modules/material.components.menu.html">material.components.menu</a></li>
                                <li><a href="../modules/material.components.menu-bar.html">material.components.menu-bar</a></li>
                                <li><a href="../modules/material.components.progressCircular.html">material.components.progressCircular</a></li>
                                <li><a href="../modules/material.components.progressLinear.html">material.components.progressLinear</a></li>
                                <li><a href="../modules/material.components.radioButton.html">material.components.radioButton</a></li>
                                <li><a href="../modules/material.components.select.html">material.components.select</a></li>
                                <li><a href="../modules/material.components.sidenav.html">material.components.sidenav</a></li>
                                <li><a href="../modules/material.components.slider.html">material.components.slider</a></li>
                                <li><a href="../modules/material.components.sticky.html">material.components.sticky</a></li>
                                <li><a href="../modules/material.components.subheader.html">material.components.subheader</a></li>
                                <li><a href="../modules/material.components.swipe.html">material.components.swipe</a></li>
                                <li><a href="../modules/material.components.switch.html">material.components.switch</a></li>
                                <li><a href="../modules/material.components.tabs.html">material.components.tabs</a></li>
                                <li><a href="../modules/material.components.toast.html">material.components.toast</a></li>
                                <li><a href="../modules/material.components.toolbar.html">material.components.toolbar</a></li>
                                <li><a href="../modules/material.components.tooltip.html">material.components.tooltip</a></li>
                                <li><a href="../modules/material.components.virtualRepeat.html">material.components.virtualRepeat</a></li>
                                <li><a href="../modules/material.components.whiteframe.html">material.components.whiteframe</a></li>
                                <li><a href="../modules/material.core.html">material.core</a></li>
                                <li><a href="../modules/material.core.gestures.html">material.core.gestures</a></li>
                                <li><a href="../modules/material.core.ripple.html">material.core.ripple</a></li>
                                <li><a href="../modules/material.core.theming.html">material.core.theming</a></li>
                                <li><a href="../modules/material.core.util.html">material.core.util</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                                <li><a href="../modules/personAutoController.html">personAutoController</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: frontend\web\bower_components\angular-material\modules\closure\gridList\gridList.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.6
 */
goog.provide(&#x27;ng.material.components.gridList&#x27;);
goog.require(&#x27;ng.material.core&#x27;);
/**
 * @ngdoc module
 * @name material.components.gridList
 */
angular.module(&#x27;material.components.gridList&#x27;, [&#x27;material.core&#x27;])
       .directive(&#x27;mdGridList&#x27;, GridListDirective)
       .directive(&#x27;mdGridTile&#x27;, GridTileDirective)
       .directive(&#x27;mdGridTileFooter&#x27;, GridTileCaptionDirective)
       .directive(&#x27;mdGridTileHeader&#x27;, GridTileCaptionDirective)
       .factory(&#x27;$mdGridLayout&#x27;, GridLayoutFactory);

/**
 * @ngdoc directive
 * @name mdGridList
 * @module material.components.gridList
 * @restrict E
 * @description
 * Grid lists are an alternative to standard list views. Grid lists are distinct
 * from grids used for layouts and other visual presentations.
 *
 * A grid list is best suited to presenting a homogenous data type, typically
 * images, and is optimized for visual comprehension and differentiating between
 * like data types.
 *
 * A grid list is a continuous element consisting of tessellated, regular
 * subdivisions called cells that contain tiles (&#x60;md-grid-tile&#x60;).
 *
 * &lt;img src=&quot;//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png&quot;
 *    style=&quot;width: 300px; height: auto; margin-right: 16px;&quot; alt=&quot;Concept of grid explained visually&quot;&gt;
 * &lt;img src=&quot;//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png&quot;
 *    style=&quot;width: 300px; height: auto;&quot; alt=&quot;Grid concepts legend&quot;&gt;
 *
 * Cells are arrayed vertically and horizontally within the grid.
 *
 * Tiles hold content and can span one or more cells vertically or horizontally.
 *
 * ### Responsive Attributes
 *
 * The &#x60;md-grid-list&#x60; directive supports &quot;responsive&quot; attributes, which allow
 * different &#x60;md-cols&#x60;, &#x60;md-gutter&#x60; and &#x60;md-row-height&#x60; values depending on the
 * currently matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: &#x60;{base-attribute-name}-{media-query-name}=&quot;{value}&quot;&#x60;
 * (ie. &#x60;md-cols-lg=&quot;8&quot;&#x60;)
 *
 * @param {number} md-cols Number of columns in the grid.
 * @param {string} md-row-height One of
 * &lt;ul&gt;
 *   &lt;li&gt;CSS length - Fixed height rows (eg. &#x60;8px&#x60; or &#x60;1rem&#x60;)&lt;/li&gt;
 *   &lt;li&gt;&#x60;{width}:{height}&#x60; - Ratio of width to height (eg.
 *   &#x60;md-row-height=&quot;16:9&quot;&#x60;)&lt;/li&gt;
 *   &lt;li&gt;&#x60;&quot;fit&quot;&#x60; - Height will be determined by subdividing the available
 *   height by the number of rows&lt;/li&gt;
 * &lt;/ul&gt;
 * @param {string=} md-gutter The amount of space between tiles in CSS units
 *     (default 1px)
 * @param {expression=} md-on-layout Expression to evaluate after layout. Event
 *     object is available as &#x60;$event&#x60;, and contains performance information.
 *
 * @usage
 * Basic:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-list md-cols=&quot;5&quot; md-gutter=&quot;1em&quot; md-row-height=&quot;4:3&quot;&gt;
 *   &lt;md-grid-tile&gt;&lt;/md-grid-tile&gt;
 * &lt;/md-grid-list&gt;
 * &lt;/hljs&gt;
 *
 * Fixed-height rows:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-list md-cols=&quot;4&quot; md-row-height=&quot;200px&quot; ...&gt;
 *   &lt;md-grid-tile&gt;&lt;/md-grid-tile&gt;
 * &lt;/md-grid-list&gt;
 * &lt;/hljs&gt;
 *
 * Fit rows:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-list md-cols=&quot;4&quot; md-row-height=&quot;fit&quot; style=&quot;height: 400px;&quot; ...&gt;
 *   &lt;md-grid-tile&gt;&lt;/md-grid-tile&gt;
 * &lt;/md-grid-list&gt;
 * &lt;/hljs&gt;
 *
 * Using responsive attributes:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-list
 *     md-cols-sm=&quot;2&quot;
 *     md-cols-md=&quot;4&quot;
 *     md-cols-lg=&quot;8&quot;
 *     md-cols-gt-lg=&quot;12&quot;
 *     ...&gt;
 *   &lt;md-grid-tile&gt;&lt;/md-grid-tile&gt;
 * &lt;/md-grid-list&gt;
 * &lt;/hljs&gt;
 */
function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
  return {
    restrict: &#x27;E&#x27;,
    controller: GridListController,
    scope: {
      mdOnLayout: &#x27;&amp;&#x27;
    },
    link: postLink
  };

  function postLink(scope, element, attrs, ctrl) {
    // Apply semantics
    element.attr(&#x27;role&#x27;, &#x27;list&#x27;);

    // Provide the controller with a way to trigger layouts.
    ctrl.layoutDelegate = layoutDelegate;

    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
        unwatchAttrs = watchMedia();
      scope.$on(&#x27;$destroy&#x27;, unwatchMedia);

    /**
     * Watches for changes in media, invalidating layout as necessary.
     */
    function watchMedia() {
      for (var mediaName in $mdConstant.MEDIA) {
        $mdMedia(mediaName); // initialize
        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])
            .addListener(invalidateLayout);
      }
      return $mdMedia.watchResponsiveAttributes(
          [&#x27;md-cols&#x27;, &#x27;md-row-height&#x27;, &#x27;md-gutter&#x27;], attrs, layoutIfMediaMatch);
    }

    function unwatchMedia() {
      ctrl.layoutDelegate = angular.noop;

      unwatchAttrs();
      for (var mediaName in $mdConstant.MEDIA) {
        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])
            .removeListener(invalidateLayout);
      }
    }

    /**
     * Performs grid layout if the provided mediaName matches the currently
     * active media type.
     */
    function layoutIfMediaMatch(mediaName) {
      if (mediaName == null) {
        // TODO(shyndman): It would be nice to only layout if we have
        // instances of attributes using this media type
        ctrl.invalidateLayout();
      } else if ($mdMedia(mediaName)) {
        ctrl.invalidateLayout();
      }
    }

    var lastLayoutProps;

    /**
     * Invokes the layout engine, and uses its results to lay out our
     * tile elements.
     *
     * @param {boolean} tilesInvalidated Whether tiles have been
     *    added/removed/moved since the last layout. This is to avoid situations
     *    where tiles are replaced with properties identical to their removed
     *    counterparts.
     */
    function layoutDelegate(tilesInvalidated) {
      var tiles = getTileElements();
      var props = {
        tileSpans: getTileSpans(tiles),
        colCount: getColumnCount(),
        rowMode: getRowMode(),
        rowHeight: getRowHeight(),
        gutter: getGutter()
      };

      if (!tilesInvalidated &amp;&amp; angular.equals(props, lastLayoutProps)) {
        return;
      }

      var performance =
        $mdGridLayout(props.colCount, props.tileSpans, tiles)
          .map(function(tilePositions, rowCount) {
            return {
              grid: {
                element: element,
                style: getGridStyle(props.colCount, rowCount,
                    props.gutter, props.rowMode, props.rowHeight)
              },
              tiles: tilePositions.map(function(ps, i) {
                return {
                  element: angular.element(tiles[i]),
                  style: getTileStyle(ps.position, ps.spans,
                      props.colCount, rowCount,
                      props.gutter, props.rowMode, props.rowHeight)
                }
              })
            }
          })
          .reflow()
          .performance();

      // Report layout
      scope.mdOnLayout({
        $event: {
          performance: performance
        }
      });

      lastLayoutProps = props;
    }

    // Use $interpolate to do some simple string interpolation as a convenience.

    var startSymbol = $interpolate.startSymbol();
    var endSymbol = $interpolate.endSymbol();

    // Returns an expression wrapped in the interpolator&#x27;s start and end symbols.
    function expr(exprStr) {
      return startSymbol + exprStr + endSymbol;
    }

    // The amount of space a single 1x1 tile would take up (either width or height), used as
    // a basis for other calculations. This consists of taking the base size percent (as would be
    // if evenly dividing the size between cells), and then subtracting the size of one gutter.
    // However, since there are no gutters on the edges, each tile only uses a fration
    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per
    // tile, and then breaking up the extra gutter on the edge evenly among the cells).
    var UNIT = $interpolate(expr(&#x27;share&#x27;) + &#x27;% - (&#x27; + expr(&#x27;gutter&#x27;) + &#x27; * &#x27; + expr(&#x27;gutterShare&#x27;) + &#x27;)&#x27;);

    // The horizontal or vertical position of a tile, e.g., the &#x27;top&#x27; or &#x27;left&#x27; property value.
    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
    // row/column (offset).
    var POSITION  = $interpolate(&#x27;calc((&#x27; + expr(&#x27;unit&#x27;) + &#x27; + &#x27; + expr(&#x27;gutter&#x27;) + &#x27;) * &#x27; + expr(&#x27;offset&#x27;) + &#x27;)&#x27;);

    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.
    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back
    // in the space that the gutter would normally have used (which was already accounted for in
    // the base unit calculation).
    var DIMENSION = $interpolate(&#x27;calc((&#x27; + expr(&#x27;unit&#x27;) + &#x27;) * &#x27; + expr(&#x27;span&#x27;) + &#x27; + (&#x27; + expr(&#x27;span&#x27;) + &#x27; - 1) * &#x27; + expr(&#x27;gutter&#x27;) + &#x27;)&#x27;);

    /**
     * Gets the styles applied to a tile element described by the given parameters.
     * @param {{row: number, col: number}} position The row and column indices of the tile.
     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.
     * @param {number} colCount The number of columns.
     * @param {number} rowCount The number of rows.
     * @param {string} gutter The amount of space between tiles. This will be something like
     *     &#x27;5px&#x27; or &#x27;2em&#x27;.
     * @param {string} rowMode The row height mode. Can be one of:
     *     &#x27;fixed&#x27;: all rows have a fixed size, given by rowHeight,
     *     &#x27;ratio&#x27;: row height defined as a ratio to width, or
     *     &#x27;fit&#x27;: fit to the grid-list element height, divinding evenly among rows.
     * @param {string|number} rowHeight The height of a row. This is only used for &#x27;fixed&#x27; mode and
     *     for &#x27;ratio&#x27; mode. For &#x27;ratio&#x27; mode, this is the *ratio* of width-to-height (e.g., 0.75).
     * @returns {Object} Map of CSS properties to be applied to the style element. Will define
     *     values for top, left, width, height, marginTop, and paddingTop.
     */
    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
      // TODO(shyndman): There are style caching opportunities here.

      // Percent of the available horizontal space that one column takes up.
      var hShare = (1 / colCount) * 100;

      // Fraction of the gutter size that each column takes up.
      var hGutterShare = (colCount - 1) / colCount;

      // Base horizontal size of a column.
      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});

      // The width and horizontal position of each tile is always calculated the same way, but the
      // height and vertical position depends on the rowMode.
      var style = {
        left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),
        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),
        // resets
        paddingTop: &#x27;&#x27;,
        marginTop: &#x27;&#x27;,
        top: &#x27;&#x27;,
        height: &#x27;&#x27;
      };

      switch (rowMode) {
        case &#x27;fixed&#x27;:
          // In fixed mode, simply use the given rowHeight.
          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });
          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });
          break;

        case &#x27;ratio&#x27;:
          // Percent of the available vertical space that one row takes up. Here, rowHeight holds
          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.
          var vShare = hShare / rowHeight;

          // Base veritcal size of a row.
          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });

          // padidngTop and marginTop are used to maintain the given aspect ratio, as
          // a percentage-based value for these properties is applied to the *width* of the
          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});
          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });
          break;

        case &#x27;fit&#x27;:
          // Fraction of the gutter size that each column takes up.
          var vGutterShare = (rowCount - 1) / rowCount;

          // Percent of the available vertical space that one row takes up.
          var vShare = (1 / rowCount) * 100;

          // Base vertical size of a row.
          var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});

          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});
          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});
          break;
      }

      return style;
    }

    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
      var style = {};

      switch(rowMode) {
        case &#x27;fixed&#x27;:
          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });
          style.paddingBottom = &#x27;&#x27;;
          break;

        case &#x27;ratio&#x27;:
          // rowHeight is width / height
          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
              hShare = (1 / colCount) * 100,
              vShare = hShare * (1 / rowHeight),
              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });

          style.height = &#x27;&#x27;;
          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});
          break;

        case &#x27;fit&#x27;:
          // noop, as the height is user set
          break;
      }

      return style;
    }

    function getTileElements() {
      return [].filter.call(element.children(), function(ele) {
        return ele.tagName == &#x27;MD-GRID-TILE&#x27; &amp;&amp; !ele.$$mdDestroyed;
      });
    }

    /**
     * Gets an array of objects containing the rowspan and colspan for each tile.
     * @returns {Array&lt;{row: number, col: number}&gt;}
     */
    function getTileSpans(tileElements) {
      return [].map.call(tileElements, function(ele) {
        var ctrl = angular.element(ele).controller(&#x27;mdGridTile&#x27;);
        return {
          row: parseInt(
              $mdMedia.getResponsiveAttribute(ctrl.$attrs, &#x27;md-rowspan&#x27;), 10) || 1,
          col: parseInt(
              $mdMedia.getResponsiveAttribute(ctrl.$attrs, &#x27;md-colspan&#x27;), 10) || 1
        };
      });
    }

    function getColumnCount() {
      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, &#x27;md-cols&#x27;), 10);
      if (isNaN(colCount)) {
        throw &#x27;md-grid-list: md-cols attribute was not found, or contained a non-numeric value&#x27;;
      }
      return colCount;
    }

    function getGutter() {
      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, &#x27;md-gutter&#x27;) || 1);
    }

    function getRowHeight() {
      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, &#x27;md-row-height&#x27;);
      switch (getRowMode()) {
        case &#x27;fixed&#x27;:
          return applyDefaultUnit(rowHeight);
        case &#x27;ratio&#x27;:
          var whRatio = rowHeight.split(&#x27;:&#x27;);
          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
        case &#x27;fit&#x27;:
          return 0; // N/A
      }
    }

    function getRowMode() {
      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, &#x27;md-row-height&#x27;);
      if (rowHeight == &#x27;fit&#x27;) {
        return &#x27;fit&#x27;;
      } else if (rowHeight.indexOf(&#x27;:&#x27;) !== -1) {
        return &#x27;ratio&#x27;;
      } else {
        return &#x27;fixed&#x27;;
      }
    }

    function applyDefaultUnit(val) {
      return /\D$/.test(val) ? val : val + &#x27;px&#x27;;
    }
  }
}
GridListDirective.$inject = [&quot;$interpolate&quot;, &quot;$mdConstant&quot;, &quot;$mdGridLayout&quot;, &quot;$mdMedia&quot;];

/* ngInject */
function GridListController($mdUtil) {
  this.layoutInvalidated = false;
  this.tilesInvalidated = false;
  this.$timeout_ = $mdUtil.nextTick;
  this.layoutDelegate = angular.noop;
}
GridListController.$inject = [&quot;$mdUtil&quot;];

GridListController.prototype = {
  invalidateTiles: function() {
    this.tilesInvalidated = true;
    this.invalidateLayout();
  },

  invalidateLayout: function() {
    if (this.layoutInvalidated) {
      return;
    }
    this.layoutInvalidated = true;
    this.$timeout_(angular.bind(this, this.layout));
  },

  layout: function() {
    try {
      this.layoutDelegate(this.tilesInvalidated);
    } finally {
      this.layoutInvalidated = false;
      this.tilesInvalidated = false;
    }
  }
};


/* ngInject */
function GridLayoutFactory($mdUtil) {
  var defaultAnimator = GridTileAnimator;

  /**
   * Set the reflow animator callback
   */
  GridLayout.animateWith = function(customAnimator) {
    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
  };

  return GridLayout;

  /**
   * Publish layout function
   */
  function GridLayout(colCount, tileSpans) {
      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;

      layoutTime = $mdUtil.time(function() {
        layoutInfo = calculateGridFor(colCount, tileSpans);
      });

      return self = {

        /**
         * An array of objects describing each tile&#x27;s position in the grid.
         */
        layoutInfo: function() {
          return layoutInfo;
        },

        /**
         * Maps grid positioning to an element and a set of styles using the
         * provided updateFn.
         */
        map: function(updateFn) {
          mapTime = $mdUtil.time(function() {
            var info = self.layoutInfo();
            gridStyles = updateFn(info.positioning, info.rowCount);
          });
          return self;
        },

        /**
         * Default animator simply sets the element.css( &lt;styles&gt; ). An alternate
         * animator can be provided as an argument. The function has the following
         * signature:
         *
         *    function({grid: {element: JQLite, style: Object}, tiles: Array&lt;{element: JQLite, style: Object}&gt;)
         */
        reflow: function(animatorFn) {
          reflowTime = $mdUtil.time(function() {
            var animator = animatorFn || defaultAnimator;
            animator(gridStyles.grid, gridStyles.tiles);
          });
          return self;
        },

        /**
         * Timing for the most recent layout run.
         */
        performance: function() {
          return {
            tileCount: tileSpans.length,
            layoutTime: layoutTime,
            mapTime: mapTime,
            reflowTime: reflowTime,
            totalTime: layoutTime + mapTime + reflowTime
          };
        }
      };
    }

  /**
   * Default Gridlist animator simple sets the css for each element;
   * NOTE: any transitions effects must be manually set in the CSS.
   * e.g.
   *
   *  md-grid-tile {
   *    transition: all 700ms ease-out 50ms;
   *  }
   *
   */
  function GridTileAnimator(grid, tiles) {
    grid.element.css(grid.style);
    tiles.forEach(function(t) {
      t.element.css(t.style);
    })
  }

  /**
   * Calculates the positions of tiles.
   *
   * The algorithm works as follows:
   *    An Array&lt;Number&gt; with length colCount (spaceTracker) keeps track of
   *    available tiling positions, where elements of value 0 represents an
   *    empty position. Space for a tile is reserved by finding a sequence of
   *    0s with length &lt;= than the tile&#x27;s colspan. When such a space has been
   *    found, the occupied tile positions are incremented by the tile&#x27;s
   *    rowspan value, as these positions have become unavailable for that
   *    many rows.
   *
   *    If the end of a row has been reached without finding space for the
   *    tile, spaceTracker&#x27;s elements are each decremented by 1 to a minimum
   *    of 0. Rows are searched in this fashion until space is found.
   */
  function calculateGridFor(colCount, tileSpans) {
    var curCol = 0,
        curRow = 0,
        spaceTracker = newSpaceTracker();

    return {
      positioning: tileSpans.map(function(spans, i) {
        return {
          spans: spans,
          position: reserveSpace(spans, i)
        };
      }),
      rowCount: curRow + Math.max.apply(Math, spaceTracker)
    };

    function reserveSpace(spans, i) {
      if (spans.col &gt; colCount) {
        throw &#x27;md-grid-list: Tile at position &#x27; + i + &#x27; has a colspan &#x27; +
            &#x27;(&#x27; + spans.col + &#x27;) that exceeds the column count &#x27; +
            &#x27;(&#x27; + colCount + &#x27;)&#x27;;
      }

      var start = 0,
          end = 0;

      // TODO(shyndman): This loop isn&#x27;t strictly necessary if you can
      // determine the minimum number of rows before a space opens up. To do
      // this, recognize that you&#x27;ve iterated across an entire row looking for
      // space, and if so fast-forward by the minimum rowSpan count. Repeat
      // until the required space opens up.
      while (end - start &lt; spans.col) {
        if (curCol &gt;= colCount) {
          nextRow();
          continue;
        }

        start = spaceTracker.indexOf(0, curCol);
        if (start === -1 || (end = findEnd(start + 1)) === -1) {
          start = end = 0;
          nextRow();
          continue;
        }

        curCol = end + 1;
      }

      adjustRow(start, spans.col, spans.row);
      curCol = start + spans.col;

      return {
        col: start,
        row: curRow
      };
    }

    function nextRow() {
      curCol = 0;
      curRow++;
      adjustRow(0, colCount, -1); // Decrement row spans by one
    }

    function adjustRow(from, cols, by) {
      for (var i = from; i &lt; from + cols; i++) {
        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
      }
    }

    function findEnd(start) {
      var i;
      for (i = start; i &lt; spaceTracker.length; i++) {
        if (spaceTracker[i] !== 0) {
          return i;
        }
      }

      if (i === spaceTracker.length) {
        return i;
      }
    }

    function newSpaceTracker() {
      var tracker = [];
      for (var i = 0; i &lt; colCount; i++) {
        tracker.push(0);
      }
      return tracker;
    }
  }
}
GridLayoutFactory.$inject = [&quot;$mdUtil&quot;];

/**
 * @ngdoc directive
 * @name mdGridTile
 * @module material.components.gridList
 * @restrict E
 * @description
 * Tiles contain the content of an &#x60;md-grid-list&#x60;. They span one or more grid
 * cells vertically or horizontally, and use &#x60;md-grid-tile-{footer,header}&#x60; to
 * display secondary content.
 *
 * ### Responsive Attributes
 *
 * The &#x60;md-grid-tile&#x60; directive supports &quot;responsive&quot; attributes, which allow
 * different &#x60;md-rowspan&#x60; and &#x60;md-colspan&#x60; values depending on the currently
 * matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: &#x60;{base-attribute-name}-{media-query-name}=&quot;{value}&quot;&#x60;
 * (ie. &#x60;md-colspan-sm=&quot;4&quot;&#x60;)
 *
 * @param {number=} md-colspan The number of columns to span (default 1). Cannot
 *    exceed the number of columns in the grid. Supports interpolation.
 * @param {number=} md-rowspan The number of rows to span (default 1). Supports
 *     interpolation.
 *
 * @usage
 * With header:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-tile&gt;
 *   &lt;md-grid-tile-header&gt;
 *     &lt;h3&gt;This is a header&lt;/h3&gt;
 *   &lt;/md-grid-tile-header&gt;
 * &lt;/md-grid-tile&gt;
 * &lt;/hljs&gt;
 *
 * With footer:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-tile&gt;
 *   &lt;md-grid-tile-footer&gt;
 *     &lt;h3&gt;This is a footer&lt;/h3&gt;
 *   &lt;/md-grid-tile-footer&gt;
 * &lt;/md-grid-tile&gt;
 * &lt;/hljs&gt;
 *
 * Spanning multiple rows/columns:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-tile md-colspan=&quot;2&quot; md-rowspan=&quot;3&quot;&gt;
 * &lt;/md-grid-tile&gt;
 * &lt;/hljs&gt;
 *
 * Responsive attributes:
 * &lt;hljs lang=&quot;html&quot;&gt;
 * &lt;md-grid-tile md-colspan=&quot;1&quot; md-colspan-sm=&quot;3&quot; md-colspan-md=&quot;5&quot;&gt;
 * &lt;/md-grid-tile&gt;
 * &lt;/hljs&gt;
 */
function GridTileDirective($mdMedia) {
  return {
    restrict: &#x27;E&#x27;,
    require: &#x27;^mdGridList&#x27;,
    template: &#x27;&lt;figure ng-transclude&gt;&lt;/figure&gt;&#x27;,
    transclude: true,
    scope: {},
    // Simple controller that exposes attributes to the grid directive
    controller: [&quot;$attrs&quot;, function($attrs) {
      this.$attrs = $attrs;
    }],
    link: postLink
  };

  function postLink(scope, element, attrs, gridCtrl) {
    // Apply semantics
    element.attr(&#x27;role&#x27;, &#x27;listitem&#x27;);

    // If our colspan or rowspan changes, trigger a layout
    var unwatchAttrs = $mdMedia.watchResponsiveAttributes([&#x27;md-colspan&#x27;, &#x27;md-rowspan&#x27;],
        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));

    // Tile registration/deregistration
    gridCtrl.invalidateTiles();
    scope.$on(&#x27;$destroy&#x27;, function() {
      // Mark the tile as destroyed so it is no longer considered in layout,
      // even if the DOM element sticks around (like during a leave animation)
      element[0].$$mdDestroyed = true;
      unwatchAttrs();
      gridCtrl.invalidateLayout();
    });

    if (angular.isDefined(scope.$parent.$index)) {
      scope.$watch(function() { return scope.$parent.$index; },
        function indexChanged(newIdx, oldIdx) {
          if (newIdx === oldIdx) {
            return;
          }
          gridCtrl.invalidateTiles();
        });
    }
  }
}
GridTileDirective.$inject = [&quot;$mdMedia&quot;];


function GridTileCaptionDirective() {
  return {
    template: &#x27;&lt;figcaption ng-transclude&gt;&lt;/figcaption&gt;&#x27;,
    transclude: true
  };
}

ng.material.components.gridList = angular.module(&quot;material.components.gridList&quot;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
